<!doctype html>
<html lang="zh-Hans" dir="ltr" class="docs-wrapper plugin-docs plugin-id-middleware docs-version-current docs-doc-page docs-doc-id-mysql/Mysql-Optimize-2" data-has-hydrated="false">
<head>
<meta charset="UTF-8">
<meta name="generator" content="Docusaurus v3.0.1">
<title data-rh="true">Mysql-Optimize-2 | Light Docusaurus</title><meta data-rh="true" name="viewport" content="width=device-width,initial-scale=1"><meta data-rh="true" name="twitter:card" content="summary_large_image"><meta data-rh="true" property="og:image" content="https://lorchr.github.io/light-docusaurus/img/docusaurus-social-card.jpg"><meta data-rh="true" name="twitter:image" content="https://lorchr.github.io/light-docusaurus/img/docusaurus-social-card.jpg"><meta data-rh="true" property="og:url" content="https://lorchr.github.io/light-docusaurus/middleware/mysql/Mysql-Optimize-2/"><meta data-rh="true" property="og:locale" content="zh_Hans"><meta data-rh="true" name="docusaurus_locale" content="zh-Hans"><meta data-rh="true" name="docsearch:language" content="zh-Hans"><meta data-rh="true" name="docusaurus_version" content="current"><meta data-rh="true" name="docusaurus_tag" content="docs-middleware-current"><meta data-rh="true" name="docsearch:version" content="current"><meta data-rh="true" name="docsearch:docusaurus_tag" content="docs-middleware-current"><meta data-rh="true" property="og:title" content="Mysql-Optimize-2 | Light Docusaurus"><meta data-rh="true" name="description" content="- 万字长文，讲懂SQL调优，还不会，来找我"><meta data-rh="true" property="og:description" content="- 万字长文，讲懂SQL调优，还不会，来找我"><link data-rh="true" rel="icon" href="/light-docusaurus/img/favicon.ico"><link data-rh="true" rel="canonical" href="https://lorchr.github.io/light-docusaurus/middleware/mysql/Mysql-Optimize-2/"><link data-rh="true" rel="alternate" href="https://lorchr.github.io/light-docusaurus/middleware/mysql/Mysql-Optimize-2/" hreflang="zh-Hans"><link data-rh="true" rel="alternate" href="https://lorchr.github.io/light-docusaurus/middleware/mysql/Mysql-Optimize-2/" hreflang="x-default"><link data-rh="true" rel="preconnect" href="https://TLGHDZ3Y2I-dsn.algolia.net" crossorigin="anonymous"><link rel="alternate" type="application/rss+xml" href="/light-docusaurus/blog/rss.xml" title="Light Docusaurus RSS Feed">
<link rel="alternate" type="application/atom+xml" href="/light-docusaurus/blog/atom.xml" title="Light Docusaurus Atom Feed">



<link rel="search" type="application/opensearchdescription+xml" title="Light Docusaurus" href="/light-docusaurus/opensearch.xml"><link rel="stylesheet" href="/light-docusaurus/assets/css/styles.609e5209.css">
<script src="/light-docusaurus/assets/js/runtime~main.4e92a8d4.js" defer="defer"></script>
<script src="/light-docusaurus/assets/js/main.a10fa4bc.js" defer="defer"></script>
</head>
<body class="navigation-with-keyboard">
<script>!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){try{return new URLSearchParams(window.location.search).get("docusaurus-theme")}catch(t){}}()||function(){try{return localStorage.getItem("theme")}catch(t){}}();t(null!==e?e:"light")}(),function(){try{const c=new URLSearchParams(window.location.search).entries();for(var[t,e]of c)if(t.startsWith("docusaurus-data-")){var a=t.replace("docusaurus-data-","data-");document.documentElement.setAttribute(a,e)}}catch(t){}}()</script><div id="__docusaurus"><div role="region" aria-label="跳到主要内容"><a class="skipToContent_fXgn" href="#__docusaurus_skipToContent_fallback">跳到主要内容</a></div><nav aria-label="主导航" class="navbar navbar--fixed-top"><div class="navbar__inner"><div class="navbar__items"><button aria-label="切换导航栏" aria-expanded="false" class="navbar__toggle clean-btn" type="button"><svg width="30" height="30" viewBox="0 0 30 30" aria-hidden="true"><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><a class="navbar__brand" href="/light-docusaurus/"><div class="navbar__logo"><img src="/light-docusaurus/img/logo.svg" alt="Torch Logo" class="themedComponent_mlkZ themedComponent--light_NVdE"><img src="/light-docusaurus/img/logo.svg" alt="Torch Logo" class="themedComponent_mlkZ themedComponent--dark_xIcU"></div><b class="navbar__title text--truncate">Torch</b></a><a class="navbar__item navbar__link" href="/light-docusaurus/docs/category/guide/">Torch</a><a class="navbar__item navbar__link" href="/light-docusaurus/blog/">Blog</a><a aria-current="page" class="navbar__item navbar__link navbar__link--active" href="/light-docusaurus/middleware/">Middleware</a><a class="navbar__item navbar__link" href="/light-docusaurus/electron/">Electron</a><a class="navbar__item navbar__link" href="/light-docusaurus/postman/">Postman</a><a class="navbar__item navbar__link" href="/light-docusaurus/diy/">DIY</a></div><div class="navbar__items navbar__items--right"><div class="navbar__item dropdown dropdown--hoverable dropdown--right"><a href="#" aria-haspopup="true" aria-expanded="false" role="button" class="navbar__link"><svg viewBox="0 0 24 24" width="20" height="20" aria-hidden="true" class="iconLanguage_nlXk"><path fill="currentColor" d="M12.87 15.07l-2.54-2.51.03-.03c1.74-1.94 2.98-4.17 3.71-6.53H17V4h-7V2H8v2H1v1.99h11.17C11.5 7.92 10.44 9.75 9 11.35 8.07 10.32 7.3 9.19 6.69 8h-2c.73 1.63 1.73 3.17 2.98 4.56l-5.09 5.02L4 19l5-5 3.11 3.11.76-2.04zM18.5 10h-2L12 22h2l1.12-3h4.75L21 22h2l-4.5-12zm-2.62 7l1.62-4.33L19.12 17h-3.24z"></path></svg>简体中文</a><ul class="dropdown__menu"><li><a href="/light-docusaurus/middleware/mysql/Mysql-Optimize-2/" target="_self" rel="noopener noreferrer" class="dropdown__link dropdown__link--active" lang="zh-Hans">简体中文</a></li></ul></div><a href="https://github.com/lorchr/light-docusaurus" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link">GitHub<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a><div class="toggle_vylO colorModeToggle_DEke"><button class="clean-btn toggleButton_gllP toggleButtonDisabled_aARS" type="button" disabled="" title="切换浅色/暗黑模式（当前为浅色模式）" aria-label="切换浅色/暗黑模式（当前为浅色模式）" aria-live="polite"><svg viewBox="0 0 24 24" width="24" height="24" class="lightToggleIcon_pyhR"><path fill="currentColor" d="M12,9c1.65,0,3,1.35,3,3s-1.35,3-3,3s-3-1.35-3-3S10.35,9,12,9 M12,7c-2.76,0-5,2.24-5,5s2.24,5,5,5s5-2.24,5-5 S14.76,7,12,7L12,7z M2,13l2,0c0.55,0,1-0.45,1-1s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S1.45,13,2,13z M20,13l2,0c0.55,0,1-0.45,1-1 s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S19.45,13,20,13z M11,2v2c0,0.55,0.45,1,1,1s1-0.45,1-1V2c0-0.55-0.45-1-1-1S11,1.45,11,2z M11,20v2c0,0.55,0.45,1,1,1s1-0.45,1-1v-2c0-0.55-0.45-1-1-1C11.45,19,11,19.45,11,20z M5.99,4.58c-0.39-0.39-1.03-0.39-1.41,0 c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0s0.39-1.03,0-1.41L5.99,4.58z M18.36,16.95 c-0.39-0.39-1.03-0.39-1.41,0c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0c0.39-0.39,0.39-1.03,0-1.41 L18.36,16.95z M19.42,5.99c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06c-0.39,0.39-0.39,1.03,0,1.41 s1.03,0.39,1.41,0L19.42,5.99z M7.05,18.36c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06 c-0.39,0.39-0.39,1.03,0,1.41s1.03,0.39,1.41,0L7.05,18.36z"></path></svg><svg viewBox="0 0 24 24" width="24" height="24" class="darkToggleIcon_wfgR"><path fill="currentColor" d="M9.37,5.51C9.19,6.15,9.1,6.82,9.1,7.5c0,4.08,3.32,7.4,7.4,7.4c0.68,0,1.35-0.09,1.99-0.27C17.45,17.19,14.93,19,12,19 c-3.86,0-7-3.14-7-7C5,9.07,6.81,6.55,9.37,5.51z M12,3c-4.97,0-9,4.03-9,9s4.03,9,9,9s9-4.03,9-9c0-0.46-0.04-0.92-0.1-1.36 c-0.98,1.37-2.58,2.26-4.4,2.26c-2.98,0-5.4-2.42-5.4-5.4c0-1.81,0.89-3.42,2.26-4.4C12.92,3.04,12.46,3,12,3L12,3z"></path></svg></button></div><div class="navbarSearchContainer_Bca1"><button type="button" class="DocSearch DocSearch-Button" aria-label="搜索"><span class="DocSearch-Button-Container"><svg width="20" height="20" class="DocSearch-Search-Icon" viewBox="0 0 20 20"><path d="M14.386 14.386l4.0877 4.0877-4.0877-4.0877c-2.9418 2.9419-7.7115 2.9419-10.6533 0-2.9419-2.9418-2.9419-7.7115 0-10.6533 2.9418-2.9419 7.7115-2.9419 10.6533 0 2.9419 2.9418 2.9419 7.7115 0 10.6533z" stroke="currentColor" fill="none" fill-rule="evenodd" stroke-linecap="round" stroke-linejoin="round"></path></svg><span class="DocSearch-Button-Placeholder">搜索</span></span><span class="DocSearch-Button-Keys"></span></button></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div></nav><div id="__docusaurus_skipToContent_fallback" class="main-wrapper mainWrapper_z2l0"><div class="docsWrapper_hBAB"><button aria-label="回到顶部" class="clean-btn theme-back-to-top-button backToTopButton_sjWU" type="button"></button><div class="docRoot_UBD9"><aside class="theme-doc-sidebar-container docSidebarContainer_YfHR"><div class="sidebarViewport_aRkj"><div class="sidebar_njMd"><nav aria-label="文档侧边栏" class="menu thin-scrollbar menu_SIkG"><ul class="theme-doc-sidebar-menu menu__list"><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/light-docusaurus/middleware/">MiddleWare</a></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" aria-expanded="false" href="/light-docusaurus/middleware/category/compare/">Compare</a><button aria-label="展开侧边栏分类 &#x27;Compare&#x27;" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--active" aria-expanded="true" href="/light-docusaurus/middleware/category/mysql/">Mysql</a><button aria-label="折叠侧边栏分类 &#x27;Mysql&#x27;" type="button" class="clean-btn menu__caret"></button></div><ul style="display:block;overflow:visible;height:auto" class="menu__list"><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/light-docusaurus/middleware/mysql/Mysql-Install-On-Windows/">Mysql-Install-On-Windows</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/light-docusaurus/middleware/mysql/Mysql-Store-Function-Procedure/">Mysql-Store-Function-Procedure</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/light-docusaurus/middleware/mysql/Mysql-Optimize-1/">Mysql-Optimize-1</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link menu__link--active" aria-current="page" tabindex="0" href="/light-docusaurus/middleware/mysql/Mysql-Optimize-2/">Mysql-Optimize-2</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/light-docusaurus/middleware/mysql/Mysql-redolog-undolog-binlog/">Mysql-redolog-undolog-binlog</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/light-docusaurus/middleware/mysql/Mysql-Execute-Sequence/">Mysql-Execute-Sequence</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/light-docusaurus/middleware/mysql/Mysql-Command/">Mysql-Command</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/light-docusaurus/middleware/mysql/Query-Sql-Execute-Sequence/">Query-Sql-Execute-Sequence</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/light-docusaurus/middleware/mysql/Update-SQL-Execute-Sequence/">Update-SQL-Execute-Sequence</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/light-docusaurus/middleware/mysql/Mysql-Index-Optimize/">Mysql-Index-Optimize</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/light-docusaurus/middleware/mysql/Mysql-Schedule-Event/">Mysql-Schedule-Event</a></li></ul></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" aria-expanded="false" href="/light-docusaurus/middleware/category/postgresql/">Postgresql</a><button aria-label="展开侧边栏分类 &#x27;Postgresql&#x27;" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" aria-expanded="false" href="/light-docusaurus/middleware/category/redis/">Redis</a><button aria-label="展开侧边栏分类 &#x27;Redis&#x27;" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" aria-expanded="false" href="/light-docusaurus/middleware/category/nginx/">Nginx</a><button aria-label="展开侧边栏分类 &#x27;Nginx&#x27;" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" aria-expanded="false" href="/light-docusaurus/middleware/category/mqtt/">MQTT</a><button aria-label="展开侧边栏分类 &#x27;MQTT&#x27;" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" aria-expanded="false" href="/light-docusaurus/middleware/category/influxdb/">InfluxDB</a><button aria-label="展开侧边栏分类 &#x27;InfluxDB&#x27;" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" aria-expanded="false" href="/light-docusaurus/middleware/category/kafka/">Kafka</a><button aria-label="展开侧边栏分类 &#x27;Kafka&#x27;" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" aria-expanded="false" href="/light-docusaurus/middleware/category/rocketmq/">RocketMQ</a><button aria-label="展开侧边栏分类 &#x27;RocketMQ&#x27;" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" aria-expanded="false" href="/light-docusaurus/middleware/category/workflow/">Workflow</a><button aria-label="展开侧边栏分类 &#x27;Workflow&#x27;" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" aria-expanded="false" href="/light-docusaurus/middleware/category/plusar/">Plusar</a><button aria-label="展开侧边栏分类 &#x27;Plusar&#x27;" type="button" class="clean-btn menu__caret"></button></div></li></ul></nav><button type="button" title="收起侧边栏" aria-label="收起侧边栏" class="button button--secondary button--outline collapseSidebarButton_PEFL"><svg width="20" height="20" aria-hidden="true" class="collapseSidebarButtonIcon_kv0_"><g fill="#7a7a7a"><path d="M9.992 10.023c0 .2-.062.399-.172.547l-4.996 7.492a.982.982 0 01-.828.454H1c-.55 0-1-.453-1-1 0-.2.059-.403.168-.551l4.629-6.942L.168 3.078A.939.939 0 010 2.528c0-.548.45-.997 1-.997h2.996c.352 0 .649.18.828.45L9.82 9.472c.11.148.172.347.172.55zm0 0"></path><path d="M19.98 10.023c0 .2-.058.399-.168.547l-4.996 7.492a.987.987 0 01-.828.454h-3c-.547 0-.996-.453-.996-1 0-.2.059-.403.168-.551l4.625-6.942-4.625-6.945a.939.939 0 01-.168-.55 1 1 0 01.996-.997h3c.348 0 .649.18.828.45l4.996 7.492c.11.148.168.347.168.55zm0 0"></path></g></svg></button></div></div></aside><main class="docMainContainer_TBSr"><div class="container padding-top--md padding-bottom--lg"><div class="row"><div class="col docItemCol_VOVn"><div class="docItemContainer_Djhp"><article><nav class="theme-doc-breadcrumbs breadcrumbsContainer_Z_bl" aria-label="页面路径"><ul class="breadcrumbs" itemscope="" itemtype="https://schema.org/BreadcrumbList"><li class="breadcrumbs__item"><a aria-label="主页面" class="breadcrumbs__link" href="/light-docusaurus/"><svg viewBox="0 0 24 24" class="breadcrumbHomeIcon_YNFT"><path d="M10 19v-5h4v5c0 .55.45 1 1 1h3c.55 0 1-.45 1-1v-7h1.7c.46 0 .68-.57.33-.87L12.67 3.6c-.38-.34-.96-.34-1.34 0l-8.36 7.53c-.34.3-.13.87.33.87H5v7c0 .55.45 1 1 1h3c.55 0 1-.45 1-1z" fill="currentColor"></path></svg></a></li><li itemscope="" itemprop="itemListElement" itemtype="https://schema.org/ListItem" class="breadcrumbs__item"><a class="breadcrumbs__link" itemprop="item" href="/light-docusaurus/middleware/category/mysql/"><span itemprop="name">Mysql</span></a><meta itemprop="position" content="1"></li><li itemscope="" itemprop="itemListElement" itemtype="https://schema.org/ListItem" class="breadcrumbs__item breadcrumbs__item--active"><span class="breadcrumbs__link" itemprop="name">Mysql-Optimize-2</span><meta itemprop="position" content="2"></li></ul></nav><div class="tocCollapsible_ETCw theme-doc-toc-mobile tocMobile_ITEo"><button type="button" class="clean-btn tocCollapsibleButton_TO0P">本页总览</button></div><div class="theme-doc-markdown markdown"><header><h1>Mysql-Optimize-2</h1></header><ul>
<li><a href="https://mp.weixin.qq.com/s/pO1WcM5h6csxNQ7azb0HqA">万字长文，讲懂SQL调优，还不会，来找我</a></li>
<li><a href="https://www.cnblogs.com/annsshadow/p/5037667.html">步步深入：MySQL架构总览-&gt;查询执行流程-&gt;SQL解析顺序</a></li>
</ul>
<p>很多朋友在做数据分析时，分析两分钟，跑数两小时？</p>
<p>在使用SQL过程中不仅要关注数据结果，同样要注意SQL语句的执行效率。</p>
<p>本文涉及三部分：</p>
<ul>
<li>SQL介绍</li>
<li>SQL优化方法</li>
<li>SQL优化实例</li>
</ul>
<h2 id="1mysql的基本架构">1、MySQL的基本架构</h2>
<h3 id="1mysql的基础架构图">1）MySQL的基础架构图</h3>
<p><img alt="img" src="/light-docusaurus/assets/images/mysql-3-1-4efac11a4ea062e2d8f34b3af6a7bbfe.jpg" width="732" height="413"></p>
<p>左边的client可以看成是客户端，客户端有很多，像我们经常你使用的CMD黑窗口，像我们经常用于学习的WorkBench，像企业经常使用的Navicat工具，它们都是一个客户端。右边的这一大堆都可以看成是Server(MySQL的服务端)，我们将Server在细分为sql层和存储引擎层。</p>
<p>当查询出数据以后，会返回给执行器。执行器一方面将结果写到查询缓存里面，当你下次再次查询的时候，就可以直接从查询缓存中获取到数据了。另一方面，直接将结果响应回客户端。</p>
<h3 id="2查询数据库的引擎">2）查询数据库的引擎</h3>
<h4 id="-show-engines">① <code>show engines;</code></h4>
<table><thead><tr><th>Engine</th><th>Support</th><th>Comment</th><th>Transactions</th><th>XA</th><th>Savepoints</th></tr></thead><tbody><tr><td>ndbcluster</td><td>NO</td><td>Clustered, fault-tolerant tables</td><td></td><td></td><td></td></tr><tr><td>FEDERATED</td><td>NO</td><td>Federated MySQL storage engine</td><td></td><td></td><td></td></tr><tr><td>MEMORY</td><td>YES</td><td>Hash based, stored in memory, useful for temporary tables</td><td>NO</td><td>NO</td><td>NO</td></tr><tr><td>InnoDB</td><td>DEFAULT</td><td>Supports transactions, row-level locking, and foreign keys</td><td>YES</td><td>YES</td><td>YES</td></tr><tr><td>PERFORMANCE_SCHEMA</td><td>YES</td><td>Performance Schema</td><td>NO</td><td>NO</td><td>NO</td></tr><tr><td>MyISAM</td><td>YES</td><td>MyISAM storage engine</td><td>NO</td><td>NO</td><td>NO</td></tr><tr><td>ndbinfo</td><td>NO</td><td>MySQL Cluster system information storage engine</td><td></td><td></td><td></td></tr><tr><td>MRG_MYISAM</td><td>YES</td><td>Collection of identical MyISAM tables</td><td>NO</td><td>NO</td><td>NO</td></tr><tr><td>BLACKHOLE</td><td>YES</td><td>/dev/null storage engine (anything you write to it disappears)</td><td>NO</td><td>NO</td><td>NO</td></tr><tr><td>CSV</td><td>YES</td><td>CSV storage engine</td><td>NO</td><td>NO</td><td>NO</td></tr><tr><td>ARCHIVE</td><td>YES</td><td>Archive storage engine</td><td>NO</td><td>NO</td><td>NO</td></tr></tbody></table>
<h4 id="-show-variables-like-storage_engine">② <code>show variables like &quot;%storage_engine%&quot;;</code></h4>
<table><thead><tr><th>Variable_name</th><th>Value</th></tr></thead><tbody><tr><td>default_storage_engine</td><td>InnoDB</td></tr><tr><td>default_tmp_storage_engine</td><td>InnoDB</td></tr><tr><td>disabled_storage_engines</td><td></td></tr><tr><td>internal_tmp_mem_storage_engine</td><td>TempTable</td></tr></tbody></table>
<h3 id="3指定数据库对象的存储引擎">3）指定数据库对象的存储引擎</h3>
<pre><code class="language-sql">create table tb(
    id int(4) auto_increment,
    name varchar(5),
    dept varchar(5),
    primary key(id)
) engine=myISAM auto_increment=1 default charset=utf8;
</code></pre>
<h2 id="2sql优化">2、SQL优化</h2>
<h3 id="1为什么需要进行sql优化">1）为什么需要进行SQL优化？</h3>
<p>在进行多表连接查询、子查询等操作的时候，由于你写出的SQL语句欠佳，导致的服务器执行时间太长，我们等待结果的时间太长。基于此，我们需要学习怎么优化SQL。</p>
<h3 id="2mysql的编写过程和解析过程">2）mysql的编写过程和解析过程</h3>
<h4 id="-编写过程">① 编写过程</h4>
<pre><code class="language-sql">select dinstinct  ..from  ..join ..on ..where ..group by ..having ..order by ..limit ..
</code></pre>
<h4 id="-解析过程">② 解析过程</h4>
<pre><code class="language-sql">from .. on.. join ..where ..group by ..having ..select dinstinct ..order by ..limit ..
</code></pre>
<p>这里有一篇文章，详细说明了mysql解析过程：</p>
<p><a href="https://www.cnblogs.com/annsshadow/p/5037667.html">https://www.cnblogs.com/annsshadow/p/5037667.html</a></p>
<h3 id="3sql优化主要就是优化索引">3）SQL优化—主要就是优化索引</h3>
<p>优化SQL，最重要的  就是优化SQL索引。</p>
<p>索引相当于字典的目录。利用字典目录查找汉字的过程，就相当于利用SQL索引查找某条记录的过程。有了索引，就可以很方便快捷的定位某条记录。</p>
<h4 id="-什么是索引">① 什么是索引？</h4>
<p>索引就是帮助MySQL高效获取数据的一种【数据结构】。索引是一种树结构，MySQL中一般用的是【B+树】。</p>
<h4 id="-索引图示说明这里用二叉树来帮助我们理解索引">② 索引图示说明(这里用二叉树来帮助我们理解索引)</h4>
<p>树形结构的特点是：子元素比父元素小的，放在左侧；子元素比父元素大的，放在右侧。</p>
<p>这个图示只是为了帮我们简单理解索引的，真实的关于【B+树】的说明，我们会在下面进行说明。</p>
<p><img src="/light-docusaurus/assets/images/mysql-3-2-ee0aa74fc35d8be6d97f5e16b98e1fab.png" width="1080" height="430"></p>
<p>索引是怎么查找数据的呢？两个字【指向】，上图中我们给age列指定了一个索引，即类似于右侧的这种树形结构。mysql表中的每一行记录都有一个硬件地址，例如索引中的age=50，指向的就是源表中该行的标识符(“硬件地址”)。</p>
<p>也就是说，树形索引建立了与源表中每行记录硬件地址的映射关系，当你指定了某个索引，这种映射关系也就建成了，这就是为什么我们可以通过索引快速定位源表中记录的原因。</p>
<p>以 <code>select * from student where age=33</code> 查询语句为例。当我们不加索引的时候，会从上到下扫描源表，当扫描到第5行的时候，找到了我们想要找到了元素，一共是查询了5次。</p>
<p>当添加了索引以后，就直接在树形结构中进行查找，33比50小，就从左侧查询到了23，33大于23，就又查询到了右侧，这下找到了33，整个索引结束，一共进行了3次查找。是不是很方便，假如我们此时需要查找age=62，你再想  想“添加索引”前后，查找次数的变化情况。</p>
<h3 id="4索引的弊端">4）索引的弊端</h3>
<ol>
<li>
<p>当数据量很大的时候，索引也会很大(当然相比于源表来说，还是相当小的)，也需要存放在内存/硬盘中(通常存放在硬盘中)，占据一定的内存空间/物理空间。</p>
</li>
<li>
<p>索引并不适用于所有情况：a.少量数据；b.频繁进行改动的字段，不适合做索引；c.很少使用的字段，不需要加索引；</p>
</li>
<li>
<p>索引会提高数据查询效率，但是会降低“增、删、改”的效率。当不使用索引的时候，我们进行数据的增删改，只需要操作源表即可，但是当我们添加索引后，不仅需要修改源表，也需要再次修改索引，很麻烦。尽管是这样，添加索引还是很划算的，因为我们大多数使用的就是查询，“查询”对于程序的性能影响是很大的。</p>
</li>
</ol>
<h3 id="5索引的优势">5）索引的优势</h3>
<ol>
<li>
<p>提高查询效率(降低了IO使用率)。当创建了索引后，查询次数减少了。</p>
</li>
<li>
<p>降低CPU使用率。比如说【…order by age desc】这样一个操作，当不加索引，会把源表加载到内存中做一个排序操作，极大的消耗了资源。但是使用了索引以后，第一索引本身就小一些，第二索引本身就是排好序的，左边数据最小，右边数据最大。</p>
</li>
</ol>
<h3 id="6b树图示说明">6）B+树图示说明</h3>
<p>MySQL中索引使用的就是B+树结构。</p>
<p><img src="/light-docusaurus/assets/images/mysql-3-3-b62b36ba0287f6feb30ed2866f5ad54d.jpg" width="635" height="363"></p>
<p>关于B+树的说明：</p>
<p>首先，Btree一般指的都是【B+树】，数据全部存放在叶子节点中。对于上图来说，最下面的第3层，属于叶子节点，真实数据部份都是存放在叶子节点当中的。</p>
<p>那么对于第1、2层中的数据又是干嘛的呢？答：用于分割指针块儿 的，比如说小于26的找P1，介于26-30之间的找P2，大于30的找P3。</p>
<p>其次，三层【B+树】可以存放上百万条数据。这么多数据怎么放的呢？增加“节点数”。图中我们只有三个节点。</p>
<p>最后，【B+树】中查询任意数据的次数，都是n次，n表示的是【B+树】的高度。</p>
<h2 id="3索引的分类与创建">3、索引的分类与创建</h2>
<h3 id="1索引分类">1）索引分类</h3>
<ul>
<li>单值索引</li>
<li>唯一索引</li>
<li>复合索引</li>
</ul>
<h4 id="-单值索引">① 单值索引</h4>
<p>利用表中的某一个字段创建单值索引。一张表中往往有多个字段，也就是说每一列其实都可以创建一个索引，这个根据我们实际需求来进行创建。还需要注意的一点就是，一张表可以创建多个“单值索引”。</p>
<p>假如某一张表既有age字段，又有name字段，我们可以分别对age、name创建一个单值索引，这样一张表就有了两个单值索引。</p>
<h4 id="-唯一索引">② 唯一索引</h4>
<p>也是利用表中的某一个字段创建单值索引，与单值索引不同的是：创建唯一索引的字段中的数据，不能有重复值。像age肯定有很多人的年龄相同，像name肯定有些人是重名的，因此都不适合创建“唯一索引”。像编号id、学号sid，对于每个人都不一样，因此可以用于创建唯一索引。</p>
<h4 id="-复合索引">③ 复合索引</h4>
<p>多个列共同构成的索引。比如说我们创建这样一个“复合索引”(name,age)，先利用name进行索引查询，当name相同的时候，我们利用age再进行一次筛选。注意：复合索引的字段并不是非要都用完，当我们利用name字段索引出我们想要的结果以后，就不需要再使用age进行再次筛选了。</p>
<h3 id="2创建索引">2）创建索引</h3>
<h4 id="-语法">① 语法</h4>
<p>语法：<code>create 索引类型 索引名 on 表(字段);</code></p>
<p>建表语句如  下：</p>
<pre><code class="language-sql">create table tb(
    id int(4) auto_increment,
    name varchar(5),
    dept varchar(5),
    primary key(id)
) engine=myISAM auto_increment=1 default charset=utf8;
</code></pre>
<p>查询表结构如下：</p>
<pre><code class="language-sql">desc tb;
</code></pre>
<table><thead><tr><th>Field</th><th>Type</th><th>Null</th><th>Key</th><th>Default</th><th>Extra</th></tr></thead><tbody><tr><td>id</td><td>int</td><td>NO</td><td>PRI</td><td></td><td>auto_increment</td></tr><tr><td>name</td><td>varchar(5)</td><td>YES</td><td></td><td></td><td></td></tr><tr><td>dept</td><td>varchar(5)</td><td>YES</td><td></td><td></td><td></td></tr></tbody></table>
<h4 id="-创建索引的第一种方式">② 创建索引的第一种方式</h4>
<ol>
<li>创建单值索引</li>
</ol>
<pre><code class="language-sql">create index dept_index on tb(dept);
</code></pre>
<ol start="2">
<li>创建唯一索引：这里我们假定name字段中的值都是唯一的</li>
</ol>
<pre><code class="language-sql">create unique index name_index on tb(name);
</code></pre>
<ol start="3">
<li>创建复合索引</li>
</ol>
<pre><code class="language-sql">create index dept_name_index on tb(dept,name);
</code></pre>
<h4 id="-创建索引的第二种方式">③ 创建索引的第二种方式</h4>
<p>先删除之前创建的索引以后，再进行这种创建索引方式的测试；</p>
<pre><code class="language-sql">drop index dept_index on tb;
drop index name_index on tb;
drop index dept_name_index on tb;
</code></pre>
<p>语法：<code>alter table 表名 add 索引类型 索引名(字段);</code></p>
<ol>
<li>创建单值索引</li>
</ol>
<pre><code class="language-sql">alter table tb add index dept_index(dept);
</code></pre>
<ol>
<li>创建唯一索引：这里我们假定name字段中的值都是唯一的</li>
</ol>
<pre><code class="language-sql">alter table tb add unique index name_index(name);
</code></pre>
<ol>
<li>创建复合索引</li>
</ol>
<pre><code class="language-sql">alter table tb add index dept_name_index(dept, name);
</code></pre>
<h4 id="-补充说明">④ 补充说明</h4>
<p>如果某个字段是<code>primary key</code>，那么该字段默认就是主键索引。</p>
<p>主键索引和唯一索引非常相似。相同点：该列中的数据都不能有相同值；不同点：主键索引不能有null值，但是唯一索引可以有null值。</p>
<h3 id="3索引删除和索引查询">3）索引删除和索引查询</h3>
<h4 id="-索引删除">① 索引删除</h4>
<p>语法：<code>drop index 索引名 on 表名;</code></p>
<pre><code class="language-sql">drop index name_index on tb;
</code></pre>
<h4 id="-索引查询">② 索引查询</h4>
<p>语法：<code>show index from 表名;</code></p>
<pre><code class="language-sql">show index from tb;
</code></pre>
<p>结果如下：</p>
<table><thead><tr><th>Table</th><th>Non_unique</th><th>Key_name</th><th>Seq_in_index</th><th>Column_name</th><th>Collation</th><th>Cardinality</th><th>Sub_part</th><th>Packed</th><th>Null</th><th>Index_type</th><th>Comment</th><th>Index_comment</th><th>Visible</th><th>Expression</th></tr></thead><tbody><tr><td>tb</td><td>0</td><td>PRIMARY</td><td>1</td><td>id</td><td>A</td><td>0</td><td></td><td></td><td></td><td>BTREE</td><td></td><td></td><td>YES</td><td></td></tr><tr><td>tb</td><td>1</td><td>dept_index</td><td>1</td><td>dept</td><td>A</td><td></td><td></td><td></td><td>YES</td><td>BTREE</td><td></td><td></td><td>YES</td><td></td></tr><tr><td>tb</td><td>1</td><td>dept_name_index</td><td>1</td><td>dept</td><td>A</td><td></td><td></td><td></td><td>YES</td><td>BTREE</td><td></td><td></td><td>YES</td><td></td></tr><tr><td>tb</td><td>1</td><td>dept_name_index</td><td>2</td><td>name</td><td>A</td><td></td><td></td><td></td><td>YES</td><td>BTREE</td><td></td><td></td><td>YES</td><td></td></tr></tbody></table>
<h2 id="4sql性能问题的探索">4、SQL性能问题的探索</h2>
<p><strong>人为优化：</strong> 需要我们使用explain分析SQL的执行计划。该执行计划可以模拟SQL优化器执行SQL语句，可以帮助我们了解到自己编写SQL的好坏。</p>
<p><strong>SQL优化器自动优化：</strong> 最开始讲述MySQL执行原理的时候，我们已经知道MySQL有一个优化器，当你写了一个SQL语句的时候，SQL优化器如果认为你写的SQL语句不够好，就会自动写一个好一些的等价SQL去执行。</p>
<p>SQL优化器自动优化功能【会干扰】我们的人为优化功能。当我们查看了SQL执行计划以后，如果写的不好，我们会去优化自己的SQL。当我们以为自己优化的很好的时候，最终的执行计划，并不是按照我们优化好的SQL语句来执行的，而是有时候将我们优化好的SQL改变了，去执行。</p>
<p>SQL优化是一种概率问题，有时候系统会按照我们优化好的SQL去执行结果(优化器觉得你写的差不多，就不会动你的SQL)。有时候优化器仍然会修改我们优化好的SQL，然后再去执行。</p>
<h3 id="1查看执行计划">1）查看执行计划</h3>
<p>语法：<code>explain + SQL语句</code></p>
<p>eg：<code>explain select * from tb;</code></p>
<h3 id="2执行计划中需要知道的几个关键字">2）“执行计划”中需要知道的几个“关键字”</h3>
<table><thead><tr><th>字段</th><th>含义</th></tr></thead><tbody><tr><td>id</td><td>编号</td></tr><tr><td>select_type</td><td>查询类型</td></tr><tr><td>table</td><td>表</td></tr><tr><td>type</td><td>类型</td></tr><tr><td>possible_keys</td><td>预测用到的索引</td></tr><tr><td>key</td><td>实际使用的索引</td></tr><tr><td>key_len</td><td>实际使用索引的长度</td></tr><tr><td>ref</td><td>表之间的引用</td></tr><tr><td>rows</td><td>通过索引查询到的数据量</td></tr><tr><td>Extra</td><td>额外的信息</td></tr></tbody></table>
<h3 id="建表语句和插入数据">建表语句和插入数据：</h3>
<pre><code class="language-sql">-- 建表语句
create table course
(    
    cid int(3),   
    cname varchar(20),   
    tid int(3)
);

create table teacher
(  
    tid int(3),  
    tname varchar(20),  
    tcid int(3)
);

create table teacherCard
(   
    tcid int(3),  
    tcdesc varchar(200)
);

-- 插入数据
insert into course values(1,&#x27;java&#x27;,1);
insert into course values(2,&#x27;html&#x27;,1);
insert into course values(3,&#x27;sql&#x27;,2);
insert into course values(4,&#x27;web&#x27;,3);

insert into teacher values(1,&#x27;tz&#x27;,1);
insert into teacher values(2,&#x27;tw&#x27;,2);
insert into teacher values(3,&#x27;tl&#x27;,3);

insert into teacherCard values(1,&#x27;tzdesc&#x27;) ;
insert into teacherCard values(2,&#x27;twdesc&#x27;) ;
insert into teacherCard values(3,&#x27;tldesc&#x27;) ;
</code></pre>
<h2 id="5-explain执行计划常用关键字详解">5. explain执行计划常用关键字详解</h2>
<h3 id="1id关键字的使用说明">1）id关键字的使用说明</h3>
<h4 id="-案例查询课程编号为2-或-教师证编号为3-的老师信息">① 案例：查询课程编号为2 或 教师证编号为3 的老师信息：</h4>
<pre><code class="language-sql">-- 查看执行计划
explain select t.*
from teacher t,course c,teacherCard tc
where t.tid = c.tid and t.tcid = tc.tcid
and (c.cid = 2 or tc.tcid = 3);
</code></pre>
<p>结果如下：</p>
<table><thead><tr><th>id</th><th>select_type</th><th>table</th><th>partitions</th><th>type</th><th>possible_keys</th><th>key</th><th>key_len</th><th>ref</th><th>rows</th><th>filtered</th><th>Extra</th></tr></thead><tbody><tr><td>1</td><td>SIMPLE</td><td>t</td><td></td><td>ALL</td><td></td><td></td><td></td><td></td><td>3</td><td>100.00</td><td></td></tr><tr><td>1</td><td>SIMPLE</td><td>tc</td><td></td><td>ALL</td><td></td><td></td><td></td><td></td><td>3</td><td>33.33</td><td>Using where; Using join buffer (hash join)</td></tr><tr><td>1</td><td>SIMPLE</td><td>c</td><td></td><td>ALL</td><td></td><td></td><td></td><td></td><td>4</td><td>25.00</td><td>Using where; Using join buffer (hash join)</td></tr></tbody></table>
<p>接着，在往teacher表中增加几条数据。</p>
<pre><code class="language-sql">insert into teacher values(4,&#x27;ta&#x27;,4);
insert into teacher values(5,&#x27;tb&#x27;,5);
insert into teacher values(6,&#x27;tc&#x27;,6);
</code></pre>
<p>再次查看执行计划。</p>
<pre><code class="language-sql">-- 查看执行计划
explain select t.*
from teacher t,course c,teacherCard tc
where t.tid = c.tid and t.tcid = tc.tcid
and (c.cid = 2 or tc.tcid = 3);
</code></pre>
<p>结果如下：</p>
<table><thead><tr><th>id</th><th>select_type</th><th>table</th><th>partitions</th><th>type</th><th>possible_keys</th><th>key</th><th>key_len</th><th>ref</th><th>rows</th><th>filtered</th><th>Extra</th></tr></thead><tbody><tr><td>1</td><td>SIMPLE</td><td>tc</td><td></td><td>ALL</td><td></td><td></td><td></td><td></td><td>3</td><td>100.00</td><td></td></tr><tr><td>1</td><td>SIMPLE</td><td>t</td><td></td><td>ALL</td><td></td><td></td><td></td><td></td><td>6</td><td>16.67</td><td>Using where; Using join buffer (hash join)</td></tr><tr><td>1</td><td>SIMPLE</td><td>c</td><td></td><td>ALL</td><td></td><td></td><td></td><td></td><td>4</td><td>25.00</td><td>Using where; Using join buffer (hash join)</td></tr></tbody></table>
<p>表的执行顺序 ，因表数量改变而改变的原因：笛卡尔积。</p>
<pre><code class="language-shell">a   b   c
2   3   4
最终：2 * 3 * 4  = 6 * 4 = 24
c   b   a
4   3   2
最终：4 * 3 * 2 = 12 * 2 = 24
</code></pre>
<p>分析：最终执行的条数，虽然是一致的。但是中间过程，有一张临时表是6，一张临时表是12，很明显6 &lt; 12，对于内存来说，数据量越小越好，因此优化器肯定会选择第一种执行顺序。</p>
<p>结论：id值相同，从上往下顺序执行。表的执行顺序因表数量的改变而改变。</p>
<h4 id="-案例查询教授sql课程的老师的描述desc">② 案例：查询教授SQL课程的老师的描述(desc)</h4>
<pre><code class="language-sql">-- 查看执行计划
explain select tc.tcdesc from teacherCard tc 
where tc.tcid = 
(    
    select t.tcid from teacher t  
    where  t.tid =   
    (select c.tid from course c where c.cname = &#x27;sql&#x27;)
);
</code></pre>
<p>结果如下：</p>
<table><thead><tr><th>id</th><th>select_type</th><th>table</th><th>partitions</th><th>type</th><th>possible_keys</th><th>key</th><th>key_len</th><th>ref</th><th>rows</th><th>filtered</th><th>Extra</th></tr></thead><tbody><tr><td>1</td><td>PRIMARY</td><td>tc</td><td></td><td>ALL</td><td></td><td></td><td></td><td></td><td>3</td><td>33.33</td><td>Using where</td></tr><tr><td>2</td><td>SUBQUERY</td><td>t</td><td></td><td>ALL</td><td></td><td></td><td></td><td></td><td>6</td><td>16.67</td><td>Using where</td></tr><tr><td>3</td><td>SUBQUERY</td><td>c</td><td></td><td>ALL</td><td></td><td></td><td></td><td></td><td>4</td><td>25.00</td><td>Using where</td></tr></tbody></table>
<p>结论：id值不同，id值越大越优先查询。这是由于在进行嵌套子查询时，先查内层，再查外层。</p>
<h4 id="-针对做一个简单的修改">③ 针对②做一个简单的修改</h4>
<pre><code class="language-sql">-- 查看执行计划
explain select t.tname ,tc.tcdesc from teacher t,teacherCard tc 
where t.tcid= tc.tcid
and t.tid = (select c.tid from course c where cname = &#x27;sql&#x27;) ;
</code></pre>
<p>结果如下：</p>
<table><thead><tr><th>id</th><th>select_type</th><th>table</th><th>partitions</th><th>type</th><th>possible_keys</th><th>key</th><th>key_len</th><th>ref</th><th>rows</th><th>filtered</th><th>Extra</th></tr></thead><tbody><tr><td>1</td><td>PRIMARY</td><td>t</td><td></td><td>ALL</td><td></td><td></td><td></td><td></td><td>6</td><td>16.67</td><td>Using where</td></tr><tr><td>1</td><td>PRIMARY</td><td>tc</td><td></td><td>ALL</td><td></td><td></td><td></td><td></td><td>3</td><td>33.33</td><td>Using where; Using join buffer (hash join)</td></tr><tr><td>2</td><td>SUBQUERY</td><td>c</td><td></td><td>ALL</td><td></td><td></td><td></td><td></td><td>4</td><td>25.00</td><td>Using where</td></tr></tbody></table>
<p>结论：id值有相同，又有不同。id值越大越优先；id值相同，从上往下顺序执行。</p>
<h3 id="2select_type关键字的使用说明查询类型">2）select_type关键字的使用说明：查询类型</h3>
<table><thead><tr><th>id</th><th>select_type</th></tr></thead><tbody><tr><td>1</td><td>SIMPLE</td></tr><tr><td>2</td><td>PRIMARY</td></tr><tr><td>3</td><td>SUBQUERY</td></tr><tr><td>4</td><td>DERIVED</td></tr><tr><td>5</td><td>UNION</td></tr><tr><td>6</td><td>UNION RESULT</td></tr></tbody></table>
<h4 id="-simple简单查询">① simple：简单查询</h4>
<p>不包含子查询，不包含union查询。</p>
<pre><code class="language-sql">explain select * from teacher;
</code></pre>
<p>结果如下：</p>
<table><thead><tr><th>id</th><th>select_type</th><th>table</th><th>partitions</th><th>type</th><th>possible_keys</th><th>key</th><th>key_len</th><th>ref</th><th>rows</th><th>filtered</th><th>Extra</th></tr></thead><tbody><tr><td>1</td><td>SIMPLE</td><td>teacher</td><td></td><td>ALL</td><td></td><td></td><td></td><td></td><td>6</td><td>100.00</td><td></td></tr></tbody></table>
<h4 id="-primary包含子查询的主查询最外层">② primary：包含子查询的主查询(最外层)</h4>
<h4 id="-subquery包含子查询的主查询非最外层">③ subquery：包含子查询的主查询(非最外层)</h4>
<h4 id="-derived衍生查询用到了临时表">④ derived：衍生查询(用到了临时表)</h4>
<ol>
<li>
<p>在from子查询中，只有一张表；</p>
</li>
<li>
<p>在from子查询中，如果table1 union table2，则table1就是derived表；</p>
</li>
</ol>
<pre><code class="language-sql">explain select  cr.cname    
from ( select * from course where tid = 1  union select * from course where tid = 2 ) cr ;
</code></pre>
<p>结果如下：</p>
<table><thead><tr><th>id</th><th>select_type</th><th>table</th><th>partitions</th><th>type</th><th>possible_keys</th><th>key</th><th>key_len</th><th>ref</th><th>rows</th><th>filtered</th><th>Extra</th></tr></thead><tbody><tr><td>1</td><td>PRIMARY</td><td><code>&lt;derived2&gt;</code></td><td></td><td>ALL</td><td></td><td></td><td></td><td></td><td>4</td><td>100.00</td><td></td></tr><tr><td>2</td><td>DERIVED</td><td>course</td><td></td><td>ALL</td><td></td><td></td><td></td><td></td><td>4</td><td>25.00</td><td>Using where</td></tr><tr><td>3</td><td>UNION</td><td>course</td><td></td><td>ALL</td><td></td><td></td><td></td><td></td><td>4</td><td>25.00</td><td>Using where</td></tr><tr><td>4</td><td>UNION RESULT</td><td><code>&lt;union2,3&gt;</code></td><td></td><td>ALL</td><td></td><td></td><td></td><td></td><td></td><td></td><td>Using temporary</td></tr></tbody></table>
<h4 id="-unionunion之后的表称之为union表如上例">⑤ union：union之后的表称之为union表，如  上例</h4>
<h4 id="-union-result告诉我们哪些表之间使用了union查询">⑥ union result：告诉我们，哪些表之间使用了union查询</h4>
<h3 id="3type关键字的使用说明索引类型">3）type关键字的使用说明：索引类型</h3>
<p>system、const只是理想状况，实际上只能优化到 <code>index</code> --&gt; <code>range</code> --&gt; <code>ref</code> 这个级别。要对type进行优化的前提是，你得创建索引。</p>
<table><thead><tr><th>system</th><th>const</th><th>eq_ref</th><th>ref</th><th>range</th><th>index</th><th>ALL</th></tr></thead></table>
<h4 id="-system">① system</h4>
<p>源表只有一条数据(实际中，基本不可能)；</p>
<p>衍生表只有一条数据的主查询(偶尔可以达到)。</p>
<h4 id="-const">② const</h4>
<p>仅仅能查到一条数据的SQL ,仅针对Primary key或unique索引类型有效。</p>
<pre><code class="language-sql">drop table if exists test01;
create table test01
(   
    tid int(3),  
    tdesc varchar(200),
    PRIMARY KEY(tid)
);

insert into test01 values(1, &#x27;tdesc&#x27;) ;

explain select tid from test01 where tid =1 ;
</code></pre>
<p>结果如下：</p>
<table><thead><tr><th>id</th><th>select_type</th><th>table</th><th>partitions</th><th>type</th><th>possible_keys</th><th>key</th><th>key_len</th><th>ref</th><th>rows</th><th>filtered</th><th>Extra</th></tr></thead><tbody><tr><td>1</td><td>SIMPLE</td><td>test01</td><td></td><td>const</td><td>PRIMARY</td><td>PRIMARY</td><td>4</td><td>const</td><td>1</td><td>100.00</td><td>Using index</td></tr></tbody></table>
<p>删除以前的主键索引后，此时我们添加一个其他的普通索引：</p>
<pre><code class="language-sql">drop index index_name on test01 ;

create index test01_index on test01(tid) ;

-- 再次查看执行计划
explain select tid from test01 where tid =1 ;
</code></pre>
<p>结果如下：</p>
<table><thead><tr><th>id</th><th>select_type</th><th>table</th><th>partitions</th><th>type</th><th>possible_keys</th><th>key</th><th>key_len</th><th>ref</th><th>rows</th><th>filtered</th><th>Extra</th></tr></thead><tbody><tr><td>1</td><td>SIMPLE</td><td>test01</td><td></td><td>ref</td><td>test01_index</td><td>test01_index</td><td>4</td><td>const</td><td>1</td><td>100.00</td><td>Using index</td></tr></tbody></table>
<h4 id="-eq_ref">③ eq_ref</h4>
<p>唯一性索引，对于每个索引键的查询，返回匹配唯一行数据（有且只有1个，不能多 、不能0），并且查询结果和数据条数必须一致。</p>
<p>此种情况常见于唯一索引和主键索引。</p>
<pre><code class="language-sql">delete from teacher where tcid &gt;= 4;
alter table teacherCard add constraint pk_tcid primary key(tcid);
alter table teacher add constraint uk_tcid unique index(tcid) ;
explain select t.tcid from teacher t,teacherCard tc where t.tcid = tc.tcid ;
</code></pre>
<p>结果如下：</p>
<table><thead><tr><th>id</th><th>select_type</th><th>table</th><th>partitions</th><th>type</th><th>possible_keys</th><th>key</th><th>key_len</th><th>ref</th><th>rows</th><th>filtered</th><th>Extra</th></tr></thead><tbody><tr><td>1</td><td>SIMPLE</td><td>t</td><td></td><td>index</td><td>uk_tcid</td><td>uk_tcid</td><td>5</td><td></td><td>3</td><td>100.00</td><td>Using where; Using index</td></tr><tr><td>1</td><td>SIMPLE</td><td>tc</td><td></td><td>eq_ref</td><td>PRIMARY</td><td>PRIMARY</td><td>4</td><td>light.t.tcid</td><td>1</td><td>100.00</td><td>Using index</td></tr></tbody></table>
<p>总结：以上SQL，用到的索引是t.tcid，即teacher表中的tcid字段；如果teacher表的数据个数和连接查询的数据个数一致（都是3条数据），则有可能满足eq_ref级别；否则无法满足。条件很苛刻，很难达到。</p>
<h4 id="-ref">④ ref</h4>
<p>非唯一性索引，对于每个索引键的查询，返回匹配的所有行（可以0，可以1，可以多）</p>
<p>准备数据：</p>
<pre><code class="language-sql">insert into teacher values(4, &#x27;tz&#x27;, 4);

insert into teacherCard values(4, &#x27;tz222&#x27;);

select * from teacher;
select * from teacherCard;
</code></pre>
<p>创建索引，并查看执行计划：</p>
<pre><code class="language-sql">-- 添加索引
alter table teacher add index index_name (tname) ;
-- 查看执行计划
explain select * from teacher     where tname = &#x27;tz&#x27;;
</code></pre>
<p>结果如下：</p>
<table><thead><tr><th>id</th><th>select_type</th><th>table</th><th>partitions</th><th>type</th><th>possible_keys</th><th>key</th><th>key_len</th><th>ref</th><th>rows</th><th>filtered</th><th>Extra</th></tr></thead><tbody><tr><td>1</td><td>SIMPLE</td><td>teacher</td><td></td><td>ref</td><td>index_name</td><td>index_name</td><td>83</td><td>const</td><td>2</td><td>100.00</td><td></td></tr></tbody></table>
<h4 id="-range">⑤ range</h4>
<p>检索指定范围的行 ,where后面是一个范围查询(<code>between</code>, <code>&gt;</code>, <code>&lt;</code>, <code>&gt;=</code>, <code>in</code>)</p>
<p>in有时候会失效，从而转为无索引时候的ALL</p>
<pre><code class="language-sql">-- 添加索引
alter table teacher add index tid_index (tid) ;
-- 查看执行计划：以下写了一种等价SQL写法，查看执行计划
explain select t.* from teacher t where t.tid in (1, 3) ;
explain select t.* from teacher t where t.tid &lt; 3 ;
</code></pre>
<p>结果如下：</p>
<table><thead><tr><th>id</th><th>select_type</th><th>table</th><th>partitions</th><th>type</th><th>possible_keys</th><th>key</th><th>key_len</th><th>ref</th><th>rows</th><th>filtered</th><th>Extra</th></tr></thead><tbody><tr><td>1</td><td>SIMPLE</td><td>t</td><td></td><td>range</td><td>tid_index</td><td>tid_index</td><td>5</td><td></td><td>2</td><td>100.00</td><td>Using index condition</td></tr></tbody></table>
<table><thead><tr><th>id</th><th>select_type</th><th>table</th><th>partitions</th><th>type</th><th>possible_keys</th><th>key</th><th>key_len</th><th>ref</th><th>rows</th><th>filtered</th><th>Extra</th></tr></thead><tbody><tr><td>1</td><td>SIMPLE</td><td>t</td><td></td><td>range</td><td>tid_index</td><td>tid_index</td><td>5</td><td></td><td>2</td><td>100.00</td><td>Using index condition</td></tr></tbody></table>
<h4 id="-index">⑥ index</h4>
<p>查询全部索引中的数据(扫描整个索引)</p>
<h4 id="-all">⑦ ALL</h4>
<p>查询全部源表中的数据(暴力扫描全表)</p>
<pre><code class="language-sql">show index from course;

create index cid_index on course(cid);

show index from course;

explain select cid from course;

explain select tid from course;
</code></pre>
<p>结果如下：</p>
<pre><code class="language-sql">mysql&gt; show index from course;
Empty set (0.00 sec)

mysql&gt; create index cid_index on course(cid);
Query OK, 0 rows affected (0.02 sec)
Records: 0  Duplicates: 0  Warnings: 0

mysql&gt; show index from course;
+--------+------------+-----------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+---------+------------+
| Table  | Non_unique | Key_name  | Seq_in_index | Column_name | Collation | Cardinality | Sub_part | Packed | Null | Index_type | Comment | Index_comment | Visible | Expression |
+--------+------------+-----------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+---------+------------+
| course |          1 | cid_index |            1 | cid         | A         |           4 |     NULL |   NULL | YES  | BTREE      |         |               | YES     | NULL       |
+--------+------------+-----------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+---------+------------+
1 row in set (0.00 sec)

mysql&gt; explain select cid from course;
+----+-------------+--------+------------+-------+---------------+-----------+---------+------+------+----------+-------------+
| id | select_type | table  | partitions | type  | possible_keys | key       | key_len | ref  | rows | filtered | Extra       |
+----+-------------+--------+------------+-------+---------------+-----------+---------+------+------+----------+-------------+
|  1 | SIMPLE      | course | NULL       | index | NULL          | cid_index | 5       | NULL |    4 |   100.00 | Using index |
+----+-------------+--------+------------+-------+---------------+-----------+---------+------+------+----------+-------------+
1 row in set, 1 warning (0.00 sec)

mysql&gt; explain select tid from course;
+----+-------------+--------+------------+------+---------------+------+---------+------+------+----------+-------+
| id | select_type | table  | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra |
+----+-------------+--------+------------+------+---------------+------+---------+------+------+----------+-------+
|  1 | SIMPLE      | course | NULL       | ALL  | NULL          | NULL | NULL    | NULL |    4 |   100.00 | NULL  |
+----+-------------+--------+------------+------+---------------+------+---------+------+------+----------+-------+
1 row in set, 1 warning (0.00 sec)
</code></pre>
<p>注意：cid是索引字段，因此查询索引字段，只需要扫描索引表即可。但是tid不是索引字段，查询非索引字段，需要暴力扫描整个源表，会消耗更多的资源。</p>
<h3 id="4possible_keys和key">4）possible_keys和key</h3>
<p>possible_keys可能用到的索引。是一种预测，不准。了解一下就好。</p>
<p>key指的是实际使用的索引。</p>
<pre><code class="language-sql">-- 先给course表的cname字段，添加一个索引
create index cname_index on course(cname);
-- 查看执行计划
explain select t.tname ,tc.tcdesc from teacher t,teacherCard tc
where t.tcid= tc.tcid
and t.tid = (select c.tid from course c where cname = &#x27;sql&#x27;) ;
</code></pre>
<p>结果如下：</p>
<table><thead><tr><th>id</th><th>select_type</th><th>table</th><th>partitions</th><th>type</th><th>possible_keys</th><th>key</th><th>key_len</th><th>ref</th><th>rows</th><th>filtered</th><th>Extra</th></tr></thead><tbody><tr><td>1</td><td>PRIMARY</td><td>t</td><td></td><td>ref</td><td>uk_tcid,tid_index</td><td>tid_index</td><td>5</td><td>const</td><td>1</td><td>100.00</td><td>Using where</td></tr><tr><td>1</td><td>PRIMARY</td><td>tc</td><td></td><td>eq_ref</td><td>PRIMARY</td><td>PRIMARY</td><td>4</td><td>test.t.tcid</td><td>1</td><td>100.00</td><td></td></tr><tr><td>2</td><td>SUBQUERY</td><td>c</td><td></td><td>ref</td><td>cname_index</td><td>cname_index</td><td>83</td><td>const</td><td>1</td><td>100.00</td><td></td></tr></tbody></table>
<p>有一点需要注意的是：如果<code>possible_key</code> / <code>key</code> 是NULL，则说明没用索引。</p>
<h3 id="5key_len">5）key_len</h3>
<p>索引的长度，用于判断复合索引是否被完全使用(a,b,c)。</p>
<h4 id="-新建一张新表用于测试">① 新建一张新表，用于测试</h4>
<pre><code class="language-sql">--- 创建表
create table test_kl
(  
  name char(20) not null default &#x27;&#x27;
);

--- 添加索引
alter table test_kl add index index_name(name) ;
--- 查看执行计 划
explain select * from test_kl where name =&#x27;&#x27; ; 
</code></pre>
<p>结果如下：</p>
<table><thead><tr><th>id</th><th>select_type</th><th>table</th><th>partitions</th><th>type</th><th>possible_keys</th><th>key</th><th>key_len</th><th>ref</th><th>rows</th><th>filtered</th><th>Extra</th></tr></thead><tbody><tr><td>1</td><td>SIMPLE</td><td>test_kl</td><td></td><td>ref</td><td>index_name</td><td>index_name</td><td>80</td><td>const</td><td>1</td><td>100.00</td><td>Using index</td></tr></tbody></table>
<p>结果分析：因为我没有设置服务端的字符集，因此默认的字符集使用的是latin1，对于latin1一个字符代表一个字节，因此这列的key_len的长度是20，表示使用了name这个索引。</p>
<h4 id="-给test_kl表新增name1列该列没有设置not-null">② 给test_kl表，新增name1列，该列没有设置“not null”</h4>
<p>结果如下：</p>
<pre><code class="language-sql">-- 添加字段
alter table test_kl add column name1 char(20);
-- 添加索引
alter table test_kl add index index_name1(name1);
--- 查看执行计划
explain select * from test_kl where name1 =&#x27;&#x27; ; 
</code></pre>
<table><thead><tr><th>id</th><th>select_type</th><th>table</th><th>partitions</th><th>type</th><th>possible_keys</th><th>key</th><th>key_len</th><th>ref</th><th>rows</th><th>filtered</th><th>Extra</th></tr></thead><tbody><tr><td>1</td><td>SIMPLE</td><td>test_kl</td><td></td><td>ref</td><td>index_name1</td><td>index_name1</td><td>81</td><td>const</td><td>1</td><td>100.00</td><td></td></tr></tbody></table>
<p>结果分析：如果索引字段可以为null，则mysql底层会使用1个字节用于标识。</p>
<h4 id="-删除原来的索引name和name1新增一个复合索引">③ 删除原来的索引name和name1，新增一个复合索引</h4>
<pre><code class="language-sql">-- 删除原来的索引name和name1
drop index index_name on test_kl ;
drop index index_name1 on test_kl ;
-- 增加一个复合索引
create index name_name1_index on test_kl(name,name1);
-- 查看执行计划
explain select * from test_kl where name1 = &#x27;&#x27; ; -- 121
explain select * from test_kl where name = &#x27;&#x27; ; -- 60
</code></pre>
<p>结果如下：</p>
<table><thead><tr><th>id</th><th>select_type</th><th>table</th><th>partitions</th><th>type</th><th>possible_keys</th><th>key</th><th>key_len</th><th>ref</th><th>rows</th><th>filtered</th><th>Extra</th></tr></thead><tbody><tr><td>1</td><td>SIMPLE</td><td>test_kl</td><td></td><td>index</td><td>name_name1_index</td><td>name_name1_index</td><td>161</td><td></td><td>1</td><td>100.00</td><td>Using where; Using index</td></tr></tbody></table>
<table><thead><tr><th>id</th><th>select_type</th><th>table</th><th>partitions</th><th>type</th><th>possible_keys</th><th>key</th><th>key_len</th><th>ref</th><th>rows</th><th>filtered</th><th>Extra</th></tr></thead><tbody><tr><td>1</td><td>SIMPLE</td><td>test_kl</td><td></td><td>ref</td><td>name_name1_index</td><td>name_name1_index</td><td>80</td><td>const</td><td>1</td><td>100.00</td><td>Using index</td></tr></tbody></table>
<p>结果分析： 对于下面这个执行计划，可以看到我们只使用了复合索引的第一个索引字段name，因此key_len是20，这个很清楚。再看上面这个执行计划，我们虽然仅仅在where后面使用了复合索引字段中的name1字段，但是你要使用复合索引的第2个索引字段，会默认使用了复合索引的第1个索引字段name，由于name1可以是null，因此key_len = 20 + 20 + 1 = 41呀！</p>
<h4 id="-再次怎加一个name2字段并为该字段创建一个索引">④ 再次怎加一个name2字段，并为该字段创建一个索引。</h4>
<p>不同的是：该字段数据类型是varchar</p>
<pre><code class="language-sql">-- 新增一个字段name2，name2可以为null
alter table test_kl add column name2 varchar(20) ; 
-- 给name2字段，设置为索引字段
alter table test_kl add index name2_index(name2) ;
-- 查看执行计划
explain select * from test_kl where name2 = &#x27;&#x27; ; 
</code></pre>
<p>结果如 下：</p>
<table><thead><tr><th>id</th><th>select_type</th><th>table</th><th>partitions</th><th>type</th><th>possible_keys</th><th>key</th><th>key_len</th><th>ref</th><th>rows</th><th>filtered</th><th>Extra</th></tr></thead><tbody><tr><td>1</td><td>SIMPLE</td><td>test_kl</td><td></td><td>ref</td><td>name2_index</td><td>name2_index</td><td>83</td><td>const</td><td>1</td><td>100.00</td><td></td></tr></tbody></table>
<p>结果分析： key_len = 20 + 1 + 2，这个20 + 1我们知道，这个2又代表什么呢？原来varchar属于可变长度，在mysql底层中，用2个字节标识可变长度。</p>
<h3 id="6ref">6）ref</h3>
<p>这里的ref的作用，指明当前表所参照的字段。</p>
<p>注意与type中的ref值区分。在type中，ref只是type类型的一种选项值。</p>
<pre><code class="language-sql">-- 给course表的tid字段，添加一个索引
create index tid_index on course(tid);
-- 查看执行计划
explain select * from course c,teacher t 
where c.tid = t.tid  
and t.tname = &#x27;tw&#x27;;
</code></pre>
<p>结果如下：</p>
<table><thead><tr><th>id</th><th>select_type</th><th>table</th><th>partitions</th><th>type</th><th>possible_keys</th><th>key</th><th>key_len</th><th>ref</th><th>rows</th><th>filtered</th><th>Extra</th></tr></thead><tbody><tr><td>1</td><td>SIMPLE</td><td>t</td><td></td><td>ref</td><td>index_name,tid_index</td><td>index_name</td><td>83</td><td>const</td><td>1</td><td>100.00</td><td>Using where</td></tr><tr><td>1</td><td>SIMPLE</td><td>c</td><td></td><td>ref</td><td>tid_index</td><td>tid_index</td><td>5</td><td>test.t.tid</td><td>1</td><td>100.00</td><td></td></tr></tbody></table>
<p>结果分析： 有两个索引，c表的c.tid引用的是t表的tid字段，因此可以看到显示结果为【数据库名.t.tid】，t表的t.name引用的是一个常量&quot;tw&quot;，因此可以看到结果显示为const，表示一个常量。</p>
<h3 id="7rows这个目前还是有点疑惑">7）rows(这个目前还是有点疑惑)</h3>
<p>被索引优化查询的数据个数 (实际通过索引而查询到的数据个数)</p>
<pre><code class="language-sql">select * from course;

select * from teacher;

select * from course c, teacher t where c.tid = t.tid and t.tname = &#x27;tz&#x27; ;

explain select * from course c,teacher t where c.tid = t.tid and t.tname = &#x27;tz&#x27; ;
</code></pre>
<p>结果如下：</p>
<table><thead><tr><th>id</th><th>select_type</th><th>table</th><th>partitions</th><th>type</th><th>possible_keys</th><th>key</th><th>key_len</th><th>ref</th><th>rows</th><th>filtered</th><th>Extra</th></tr></thead><tbody><tr><td>1</td><td>SIMPLE</td><td>t</td><td></td><td>ref</td><td>index_name,tid_index</td><td>index_name</td><td>83</td><td>const</td><td>2</td><td>100.00</td><td>Using where</td></tr><tr><td>1</td><td>SIMPLE</td><td>c</td><td></td><td>ref</td><td>tid_index</td><td>tid_index</td><td>5</td><td>test.t.tid</td><td>1</td><td>100.00</td><td></td></tr></tbody></table>
<h3 id="8extra">8）extra</h3>
<p>表示其他的一些说明，也很有用。</p>
<h4 id="-using-filesort针对单索引的情况">① using filesort：针对单索引的情况</h4>
<p>当出现了这个词，表示你当前的SQL性能消耗较大。表示进行了一次“额外”的排序。常见于order by语句中。</p>
<p>Ⅰ 什么是“额外”的排序？</p>
<p>为了讲清楚这个，我们首先要知道什么是排序。我们为了给某一个字段进行排序的时候，首先你得先查询到这个字段，然后在将这个字段进行排序。</p>
<p>紧接着，我们查看如下两个SQL语句的执行计划。</p>
<pre><code class="language-sql">-- 新建一张表，建表同时创建索引
create table test02
(   
  a1 char(3),    
  a2 char(3),   
  a3 char(3),   
  index idx_a1(a1),  
  index idx_a2(a2),   
  index idx_a3(a3)
);
-- 查看执行计划
explain select * from test02 where a1 =&#x27;&#x27; order by a1 ;
explain select * from test02 where a1 =&#x27;&#x27; order by a2 ; 
</code></pre>
<p>结果如下：</p>
<table><thead><tr><th>id</th><th>select_type</th><th>table</th><th>partitions</th><th>type</th><th>possible_keys</th><th>key</th><th>key_len</th><th>ref</th><th>rows</th><th>filtered</th><th>Extra</th></tr></thead><tbody><tr><td>1</td><td>SIMPLE</td><td>test02</td><td></td><td>ref</td><td>idx_a1</td><td>idx_a1</td><td>13</td><td>const</td><td>1</td><td>100.00</td><td></td></tr></tbody></table>
<table><thead><tr><th>id</th><th>select_type</th><th>table</th><th>partitions</th><th>type</th><th>possible_keys</th><th>key</th><th>key_len</th><th>ref</th><th>rows</th><th>filtered</th><th>Extra</th></tr></thead><tbody><tr><td>1</td><td>SIMPLE</td><td>test02</td><td></td><td>ref</td><td>idx_a1</td><td>idx_a1</td><td>13</td><td>const</td><td>1</td><td>100.00</td><td>Using filesort</td></tr></tbody></table>
<p>结果分析： 对于第一个执行计划，where后面我们先查询了a1字段，然后再利用a1做了依次排序，这个很轻松。但是对于第二个执行计划，where后面我们查询了a1字段，然而利用的却是a2字段进行排序，此时myql底层会进行一次查询，进行“额外”的排序。</p>
<p>总结：对于单索引，如果排序和查找是同一个字段，则不会出现using filesort；如果排序和查找不是同一个字段，则会出现using filesort；因此where哪些字段，就order by哪些些字段。</p>
<h4 id="-using-filesort针对复合索引的情况">② using filesort：针对复合索引的情况</h4>
<p>不能跨列(官方术语：最佳左前缀)</p>
<pre><code class="language-sql">-- 删除test02的索引
drop index idx_a1 on test02;
drop index idx_a2 on test02;
drop index idx_a3 on test02;
-- 创建一个复合索引
alter table test02 add index idx_a1_a2_a3 (a1,a2,a3) ;
-- 查看下面SQL语句的执行计划
explain select * from test02 where a1=&#x27;&#x27; order by a3 ;  -- using filesort
explain select * from test02 where a2=&#x27;&#x27; order by a3 ;  -- using filesort
explain select * from test02 where a1=&#x27;&#x27; order by a2 ;
</code></pre>
<p>结果如下：</p>
<table><thead><tr><th>id</th><th>select_type</th><th>table</th><th>partitions</th><th>type</th><th>possible_keys</th><th>key</th><th>key_len</th><th>ref</th><th>rows</th><th>filtered</th><th>Extra</th></tr></thead><tbody><tr><td>1</td><td>SIMPLE</td><td>test02</td><td></td><td>ref</td><td>idx_a1_a2_a3</td><td>idx_a1_a2_a3</td><td>13</td><td>const</td><td>1</td><td>100.00</td><td>Using where; Using index; Using filesort</td></tr></tbody></table>
<table><thead><tr><th>id</th><th>select_type</th><th>table</th><th>partitions</th><th>type</th><th>possible_keys</th><th>key</th><th>key_len</th><th>ref</th><th>rows</th><th>filtered</th><th>Extra</th></tr></thead><tbody><tr><td>1</td><td>SIMPLE</td><td>test02</td><td></td><td>index</td><td>idx_a1_a2_a3</td><td>idx_a1_a2_a3</td><td>39</td><td></td><td>1</td><td>100.00</td><td>Using where; Using index; Using filesort</td></tr></tbody></table>
<table><thead><tr><th>id</th><th>select_type</th><th>table</th><th>partitions</th><th>type</th><th>possible_keys</th><th>key</th><th>key_len</th><th>ref</th><th>rows</th><th>filtered</th><th>Extra</th></tr></thead><tbody><tr><td>1</td><td>SIMPLE</td><td>test02</td><td></td><td>ref</td><td>idx_a1_a2_a3</td><td>idx_a1_a2_a3</td><td>13</td><td>const</td><td>1</td><td>100.00</td><td>Using index</td></tr></tbody></table>
<p>结果分析： 复合索引的顺序是(a1,a2,a3)，可以看到a1在最左边，因此a1就叫做“最佳左前缀”，如果要使用后面的索引字段，必须先使用到这个a1字段。对于explain1，where后面我们使用a1字段，但是后面的排序使用了a3，直接跳过了a2，属于跨列；对于explain2，where后面我们使用了a2字段，直接跳过了a1字段，也属于跨列；对于explain3，where后面我们使用a1字段，后面使用的是a2字段，因此没有出现【using filesort】。</p>
<h4 id="-using-temporary">③ using temporary</h4>
<p>当出现了这个词，也表示你当前的SQL性能消耗较大。这是由于当前SQL用到了临时表。一般出现在group by中。</p>
<pre><code class="language-sql">explain select a1 from test02 where a1 in (&#x27;1&#x27;,&#x27;2&#x27;,&#x27;3&#x27;) group by a1 ;
explain select a2 from test02 where a1 in (&#x27;1&#x27;,&#x27;2&#x27;,&#x27;3&#x27;) group by a2 ; --using temporary
</code></pre>
<p>结果如下：</p>
<table><thead><tr><th>id</th><th>select_type</th><th>table</th><th>partitions</th><th>type</th><th>possible_keys</th><th>key</th><th>key_len</th><th>ref</th><th>rows</th><th>filtered</th><th>Extra</th></tr></thead><tbody><tr><td>1</td><td>SIMPLE</td><td>test02</td><td></td><td>index</td><td>idx_a1_a2_a3</td><td>idx_a1_a2_a3</td><td>39</td><td></td><td>1</td><td>100.00</td><td>Using where; Using index</td></tr></tbody></table>
<table><thead><tr><th>id</th><th>select_type</th><th>table</th><th>partitions</th><th>type</th><th>possible_keys</th><th>key</th><th>key_len</th><th>ref</th><th>rows</th><th>filtered</th><th>Extra</th></tr></thead><tbody><tr><td>1</td><td>SIMPLE</td><td>test02</td><td></td><td>index</td><td>idx_a1_a2_a3</td><td>idx_a1_a2_a3</td><td>39</td><td></td><td>1</td><td>100.00</td><td>Using where; Using index; Using temporary</td></tr></tbody></table>
<p>结果分析： 当你查询哪个字段，就按照那个字段分组，否则就会出现using temporary。</p>
<p>针对using temporary，我们在看一个例子：</p>
<p>using temporary表示需要额外再使用一张表，一般出现在group by语句中。虽然已经有表了，但是不适用，必须再来一张表。</p>
<p>再次来看mysql的编写过程和解析过程。</p>
<ol>
<li>编写过程</li>
</ol>
<pre><code class="language-sql">select dinstinct  ..from  ..join ..on ..where ..group by ..having ..order by ..limit ..
</code></pre>
<ol start="2">
<li>解析过程</li>
</ol>
<pre><code class="language-sql">from .. on.. join ..where ..group by ..having ..select dinstinct ..order by ..limit ..
</code></pre>
<p>很显然，where后是group by，然后才是select。基于此，我们再查看如下两个SQL语句的执行计划。</p>
<pre><code class="language-sql">explain select * from test03 where a2=2 and a4=4 group by a2, a4;
explain select * from test03 where a2=2 and a4=4 group by a3;
</code></pre>
<p>分析如下： 对于第一个执行计划，where后面是a2和a4，接着我们按照a2和a4分组，很明显这两张表已经有了，直接在a2和a4上分组就行了。但是对于第二个执行计划，where后面是a2和a4，接着我们却按照a3分组，很明显我们没有a3这张表，因此有需要再来一张临时表a3。因此就会出现using temporary。</p>
<h4 id="-using-index">④ using index</h4>
<p>当你看到这个关键词，恭喜你，表示你的SQL性能提升了。</p>
<p>using index称之为“索引覆盖”。</p>
<p>当出现了using index，就表示不用读取源表，而只利用索引获取数据，不需要回源表查询。</p>
<p>只要使用到的列，全部出现在索引中，就是索引覆盖。</p>
<pre><code class="language-sql">-- 删除test02中的复合索引idx_a1_a2_a3
drop index idx_a1_a2_a3 on test02;
-- 重新创建一个复合索引idx_a1_a2 
create index idx_a1_a2 on test02(a1,a2);
-- 查看执行计划
explain select a1,a3 from test02 where a1=&#x27;&#x27; or a3= &#x27;&#x27; ;
explain select a1,a2 from test02 where a1=&#x27;&#x27; and a2= &#x27;&#x27; ;
</code></pre>
<p>结果如下：</p>
<table><thead><tr><th>id</th><th>select_type</th><th>table</th><th>partitions</th><th>type</th><th>possible_keys</th><th>key</th><th>key_len</th><th>ref</th><th>rows</th><th>filtered</th><th>Extra</th></tr></thead><tbody><tr><td>1</td><td>SIMPLE</td><td>test02</td><td></td><td>ALL</td><td>idx_a1_a2</td><td></td><td></td><td></td><td>1</td><td>100.00</td><td>Using where</td></tr></tbody></table>
<table><thead><tr><th>id</th><th>select_type</th><th>table</th><th>partitions</th><th>type</th><th>possible_keys</th><th>key</th><th>key_len</th><th>ref</th><th>rows</th><th>filtered</th><th>Extra</th></tr></thead><tbody><tr><td>1</td><td>SIMPLE</td><td>test02</td><td></td><td>ref</td><td>idx_a1_a2</td><td>idx_a1_a2</td><td>26</td><td>const,const</td><td>1</td><td>100.00</td><td>Using index</td></tr></tbody></table>
<p>结果分析： 我们创建的是a1和a2的复合索引，对于第一个执行计划，我们却出现了a3，该字段并没有创建索引，因此没有出现using index，而是using where，表示我们需要回表查询。对于第二个执行计划，属于完全的索引覆盖，因此出现了using index。</p>
<p>针对using index，我们在查看一个案例：</p>
<pre><code class="language-sql">explain select a1,a2 from test02 where a1=&#x27;&#x27; or a2= &#x27;&#x27; ;
explain select a1,a2 from test02;
</code></pre>
<p>结果如下：</p>
<p>如果用到了索引覆盖(using index时)，会对possible_keys和key造成影响：</p>
<ol>
<li>
<p>如果没有where，则索引只出现在key中；</p>
</li>
<li>
<p>如果有where，则索引 出现在key和possible_keys中。</p>
</li>
</ol>
<h4 id="-using-where">⑤ using where</h4>
<p>表示需要【回表查询】，表示既在索引中进行了查询，又回到了源表进行了查询。</p>
<pre><code class="language-sql">-- 删除test02中的复合索引idx_a1_a2
drop index idx_a1_a2 on test02;
-- 将a1字段，新增为一个索引
create index a1_index on test02(a1);
-- 查看执行计划
explain select a1,a3 from test02 where a1=&quot;&quot; and a3=&quot;&quot; ;
</code></pre>
<p>结果如下：</p>
<table><thead><tr><th>id</th><th>select_type</th><th>table</th><th>partitions</th><th>type</th><th>possible_keys</th><th>key</th><th>key_len</th><th>ref</th><th>rows</th><th>filtered</th><th>Extra</th></tr></thead><tbody><tr><td>1</td><td>SIMPLE</td><td>test02</td><td></td><td>ref</td><td>a1_index</td><td>a1_index</td><td>13</td><td>const</td><td>1</td><td>100.00</td><td>Using where</td></tr></tbody></table>
<p>结果分析： 我们既使用了索引a1，表示我们使用了索引进行查询。但是又对于a3字段，我们并没有使用索引，因此对于a3字段，需要回源表查询，这个时候出现了using where。</p>
<h4 id="-impossible-where了解">⑥ impossible where(了解)</h4>
<p>当where子句永远为False的时候，会出现impossible where</p>
<pre><code class="language-sql">-- 查看执行计划
explain select a1 from test02 where a1=&quot;a&quot; and a1=&quot;b&quot; ;
</code></pre>
<p>结果如下：</p>
<table><thead><tr><th>id</th><th>select_type</th><th>table</th><th>partitions</th><th>type</th><th>possible_keys</th><th>key</th><th>key_len</th><th>ref</th><th>rows</th><th>filtered</th><th>Extra</th></tr></thead><tbody><tr><td>1</td><td>SIMPLE</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td>Impossible WHERE</td></tr></tbody></table>
<h2 id="6优化示例">6、优化示例</h2>
<h3 id="1引入案例">1）引入案例</h3>
<pre><code class="language-sql">-- 创建新表
create table test03
(  
  a1 int(4) not null,   
  a2 int(4) not null,    
  a3 int(4) not null,   
  a4 int(4) not null
);
-- 创建一个复合索引
create index a1_a2_a3_test03 on test03(a1,a2,a3);
-- 查看执行计划
explain select a3 from test03 where a1=1 and a2=2 and a3=3;
</code></pre>
<p>结果如下：</p>
<table><thead><tr><th>id</th><th>select_type</th><th>table</th><th>partitions</th><th>type</th><th>possible_keys</th><th>key</th><th>key_len</th><th>ref</th><th>rows</th><th>filtered</th><th>Extra</th></tr></thead><tbody><tr><td>1</td><td>SIMPLE</td><td>test03</td><td></td><td>ref</td><td>a1_a2_a3_test03</td><td>a1_a2_a3_test03</td><td>12</td><td>const,const,const</td><td>1</td><td>100.00</td><td>Using index</td></tr></tbody></table>
<p>推荐写法： 复合索引顺序和使用顺序一致。</p>
<p>下面看看【不推荐写法】：复合索引顺序和使用顺序不一致。</p>
<pre><code class="language-sql">-- 查看执行计划
explain select a3 from test03 where a3=1 and a2=2 and a1=3;
</code></pre>
<p>结果如下：</p>
<table><thead><tr><th>id</th><th>select_type</th><th>table</th><th>partitions</th><th>type</th><th>possible_keys</th><th>key</th><th>key_len</th><th>ref</th><th>rows</th><th>filtered</th><th>Extra</th></tr></thead><tbody><tr><td>1</td><td>SIMPLE</td><td>test03</td><td></td><td>ref</td><td>a1_a2_a3_test03</td><td>a1_a2_a3_test03</td><td>12</td><td>const,const,const</td><td>1</td><td>100.00</td><td>Using index</td></tr></tbody></table>
<p>结果分析： 虽然结果和上述结果一致，但是不推荐这样写。但是这样写怎么又没有问题呢？这是由于SQL优化器的功劳，它帮我们调整了顺序。</p>
<p>最后再补充一点：对于复合索引，不要跨列使用</p>
<pre><code class="language-sql">-- 查看执行计划
explain select a3 from test03 where a1=1 and a3=2 group by a3;
</code></pre>
<p>结果如下：</p>
<table><thead><tr><th>id</th><th>select_type</th><th>table</th><th>partitions</th><th>type</th><th>possible_keys</th><th>key</th><th>key_len</th><th>ref</th><th>rows</th><th>filtered</th><th>Extra</th></tr></thead><tbody><tr><td>1</td><td>SIMPLE</td><td>test03</td><td></td><td>ref</td><td>a1_a2_a3_test03</td><td>a1_a2_a3_test03</td><td>4</td><td>const</td><td>1</td><td>100.00</td><td>Using where; Using index</td></tr></tbody></table>
<p>结果分析： a1_a2_a3是一个复合索引，我们使用a1索引后，直接跨列使用了a3，直接跳过索引a2，因此索引a3失效了，当使用a3进行分组的时候，就会出现using where。</p>
<h3 id="2单表优化">2）单表优化</h3>
<pre><code class="language-sql">-- 创建新表
create table book
(    
    bid int(4) primary key,      
    name varchar(20) not null,     
    authorid int(4) not null,     
    publicid int(4) not null,    
    typeid int(4) not null 
);
-- 插入数据
insert into book values(1,&#x27;tjava&#x27;,1,1,2) ;
insert into book values(2,&#x27;tc&#x27;,2,1,2) ;
insert into book values(3,&#x27;wx&#x27;,3,2,1) ;
insert into book values(4,&#x27;math&#x27;,4,2,3) ;  

select * from book;
</code></pre>
<p>结果如下：</p>
<table><thead><tr><th>bid</th><th>name</th><th>authorid</th><th>publicid</th><th>typeid</th></tr></thead><tbody><tr><td>1</td><td>tjava</td><td>1</td><td>1</td><td>2</td></tr><tr><td>2</td><td>tc</td><td>2</td><td>1</td><td>2</td></tr><tr><td>3</td><td>wx</td><td>3</td><td>2</td><td>1</td></tr><tr><td>4</td><td>math</td><td>4</td><td>2</td><td>3</td></tr></tbody></table>
<p>案例：查询authorid=1且typeid为2或3的bid，并根据typeid降序排列。</p>
<pre><code class="language-sql">explain 
select bid from book 
where typeid in(2,3) and authorid=1 
order by typeid desc ;    
</code></pre>
<p>结果如下：</p>
<table><thead><tr><th>id</th><th>select_type</th><th>table</th><th>partitions</th><th>type</th><th>possible_keys</th><th>key</th><th>key_len</th><th>ref</th><th>rows</th><th>filtered</th><th>Extra</th></tr></thead><tbody><tr><td>1</td><td>SIMPLE</td><td>book</td><td></td><td>ALL</td><td></td><td></td><td></td><td></td><td>4</td><td>25.00</td><td>Using where; Using filesort</td></tr></tbody></table>
<p>这是没有进行任何优化的SQL，可以看到typ为ALL类型，extra为using filesort，可以想象这个SQL有多恐怖。</p>
<p>优化：添加索引的时候，要根据MySQL解析顺序添加索引，又回到了MySQL的解析顺序，下面我们再来看看MySQL的解析顺序。</p>
<pre><code class="language-sql">from .. on.. join ..where ..group by ..having ..select dinstinct ..order by ..limit ..
</code></pre>
<h4 id="-优化1基于此我们进行索引的添加并再次查看执行计划">① 优化1：基于此，我们进行索引的添加，并再次查看执行计划。</h4>
<pre><code class="language-sql">-- 添加索引
create index typeid_authorid_bid on book(typeid,authorid,bid);
-- 再次查看执行计划
explain 
select bid from book 
where typeid in(2,3) and authorid=1  
order by typeid desc ;
</code></pre>
<p>结果如下：</p>
<table><thead><tr><th>id</th><th>select_type</th><th>table</th><th>partitions</th><th>type</th><th>possible_keys</th><th>key</th><th>key_len</th><th>ref</th><th>rows</th><th>filtered</th><th>Extra</th></tr></thead><tbody><tr><td>1</td><td>SIMPLE</td><td>book</td><td></td><td>range</td><td>typeid_authorid_bid</td><td>typeid_authorid_bid</td><td>8</td><td></td><td>2</td><td>100.00</td><td>Using where; Backward index scan; Using index</td></tr></tbody></table>
<p>结果分析： 结果并不是和我们想象的一样，还是出现了using where，查看索引长度key_len=8，表示我们只使用了2个索引，有一个索引失效了。</p>
<h4 id="-优化2使用了in有时候会导致索引失效基于此有了如下一种优化思路">② 优化2：使用了in有时候会导致索引失效，基于此有了如下一种优化思路。</h4>
<p>将in字段放在最后面。需要注意一点：每次创建新的索引的时候，最好是删除以前的废弃索引，否则有时候会产生干扰(索引之间)。</p>
<pre><code class="language-sql">-- 删除以前的索引
drop index typeid_authorid_bid on book;
-- 再次创建索引
create index authorid_typeid_bid on book(authorid,typeid,bid);
-- 再次查看执行计划
explain 
select bid from book 
where authorid=1  and typeid in(2,3) 
order by typeid desc ;
</code></pre>
<p>结果如下：</p>
<table><thead><tr><th>id</th><th>select_type</th><th>table</th><th>partitions</th><th>type</th><th>possible_keys</th><th>key</th><th>key_len</th><th>ref</th><th>rows</th><th>filtered</th><th>Extra</th></tr></thead><tbody><tr><td>1</td><td>SIMPLE</td><td>book</td><td></td><td>range</td><td>authorid_typeid_bid</td><td>authorid_typeid_bid</td><td>8</td><td></td><td>2</td><td>100.00</td><td>Using where; Backward index scan; Using index</td></tr></tbody></table>
<p>结果分析： 这里虽然没有变化，但是这是一种优化思路。</p>
<p>总结如下：</p>
<ol>
<li>
<p>最佳做前缀，保持索引的定义和使用的顺序一致性</p>
</li>
<li>
<p>索引需要逐步优化(每次创建新索引，根据情况需要删除以前的废弃索引)</p>
</li>
<li>
<p>将含In的范围查询，放到where条件的最后，防止失效。</p>
</li>
</ol>
<p>本例中同时出现了Using where（需要回原表）; Using index（不需 要回原表）：原因，where authorid=1 and typeid in(2,3)中authorid在索引(authorid,typeid,bid)中，因此不需要回原表（直接在索引表中能查到）；而typeid虽然也在索引(authorid,typeid,bid)中，但是含in的范围查询已经使该typeid索引失效，因此相当于没有typeid这个索引，所以需要回原表（using where）；</p>
<p>例如以下没有了In，则不会出现using where：</p>
<pre><code class="language-sql">explain select bid from book 
where  authorid=1 and typeid =3
order by typeid desc ;
</code></pre>
<p>结果如下：</p>
<table><thead><tr><th>id</th><th>select_type</th><th>table</th><th>partitions</th><th>type</th><th>possible_keys</th><th>key</th><th>key_len</th><th>ref</th><th>rows</th><th>filtered</th><th>Extra</th></tr></thead><tbody><tr><td>1</td><td>SIMPLE</td><td>book</td><td></td><td>ref</td><td>authorid_typeid_bid</td><td>authorid_typeid_bid</td><td>8</td><td>const,const</td><td>1</td><td>100.00</td><td>Using index</td></tr></tbody></table>
<h3 id="3两表优化">3）两表优化</h3>
<pre><code class="language-sql">-- 创建teacher2新表
create table teacher2
(      
    tid int(4) primary key,     
    cid int(4) not null
);
-- 插入数据
insert into teacher2 values(1,2);
insert into teacher2 values(2,1);
insert into teacher2 values(3,3);
-- 创建course2新表
create table course2
(  
    cid int(4) ,  
    cname varchar(20)
);
-- 插入数据
insert into course2 values(1,&#x27;java&#x27;);
insert into course2 values(2,&#x27;python&#x27;);
insert into course2 values(3,&#x27;kotlin&#x27;);
</code></pre>
<p>案例：使用一个左连接，查找教java课程的所有信息。</p>
<pre><code class="language-sql">explain 
select *
from teacher2 t
left outer join course2 c
on t.cid=c.cid 
where c.cname=&#x27;java&#x27;;
</code></pre>
<p>结果如下：</p>
<table><thead><tr><th>id</th><th>select_type</th><th>table</th><th>partitions</th><th>type</th><th>possible_keys</th><th>key</th><th>key_len</th><th>ref</th><th>rows</th><th>filtered</th><th>Extra</th></tr></thead><tbody><tr><td>1</td><td>SIMPLE</td><td>c</td><td></td><td>ALL</td><td></td><td></td><td></td><td></td><td>3</td><td>33.33</td><td>Using where</td></tr><tr><td>1</td><td>SIMPLE</td><td>t</td><td></td><td>ALL</td><td></td><td></td><td></td><td></td><td>3</td><td>33.33</td><td>Using where; Using join buffer (hash join)</td></tr></tbody></table>
<h4 id="-优化">① 优化</h4>
<p>对于两张表，索引往哪里加？答：对于表连接，小表驱动大表。索引建立在经常使用的字段上。</p>
<p>为什么小表驱动大表好一些呢？</p>
<pre><code class="language-sql">-- 小表:10   
-- 大表:300

-- 小表驱动大表
select ...where 小表.x10=大表.x300 ;
for(int i=0;i&lt;小表.length10;i++)
{   
    for(int j=0;j&lt;大表.length300;j++)  
    {       
        ...   
    }
}
-- 大表驱动小表
select ...where 大表.x300=小表.x10 ;
for(int i=0;i&lt;大表.length300;i++)
{  
    for(int j=0;j&lt;小表.length10;j++)   
    {     
        ...   
    }
}
</code></pre>
<p>分析： 以上2个FOR循环，最终都会循环3000次；但是对于双层循环来说：一般建议，将数据小的循环，放外层。数据大的循环，放内层。不用管这是为什么，这是编程语言的一个原则，对于双重循环，外层循环少，内存循环大，程序的性能越高。</p>
<p>结论：当编写【…on t.cid=c.cid】时，将数据量小的表放左边（假设此时t表数据量小，c表数据量大。）</p>
<p>我们已经知道了，对于两表连接，需要利用小表驱动大表，例如【…on t.cid=c.cid】，t如果是小表(10条)，c如果是大表(300条)，那么t每循环1次，就需要循环300次，即t表的t.cid字段属于，经常使用的字段，因此需要给cid字段添加索引。</p>
<p>更深入的说明： 一般情况下，左连接给左表加索引。右连接给右表加索引。其他表需不需要加索引，我们逐步尝试。</p>
<pre><code class="language-sql">-- 给左表的字段加索引
create index cid_teacher2 on teacher2(cid);
-- 查看执行计划
explain 
select *
from teacher2 t 
left outer join course2 c
on t.cid=c.cid
where c.cname=&#x27;java&#x27;;
</code></pre>
<p>结果如下：</p>
<table><thead><tr><th>id</th><th>select_type</th><th>table</th><th>partitions</th><th>type</th><th>possible_keys</th><th>key</th><th>key_len</th><th>ref</th><th>rows</th><th>filtered</th><th>Extra</th></tr></thead><tbody><tr><td>1</td><td>SIMPLE</td><td>c</td><td></td><td>ALL</td><td></td><td></td><td></td><td></td><td>3</td><td>33.33</td><td>Using where</td></tr><tr><td>1</td><td>SIMPLE</td><td>t</td><td></td><td>ref</td><td>cid_teacher2</td><td>cid_teacher2</td><td>4</td><td>light.c.cid</td><td>1</td><td>100.00</td><td>Using index</td></tr></tbody></table>
<p>当然你可以下去接着优化，给cname添加一个索引。索引优化是一个逐步的过程，需要一点点尝试。</p>
<pre><code class="language-sql">-- 给cname的字段加索引
create index cname_course2 on course2(cname);
-- 查看执行计划
explain
select t.cid,c.cname
from teacher2 t
left outer join course2 c
on t.cid=c.cid 
where c.cname=&#x27;java&#x27;;
</code></pre>
<p>结果如下：</p>
<table><thead><tr><th>id</th><th>select_type</th><th>table</th><th>partitions</th><th>type</th><th>possible_keys</th><th>key</th><th>key_len</th><th>ref</th><th>rows</th><th>filtered</th><th>Extra</th></tr></thead><tbody><tr><td>1</td><td>SIMPLE</td><td>c</td><td></td><td>ref</td><td>cname_course2</td><td>cname_course2</td><td>83</td><td>const</td><td>1</td><td>100.00</td><td>Using where</td></tr><tr><td>1</td><td>SIMPLE</td><td>t</td><td></td><td>ref</td><td>cid_teacher2</td><td>cid_teacher2</td><td>4</td><td>light.c.cid</td><td>1</td><td>100.00</td><td>Using index</td></tr></tbody></table>
<p>最后补充一个：Using join buffer是extra中的一个选项，表示Mysql引擎使用了“连接缓存”，即MySQL底层动了你的SQL，你写的太差了。</p>
<h3 id="4三表优化">4）三表优化</h3>
<ul>
<li>大于等于张表，优  化原则一样</li>
<li>小表驱动大表</li>
<li>索引建立在经常查询的字段上</li>
</ul>
<h2 id="7避免索引失效的一些原则">7、避免索引失效的一些原则</h2>
<h3 id="-复合索引需要注意的点">① 复合索引需要注意的点</h3>
<ul>
<li>复合索引，不要跨列或无序使用(最佳左前缀)</li>
<li>复合索引，尽量使用全索引匹配，也就是说，你建立几个索引，就使用几个索引</li>
</ul>
<h3 id="-不要在索引上进行任何操作计算函数类型转换否则索引失效">② 不要在索引上进行任何操作(计算、函数、类型转换)，否则索引失效</h3>
<pre><code class="language-sql">explain select * from book where authorid = 1 and typeid = 2;
explain select * from book where authorid*2 = 1 and typeid = 2 ;
</code></pre>
<p>结果如下：</p>
<table><thead><tr><th>id</th><th>select_type</th><th>table</th><th>partitions</th><th>type</th><th>possible_keys</th><th>key</th><th>key_len</th><th>ref</th><th>rows</th><th>filtered</th><th>Extra</th></tr></thead><tbody><tr><td>1</td><td>SIMPLE</td><td>book</td><td></td><td>ref</td><td>authorid_typeid_bid</td><td>authorid_typeid_bid</td><td>8</td><td>const,const</td><td>1</td><td>100.00</td><td></td></tr></tbody></table>
<table><thead><tr><th>id</th><th>select_type</th><th>table</th><th>partitions</th><th>type</th><th>possible_keys</th><th>key</th><th>key_len</th><th>ref</th><th>rows</th><th>filtered</th><th>Extra</th></tr></thead><tbody><tr><td>1</td><td>SIMPLE</td><td>book</td><td></td><td>ALL</td><td></td><td></td><td></td><td></td><td>4</td><td>25.00</td><td>Using where</td></tr></tbody></table>
<h3 id="-索引不能使用不等于-或is-null-is-not-null否则自身以及右侧所有全部失效针对大多数情况复合索引中如果有则自身和右侧索引全部失效">③ 索引不能使用不等于（<code>!=</code> <code>&lt;&gt;</code>）或<code>is null</code> (<code>is not null</code>)，否则自身以及右侧所有全部失效(针对大多数情况)。复合索引中如果有&gt;，则自身和右侧索引全部失效。</h3>
<pre><code class="language-sql">-- 针对不是复合索引的情况
explain select * from book where authorid != 1 and typeid =2 ;
explain select * from book where authorid = 1 and typeid !=2 ;
explain select * from book where authorid != 1 and typeid !=2 ;
</code></pre>
<p>结果如下：</p>
<table><thead><tr><th>id</th><th>select_type</th><th>table</th><th>partitions</th><th>type</th><th>possible_keys</th><th>key</th><th>key_len</th><th>ref</th><th>rows</th><th>filtered</th><th>Extra</th></tr></thead><tbody><tr><td>1</td><td>SIMPLE</td><td>book</td><td></td><td>range</td><td>authorid_typeid_bid</td><td>authorid_typeid_bid</td><td>4</td><td></td><td>4</td><td>25.00</td><td>Using index condition</td></tr></tbody></table>
<table><thead><tr><th>id</th><th>select_type</th><th>table</th><th>partitions</th><th>type</th><th>possible_keys</th><th>key</th><th>key_len</th><th>ref</th><th>rows</th><th>filtered</th><th>Extra</th></tr></thead><tbody><tr><td>1</td><td>SIMPLE</td><td>book</td><td></td><td>range</td><td>authorid_typeid_bid,idx_book_at</td><td>authorid_typeid_bid</td><td>8</td><td></td><td>2</td><td>100.00</td><td>Using index condition</td></tr></tbody></table>
<table><thead><tr><th>id</th><th>select_type</th><th>table</th><th>partitions</th><th>type</th><th>possible_keys</th><th>key</th><th>key_len</th><th>ref</th><th>rows</th><th>filtered</th><th>Extra</th></tr></thead><tbody><tr><td>1</td><td>SIMPLE</td><td>book</td><td></td><td>range</td><td>authorid_typeid_bid</td><td>authorid_typeid_bid</td><td>4</td><td></td><td>4</td><td>75.00</td><td>Using index condition</td></tr></tbody></table>
<p>再观看下面这个案例：</p>
<pre><code class="language-sql">-- 删除单独的索引
drop index authorid_index on book;
drop index typeid_index on book;
-- 创建一个复合索引
alter table book add index idx_book_at (authorid,typeid);
-- 查看执行计划
explain select * from book where authorid &gt; 1 and typeid = 2 ;
explain select * from book where authorid = 1 and typeid &gt; 2 ;
</code></pre>
<p>结果如下：</p>
<table><thead><tr><th>id</th><th>select_type</th><th>table</th><th>partitions</th><th>type</th><th>possible_keys</th><th>key</th><th>key_len</th><th>ref</th><th>rows</th><th>filtered</th><th>Extra</th></tr></thead><tbody><tr><td>1</td><td>SIMPLE</td><td>book</td><td></td><td>range</td><td>authorid_typeid_bid,idx_book_at</td><td>authorid_typeid_bid</td><td>4</td><td></td><td>3</td><td>25.00</td><td>Using index condition</td></tr></tbody></table>
<table><thead><tr><th>id</th><th>select_type</th><th>table</th><th>partitions</th><th>type</th><th>possible_keys</th><th>key</th><th>key_len</th><th>ref</th><th>rows</th><th>filtered</th><th>Extra</th></tr></thead><tbody><tr><td>1</td><td>SIMPLE</td><td>book</td><td></td><td>range</td><td>authorid_typeid_bid,idx_book_at</td><td>authorid_typeid_bid</td><td>8</td><td></td><td>1</td><td>100.00</td><td>Using index condition</td></tr></tbody></table>
<p>结论：复合索引中如果有<code>【&gt;】</code>，则自身和右侧索引全部失效。</p>
<p>在看看复合索引中有<code>【&lt;】</code>的情况：</p>
<pre><code class="language-sql">explain select * from book where authorid &lt; 1 and typeid = 2 ;
explain select * from book where authorid &lt; 4 and typeid = 2 ;
</code></pre>
<table><thead><tr><th>id</th><th>select_type</th><th>table</th><th>partitions</th><th>type</th><th>possible_keys</th><th>key</th><th>key_len</th><th>ref</th><th>rows</th><th>filtered</th><th>Extra</th></tr></thead><tbody><tr><td>1</td><td>SIMPLE</td><td>book</td><td></td><td>range</td><td>authorid_typeid_bid,idx_book_at</td><td>authorid_typeid_bid</td><td>4</td><td></td><td>1</td><td>25.00</td><td>Using index condition</td></tr></tbody></table>
<table><thead><tr><th>id</th><th>select_type</th><th>table</th><th>partitions</th><th>type</th><th>possible_keys</th><th>key</th><th>key_len</th><th>ref</th><th>rows</th><th>filtered</th><th>Extra</th></tr></thead><tbody><tr><td>1</td><td>SIMPLE</td><td>book</td><td></td><td>range</td><td>authorid_typeid_bid,idx_book_at</td><td>authorid_typeid_bid</td><td>4</td><td></td><td>3</td><td>25.00</td><td>Using index condition</td></tr></tbody></table>
<p>我们学习索引优化 ，是一个大部分情况适用的结论，但由于SQL优化器等原因 该结论不是100%正确。一般而言， 范围查询（&gt; &lt; in），之后的索引失效。</p>
<h3 id="-sql优化是一种概率层面的优化至于是否实际使用了我们的优化需要通过explain进行推测">④ SQL优化，是一种概率层面的优化。至于是否实际使用了我们的优化，需要通过explain进行推测。</h3>
<pre><code class="language-sql">-- 删除复合索引
drop index authorid_typeid_bid on book;
-- 为authorid和typeid，分别创建索引
create index authorid_index on book(authorid);
create index typeid_index on book(typeid);
-- 查看执行计划
explain select * from book where authorid = 1 and typeid =2 ;
</code></pre>
<p>结果如下：</p>
<table><thead><tr><th>id</th><th>select_type</th><th>table</th><th>partitions</th><th>type</th><th>possible_keys</th><th>key</th><th>key_len</th><th>ref</th><th>rows</th><th>filtered</th><th>Extra</th></tr></thead><tbody><tr><td>1</td><td>SIMPLE</td><td>book</td><td></td><td>ref</td><td>idx_book_at,authorid_index,typeid_index</td><td>idx_book_at</td><td>8</td><td>const,const</td><td>1</td><td>100.00</td><td></td></tr></tbody></table>
<p>结果分析： 我们创建了两个索引，但是实际上只使用了一个索引。因为对于两个单独的索引，程序觉得只用一个索引就够了，不需要使用两个。</p>
<p>当我们创建一个复合索引，再次执行上面的SQL：</p>
<pre><code class="language-sql">create index authorid_typeid_index on book(authorid, typeid);
-- 查看执行计划
explain select * from book where authorid = 1 and typeid =2 ;
</code></pre>
<p>结果如下：</p>
<table><thead><tr><th>id</th><th>select_type</th><th>table</th><th>partitions</th><th>type</th><th>possible_keys</th><th>key</th><th>key_len</th><th>ref</th><th>rows</th><th>filtered</th><th>Extra</th></tr></thead><tbody><tr><td>1</td><td>SIMPLE</td><td>book</td><td></td><td>ref</td><td>idx_book_at,authorid_index,typeid_index,authorid_typeid_index</td><td>idx_book_at</td><td>8</td><td>const,const</td><td>1</td><td>100.00</td><td></td></tr></tbody></table>
<h3 id="-索引覆盖百分之百没问题">⑤ 索引覆盖，百分之百没问题</h3>
<h3 id="-like尽量以常量开头不要以开头否则索引失效">⑥ like尽量以“常量”开头，不要以’%&#x27;开头，否则索引失效</h3>
<pre><code class="language-sql">explain select * from teacher where tname like &quot;%x%&quot; ;
explain select * from teacher  where tname like &#x27;x%&#x27;;
explain select tname from teacher  where tname like &#x27;%x%&#x27;;
</code></pre>
<p>结果如下：</p>
<table><thead><tr><th>id</th><th>select_type</th><th>table</th><th>partitions</th><th>type</th><th>possible_keys</th><th>key</th><th>key_len</th><th>ref</th><th>rows</th><th>filtered</th><th>Extra</th></tr></thead><tbody><tr><td>1</td><td>SIMPLE</td><td>teacher</td><td></td><td>ALL</td><td></td><td></td><td></td><td></td><td>4</td><td>25.00</td><td>Using where</td></tr></tbody></table>
<table><thead><tr><th>id</th><th>select_type</th><th>table</th><th>partitions</th><th>type</th><th>possible_keys</th><th>key</th><th>key_len</th><th>ref</th><th>rows</th><th>filtered</th><th>Extra</th></tr></thead><tbody><tr><td>1</td><td>SIMPLE</td><td>teacher</td><td></td><td>range</td><td>index_name</td><td>index_name</td><td>83</td><td></td><td>1</td><td>100.00</td><td>Using index condition</td></tr></tbody></table>
<table><thead><tr><th>id</th><th>select_type</th><th>table</th><th>partitions</th><th>type</th><th>possible_keys</th><th>key</th><th>key_len</th><th>ref</th><th>rows</th><th>filtered</th><th>Extra</th></tr></thead><tbody><tr><td>1</td><td>SIMPLE</td><td>teacher</td><td>index</td><td>index_name</td><td>83</td><td></td><td></td><td></td><td>4</td><td>25.00</td><td>Using where; Using index</td></tr></tbody></table>
<p>结论如下： like尽量不要使用类似&quot;%x%&quot;情况，但是可以使用&quot;x%&quot;情况。如果非使用 &quot;%x%&quot;情况，需要使用索引覆盖。</p>
<h3 id="-尽量不要使用类型转换显示隐式否则索引失效">⑦ 尽量不要使用类型转换（显示、隐式），否则索引失效</h3>
<pre><code class="language-sql">explain select * from teacher where tname = &#x27;abc&#x27; ;
explain select * from teacher where tname = 123 ;
</code></pre>
<p>结果如下：</p>
<table><thead><tr><th>id</th><th>select_type</th><th>table</th><th>partitions</th><th>type</th><th>possible_keys</th><th>key</th><th>key_len</th><th>ref</th><th>rows</th><th>filtered</th><th>Extra</th></tr></thead><tbody><tr><td>1</td><td>SIMPLE</td><td>teacher</td><td></td><td>ref</td><td>index_name</td><td>index_name</td><td>83</td><td>const</td><td>1</td><td>100.00</td><td></td></tr></tbody></table>
<table><thead><tr><th>id</th><th>select_type</th><th>table</th><th>partitions</th><th>type</th><th>possible_keys</th><th>key</th><th>key_len</th><th>ref</th><th>rows</th><th>filtered</th><th>Extra</th></tr></thead><tbody><tr><td>1</td><td>SIMPLE</td><td>teacher</td><td></td><td>ALL</td><td>index_name</td><td></td><td></td><td></td><td>4</td><td>25.00</td><td>Using where</td></tr></tbody></table>
<h3 id="-尽量不要使用or否则索引失效">⑧ 尽量不要使用or，否则索引失效</h3>
<pre><code class="language-sql">explain select * from teacher where tname =&#x27;&#x27; and tcid &gt;1 ;
explain select * from teacher where tname =&#x27;&#x27; or tcid &gt;1 ;
</code></pre>
<p>结果如下：</p>
<table><thead><tr><th>id</th><th>select_type</th><th>table</th><th>partitions</th><th>type</th><th>possible_keys</th><th>key</th><th>key_len</th><th>ref</th><th>rows</th><th>filtered</th><th>Extra</th></tr></thead><tbody><tr><td>1</td><td>SIMPLE</td><td>teacher</td><td></td><td>ref</td><td>uk_tcid,index_name</td><td>index_name</td><td>83</td><td>const</td><td>1</td><td>75.00</td><td>Using where</td></tr></tbody></table>
<table><thead><tr><th>id</th><th>select_type</th><th>table</th><th>partitions</th><th>type</th><th>possible_keys</th><th>key</th><th>key_len</th><th>ref</th><th>rows</th><th>filtered</th><th>Extra</th></tr></thead><tbody><tr><td>1</td><td>SIMPLE</td><td>teacher</td><td></td><td>ALL</td><td>uk_tcid,index_name</td><td></td><td></td><td></td><td>4</td><td>55.55</td><td>Using where</td></tr></tbody></table>
<p>注意：or很猛，会让自身索引和左右两侧的索引都失效。</p>
<h2 id="8一些其他的优化方法">8、一些其他的优化方法</h2>
<h3 id="1exists和in的优化">1）exists和in的优化</h3>
<p>如果主查询的数据集大，则使用i关键字，效率高。</p>
<p>如果子查询的数据集大，则使用exist关键字,效率高。</p>
<pre><code class="language-sql">select ..from table where exist (子查询) ;
select ..from table where 字段 in  (子查询) ;
</code></pre>
<h3 id="2order-by优化">2）order by优化</h3>
<ul>
<li>
<p>IO就是访问硬盘文件的次数</p>
</li>
<li>
<p>using filesort 有两种算法：双路排序、单路排序（根据IO的次数）</p>
</li>
<li>
<p>MySQL4.1之前默认使用双路排序；双路：扫描2次磁盘(1：从磁盘读取排序字段,对排序字段进行排序(在buffer中进行的排序)2：扫描其他字段)</p>
</li>
<li>
<p>MySQL4.1之后默认使用单路排序：只读取一次（全部字段），在buffer中进行排序。但种单路排序会有一定的隐患(不一定真的是“单路/1次IO”，有可能多次IO)。原因：如果数据量特别大，则无法将所有字段的数据一次性读取完毕，因此会进行“分片读取、多次读取”。</p>
</li>
<li>
<p>注意：单路排序 比双路排序 会占用更多的buffer。</p>
</li>
<li>
<p>单路排序在使用时，如果数据大，可以考虑调大buffer的容量大小：</p>
</li>
</ul>
<pre><code class="language-sql">-- 不一定真的是“单路/1次IO”，有可能多次IO
set max_length_for_sort_data = 1024 
</code></pre>
<p>如果max_length_for_sort_data值太低，则mysql会自动从 单路-&gt;双路(太低：需要排序的列的总大小超过了max_length_for_sort_data定义的字节数)</p>
<h4 id="-提高order-by查询的策略">① 提高order by查询的策略：</h4>
<ul>
<li>选择使用单路、双路 ；调整buffer的容量大小</li>
<li>避免使用select * …（select后面写所有字段，也比写*效率高）</li>
<li>复合索引，不要跨列使用 ，避免using filesort保证全部的排序字段，排序的一致性（都是升序或降序）</li>
</ul>
<p>篇幅很长，内容较多，建议收藏。</p></div><footer class="theme-doc-footer docusaurus-mt-lg"><div class="theme-doc-footer-edit-meta-row row"><div class="col"><a href="https://github.com/lorchr/light-docusaurus/tree/main/middleware/mysql/3-Mysql-Optimize-2.md" target="_blank" rel="noopener noreferrer" class="theme-edit-this-page"><svg fill="currentColor" height="20" width="20" viewBox="0 0 40 40" class="iconEdit_Z9Sw" aria-hidden="true"><g><path d="m34.5 11.7l-3 3.1-6.3-6.3 3.1-3q0.5-0.5 1.2-0.5t1.1 0.5l3.9 3.9q0.5 0.4 0.5 1.1t-0.5 1.2z m-29.5 17.1l18.4-18.5 6.3 6.3-18.4 18.4h-6.3v-6.2z"></path></g></svg>编辑此页</a></div><div class="col lastUpdated_vwxv"><span class="theme-last-updated">最后<!-- -->由 <b>Lorchr</b> <!-- -->于 <b><time datetime="2024-01-22T02:37:40.000Z">2024年1月22日</time></b> <!-- -->更新</span></div></div></footer></article><nav class="pagination-nav docusaurus-mt-lg" aria-label="文件选项卡"><a class="pagination-nav__link pagination-nav__link--prev" href="/light-docusaurus/middleware/mysql/Mysql-Optimize-1/"><div class="pagination-nav__sublabel">上一页</div><div class="pagination-nav__label">Mysql-Optimize-1</div></a><a class="pagination-nav__link pagination-nav__link--next" href="/light-docusaurus/middleware/mysql/Mysql-redolog-undolog-binlog/"><div class="pagination-nav__sublabel">下一页</div><div class="pagination-nav__label">Mysql-redolog-undolog-binlog</div></a></nav></div></div><div class="col col--3"><div class="tableOfContents_bqdL thin-scrollbar theme-doc-toc-desktop"><ul class="table-of-contents table-of-contents__left-border"><li><a href="#1mysql的基本架构" class="table-of-contents__link toc-highlight">1、MySQL的基本架构</a><ul><li><a href="#1mysql的基础架构图" class="table-of-contents__link toc-highlight">1）MySQL的基础架构图</a></li><li><a href="#2查询数据库的引擎" class="table-of-contents__link toc-highlight">2）查询数据库的引擎</a></li><li><a href="#3指定数据库对象的存储引擎" class="table-of-contents__link toc-highlight">3）指定数据库对象的存储引擎</a></li></ul></li><li><a href="#2sql优化" class="table-of-contents__link toc-highlight">2、SQL优化</a><ul><li><a href="#1为什么需要进行sql优化" class="table-of-contents__link toc-highlight">1）为什么需要进行SQL优化？</a></li><li><a href="#2mysql的编写过程和解析过程" class="table-of-contents__link toc-highlight">2）mysql的编写过程和解析过程</a></li><li><a href="#3sql优化主要就是优化索引" class="table-of-contents__link toc-highlight">3）SQL优化—主要就是优化索引</a></li><li><a href="#4索引的弊端" class="table-of-contents__link toc-highlight">4）索引的弊端</a></li><li><a href="#5索引的优势" class="table-of-contents__link toc-highlight">5）索引的优势</a></li><li><a href="#6b树图示说明" class="table-of-contents__link toc-highlight">6）B+树图示说明</a></li></ul></li><li><a href="#3索引的分类与创建" class="table-of-contents__link toc-highlight">3、索引的分类与创建</a><ul><li><a href="#1索引分类" class="table-of-contents__link toc-highlight">1）索引分类</a></li><li><a href="#2创建索引" class="table-of-contents__link toc-highlight">2）创建索引</a></li><li><a href="#3索引删除和索引查询" class="table-of-contents__link toc-highlight">3）索引删除和索引查询</a></li></ul></li><li><a href="#4sql性能问题的探索" class="table-of-contents__link toc-highlight">4、SQL性能问题的探索</a><ul><li><a href="#1查看执行计划" class="table-of-contents__link toc-highlight">1）查看执行计划</a></li><li><a href="#2执行计划中需要知道的几个关键字" class="table-of-contents__link toc-highlight">2）“执行计划”中需要知道的几个“关键字”</a></li><li><a href="#建表语句和插入数据" class="table-of-contents__link toc-highlight">建表语句和插入数据：</a></li></ul></li><li><a href="#5-explain执行计划常用关键字详解" class="table-of-contents__link toc-highlight">5. explain执行计划常用关键字详解</a><ul><li><a href="#1id关键字的使用说明" class="table-of-contents__link toc-highlight">1）id关键字的使用说明</a></li><li><a href="#2select_type关键字的使用说明查询类型" class="table-of-contents__link toc-highlight">2）select_type关键字的使用说明：查询类型</a></li><li><a href="#3type关键字的使用说明索引类型" class="table-of-contents__link toc-highlight">3）type关键字的使用说明：索引类型</a></li><li><a href="#4possible_keys和key" class="table-of-contents__link toc-highlight">4）possible_keys和key</a></li><li><a href="#5key_len" class="table-of-contents__link toc-highlight">5）key_len</a></li><li><a href="#6ref" class="table-of-contents__link toc-highlight">6）ref</a></li><li><a href="#7rows这个目前还是有点疑惑" class="table-of-contents__link toc-highlight">7）rows(这个目前还是有点疑惑)</a></li><li><a href="#8extra" class="table-of-contents__link toc-highlight">8）extra</a></li></ul></li><li><a href="#6优化示例" class="table-of-contents__link toc-highlight">6、优化示例</a><ul><li><a href="#1引入案例" class="table-of-contents__link toc-highlight">1）引入案例</a></li><li><a href="#2单表优化" class="table-of-contents__link toc-highlight">2）单表优化</a></li><li><a href="#3两表优化" class="table-of-contents__link toc-highlight">3）两表优化</a></li><li><a href="#4三表优化" class="table-of-contents__link toc-highlight">4）三表优化</a></li></ul></li><li><a href="#7避免索引失效的一些原则" class="table-of-contents__link toc-highlight">7、避免索引失效的一些原则</a><ul><li><a href="#-复合索引需要注意的点" class="table-of-contents__link toc-highlight">① 复合索引需要注意的点</a></li><li><a href="#-不要在索引上进行任何操作计算函数类型转换否则索引失效" class="table-of-contents__link toc-highlight">② 不要在索引上进行任何操作(计算、函数、类型转换)，否则索引失效</a></li><li><a href="#-索引不能使用不等于-或is-null-is-not-null否则自身以及右侧所有全部失效针对大多数情况复合索引中如果有则自身和右侧索引全部失效" class="table-of-contents__link toc-highlight">③ 索引不能使用不等于（<code>!=</code> <code>&lt;&gt;</code>）或<code>is null</code> (<code>is not null</code>)，否则自身以及右侧所有全部失效(针对大多数情况)。复合索引中如果有&gt;，则自身和右侧索引全部失效。</a></li><li><a href="#-sql优化是一种概率层面的优化至于是否实际使用了我们的优化需要通过explain进行推测" class="table-of-contents__link toc-highlight">④ SQL优化，是一种概率层面的优化。至于是否实际使用了我们的优化，需要通过explain进行推测。</a></li><li><a href="#-索引覆盖百分之百没问题" class="table-of-contents__link toc-highlight">⑤ 索引覆盖，百分之百没问题</a></li><li><a href="#-like尽量以常量开头不要以开头否则索引失效" class="table-of-contents__link toc-highlight">⑥ like尽量以“常量”开头，不要以’%&#39;开头，否则索引失效</a></li><li><a href="#-尽量不要使用类型转换显示隐式否则索引失效" class="table-of-contents__link toc-highlight">⑦ 尽量不要使用类型转换（显示、隐式），否则索引失效</a></li><li><a href="#-尽量不要使用or否则索引失效" class="table-of-contents__link toc-highlight">⑧ 尽量不要使用or，否则索引失效</a></li></ul></li><li><a href="#8一些其他的优化方法" class="table-of-contents__link toc-highlight">8、一些其他的优化方法</a><ul><li><a href="#1exists和in的优化" class="table-of-contents__link toc-highlight">1）exists和in的优化</a></li><li><a href="#2order-by优化" class="table-of-contents__link toc-highlight">2）order by优化</a></li></ul></li></ul></div></div></div></div></main></div></div></div><footer class="footer footer--dark"><div class="container container-fluid"><div class="row footer__links"><div class="col footer__col"><div class="footer__title">Docs</div><ul class="footer__items clean-list"><li class="footer__item"><a class="footer__link-item" href="/light-docusaurus/docs/category/guide/">Torch</a></li><li class="footer__item"><a class="footer__link-item" href="/light-docusaurus/middleware/">Middleware</a></li><li class="footer__item"><a class="footer__link-item" href="/light-docusaurus/electron/">Electron</a></li></ul></div><div class="col footer__col"><div class="footer__title">Community</div><ul class="footer__items clean-list"><li class="footer__item"><a href="https://stackoverflow.com/questions/tagged/lorchr" target="_blank" rel="noopener noreferrer" class="footer__link-item">Stack Overflow<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li><li class="footer__item"><a href="https://discordapp.com/invite/lorchr" target="_blank" rel="noopener noreferrer" class="footer__link-item">Discord<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li><li class="footer__item"><a href="https://twitter.com/lorchr" target="_blank" rel="noopener noreferrer" class="footer__link-item">Twitter<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li></ul></div><div class="col footer__col"><div class="footer__title">More</div><ul class="footer__items clean-list"><li class="footer__item"><a class="footer__link-item" href="/light-docusaurus/blog/">Blog</a></li><li class="footer__item"><a class="footer__link-item" href="/light-docusaurus/diy/">DIY</a></li><li class="footer__item"><a href="https://github.com/lorchr/light-docusaurus" target="_blank" rel="noopener noreferrer" class="footer__link-item">GitHub<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li></ul></div><div class="col footer__col"><div class="footer__title">Offical</div><ul class="footer__items clean-list"><li class="footer__item"><a href="https://docusaurus.io" target="_blank" rel="noopener noreferrer" class="footer__link-item">Home<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li><li class="footer__item"><a href="https://github.com/facebook/docusaurus" target="_blank" rel="noopener noreferrer" class="footer__link-item">Github<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li><li class="footer__item"><a href="https://docusaurus.io/docs/playground" target="_blank" rel="noopener noreferrer" class="footer__link-item">Playground<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li></ul></div></div><div class="footer__bottom text--center"><div class="footer__copyright">Copyright © 2024 Light-Docusaurus, Inc. Built with Docusaurus.</div></div></div></footer></div>
</body>
</html>