<!doctype html>
<html lang="zh-Hans" dir="ltr" class="docs-wrapper plugin-docs plugin-id-default docs-version-current docs-doc-page docs-doc-id-zh-cn/spring-authorization-server/SAS-Frontend-Backend-Separate" data-has-hydrated="false">
<head>
<meta charset="UTF-8">
<meta name="generator" content="Docusaurus v3.0.1">
<title data-rh="true">SAS-Frontend-Backend-Separate | Light Docusaurus</title><meta data-rh="true" name="viewport" content="width=device-width,initial-scale=1"><meta data-rh="true" name="twitter:card" content="summary_large_image"><meta data-rh="true" property="og:image" content="https://lorchr.github.io/light-docusaurus/img/docusaurus-social-card.jpg"><meta data-rh="true" name="twitter:image" content="https://lorchr.github.io/light-docusaurus/img/docusaurus-social-card.jpg"><meta data-rh="true" property="og:url" content="https://lorchr.github.io/light-docusaurus/docs/zh-cn/spring-authorization-server/SAS-Frontend-Backend-Separate/"><meta data-rh="true" property="og:locale" content="zh_Hans"><meta data-rh="true" name="docusaurus_locale" content="zh-Hans"><meta data-rh="true" name="docsearch:language" content="zh-Hans"><meta data-rh="true" name="docusaurus_version" content="current"><meta data-rh="true" name="docusaurus_tag" content="docs-default-current"><meta data-rh="true" name="docsearch:version" content="current"><meta data-rh="true" name="docsearch:docusaurus_tag" content="docs-default-current"><meta data-rh="true" property="og:title" content="SAS-Frontend-Backend-Separate | Light Docusaurus"><meta data-rh="true" name="description" content="- Spring Authorization Server入门 (十二) 实现授权码模式使用前后端分离的登录页面"><meta data-rh="true" property="og:description" content="- Spring Authorization Server入门 (十二) 实现授权码模式使用前后端分离的登录页面"><link data-rh="true" rel="icon" href="/light-docusaurus/img/favicon.ico"><link data-rh="true" rel="canonical" href="https://lorchr.github.io/light-docusaurus/docs/zh-cn/spring-authorization-server/SAS-Frontend-Backend-Separate/"><link data-rh="true" rel="alternate" href="https://lorchr.github.io/light-docusaurus/docs/zh-cn/spring-authorization-server/SAS-Frontend-Backend-Separate/" hreflang="zh-Hans"><link data-rh="true" rel="alternate" href="https://lorchr.github.io/light-docusaurus/docs/zh-cn/spring-authorization-server/SAS-Frontend-Backend-Separate/" hreflang="x-default"><link data-rh="true" rel="preconnect" href="https://TLGHDZ3Y2I-dsn.algolia.net" crossorigin="anonymous"><link rel="alternate" type="application/rss+xml" href="/light-docusaurus/blog/rss.xml" title="Light Docusaurus RSS Feed">
<link rel="alternate" type="application/atom+xml" href="/light-docusaurus/blog/atom.xml" title="Light Docusaurus Atom Feed">



<link rel="search" type="application/opensearchdescription+xml" title="Light Docusaurus" href="/light-docusaurus/opensearch.xml"><link rel="stylesheet" href="/light-docusaurus/assets/css/styles.609e5209.css">
<script src="/light-docusaurus/assets/js/runtime~main.8c0ff940.js" defer="defer"></script>
<script src="/light-docusaurus/assets/js/main.898faf32.js" defer="defer"></script>
</head>
<body class="navigation-with-keyboard">
<script>!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){try{return new URLSearchParams(window.location.search).get("docusaurus-theme")}catch(t){}}()||function(){try{return localStorage.getItem("theme")}catch(t){}}();t(null!==e?e:"light")}(),function(){try{const c=new URLSearchParams(window.location.search).entries();for(var[t,e]of c)if(t.startsWith("docusaurus-data-")){var a=t.replace("docusaurus-data-","data-");document.documentElement.setAttribute(a,e)}}catch(t){}}()</script><div id="__docusaurus"><div role="region" aria-label="跳到主要内容"><a class="skipToContent_fXgn" href="#__docusaurus_skipToContent_fallback">跳到主要内容</a></div><nav aria-label="主导航" class="navbar navbar--fixed-top"><div class="navbar__inner"><div class="navbar__items"><button aria-label="切换导航栏" aria-expanded="false" class="navbar__toggle clean-btn" type="button"><svg width="30" height="30" viewBox="0 0 30 30" aria-hidden="true"><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><a class="navbar__brand" href="/light-docusaurus/"><div class="navbar__logo"><img src="/light-docusaurus/img/logo.svg" alt="Torch Logo" class="themedComponent_mlkZ themedComponent--light_NVdE"><img src="/light-docusaurus/img/logo.svg" alt="Torch Logo" class="themedComponent_mlkZ themedComponent--dark_xIcU"></div><b class="navbar__title text--truncate">Torch</b></a><a aria-current="page" class="navbar__item navbar__link navbar__link--active" href="/light-docusaurus/docs/category/guide/">Torch</a><a class="navbar__item navbar__link" href="/light-docusaurus/blog/">Blog</a><a class="navbar__item navbar__link" href="/light-docusaurus/middleware/">Middleware</a><a class="navbar__item navbar__link" href="/light-docusaurus/electron/">Electron</a><a class="navbar__item navbar__link" href="/light-docusaurus/postman/">Postman</a><a class="navbar__item navbar__link" href="/light-docusaurus/diy/">DIY</a></div><div class="navbar__items navbar__items--right"><div class="navbar__item dropdown dropdown--hoverable dropdown--right"><a href="#" aria-haspopup="true" aria-expanded="false" role="button" class="navbar__link"><svg viewBox="0 0 24 24" width="20" height="20" aria-hidden="true" class="iconLanguage_nlXk"><path fill="currentColor" d="M12.87 15.07l-2.54-2.51.03-.03c1.74-1.94 2.98-4.17 3.71-6.53H17V4h-7V2H8v2H1v1.99h11.17C11.5 7.92 10.44 9.75 9 11.35 8.07 10.32 7.3 9.19 6.69 8h-2c.73 1.63 1.73 3.17 2.98 4.56l-5.09 5.02L4 19l5-5 3.11 3.11.76-2.04zM18.5 10h-2L12 22h2l1.12-3h4.75L21 22h2l-4.5-12zm-2.62 7l1.62-4.33L19.12 17h-3.24z"></path></svg>简体中文</a><ul class="dropdown__menu"><li><a href="/light-docusaurus/docs/zh-cn/spring-authorization-server/SAS-Frontend-Backend-Separate/" target="_self" rel="noopener noreferrer" class="dropdown__link dropdown__link--active" lang="zh-Hans">简体中文</a></li></ul></div><a href="https://github.com/lorchr/light-docusaurus" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link">GitHub<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a><div class="toggle_vylO colorModeToggle_DEke"><button class="clean-btn toggleButton_gllP toggleButtonDisabled_aARS" type="button" disabled="" title="切换浅色/暗黑模式（当前为浅色模式）" aria-label="切换浅色/暗黑模式（当前为浅色模式）" aria-live="polite"><svg viewBox="0 0 24 24" width="24" height="24" class="lightToggleIcon_pyhR"><path fill="currentColor" d="M12,9c1.65,0,3,1.35,3,3s-1.35,3-3,3s-3-1.35-3-3S10.35,9,12,9 M12,7c-2.76,0-5,2.24-5,5s2.24,5,5,5s5-2.24,5-5 S14.76,7,12,7L12,7z M2,13l2,0c0.55,0,1-0.45,1-1s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S1.45,13,2,13z M20,13l2,0c0.55,0,1-0.45,1-1 s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S19.45,13,20,13z M11,2v2c0,0.55,0.45,1,1,1s1-0.45,1-1V2c0-0.55-0.45-1-1-1S11,1.45,11,2z M11,20v2c0,0.55,0.45,1,1,1s1-0.45,1-1v-2c0-0.55-0.45-1-1-1C11.45,19,11,19.45,11,20z M5.99,4.58c-0.39-0.39-1.03-0.39-1.41,0 c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0s0.39-1.03,0-1.41L5.99,4.58z M18.36,16.95 c-0.39-0.39-1.03-0.39-1.41,0c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0c0.39-0.39,0.39-1.03,0-1.41 L18.36,16.95z M19.42,5.99c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06c-0.39,0.39-0.39,1.03,0,1.41 s1.03,0.39,1.41,0L19.42,5.99z M7.05,18.36c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06 c-0.39,0.39-0.39,1.03,0,1.41s1.03,0.39,1.41,0L7.05,18.36z"></path></svg><svg viewBox="0 0 24 24" width="24" height="24" class="darkToggleIcon_wfgR"><path fill="currentColor" d="M9.37,5.51C9.19,6.15,9.1,6.82,9.1,7.5c0,4.08,3.32,7.4,7.4,7.4c0.68,0,1.35-0.09,1.99-0.27C17.45,17.19,14.93,19,12,19 c-3.86,0-7-3.14-7-7C5,9.07,6.81,6.55,9.37,5.51z M12,3c-4.97,0-9,4.03-9,9s4.03,9,9,9s9-4.03,9-9c0-0.46-0.04-0.92-0.1-1.36 c-0.98,1.37-2.58,2.26-4.4,2.26c-2.98,0-5.4-2.42-5.4-5.4c0-1.81,0.89-3.42,2.26-4.4C12.92,3.04,12.46,3,12,3L12,3z"></path></svg></button></div><div class="navbarSearchContainer_Bca1"><button type="button" class="DocSearch DocSearch-Button" aria-label="搜索"><span class="DocSearch-Button-Container"><svg width="20" height="20" class="DocSearch-Search-Icon" viewBox="0 0 20 20"><path d="M14.386 14.386l4.0877 4.0877-4.0877-4.0877c-2.9418 2.9419-7.7115 2.9419-10.6533 0-2.9419-2.9418-2.9419-7.7115 0-10.6533 2.9418-2.9419 7.7115-2.9419 10.6533 0 2.9419 2.9418 2.9419 7.7115 0 10.6533z" stroke="currentColor" fill="none" fill-rule="evenodd" stroke-linecap="round" stroke-linejoin="round"></path></svg><span class="DocSearch-Button-Placeholder">搜索</span></span><span class="DocSearch-Button-Keys"></span></button></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div></nav><div id="__docusaurus_skipToContent_fallback" class="main-wrapper mainWrapper_z2l0"><div class="docsWrapper_hBAB"><button aria-label="回到顶部" class="clean-btn theme-back-to-top-button backToTopButton_sjWU" type="button"></button><div class="docRoot_UBD9"><aside class="theme-doc-sidebar-container docSidebarContainer_YfHR"><div class="sidebarViewport_aRkj"><div class="sidebar_njMd"><nav aria-label="文档侧边栏" class="menu thin-scrollbar menu_SIkG"><ul class="theme-doc-sidebar-menu menu__list"><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" aria-expanded="false" href="/light-docusaurus/docs/category/guide/">Guide</a><button aria-label="展开侧边栏分类 &#x27;Guide&#x27;" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" aria-expanded="false" href="/light-docusaurus/docs/category/develop-environment/">Develop Environment</a><button aria-label="展开侧边栏分类 &#x27;Develop Environment&#x27;" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" aria-expanded="false" href="/light-docusaurus/docs/category/java-jvm/">Java (JVM)</a><button aria-label="展开侧边栏分类 &#x27;Java (JVM)&#x27;" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" aria-expanded="false" href="/light-docusaurus/docs/category/spring-boot/">Spring Boot</a><button aria-label="展开侧边栏分类 &#x27;Spring Boot&#x27;" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" aria-expanded="false" href="/light-docusaurus/docs/category/spring-cloud/">Spring Cloud</a><button aria-label="展开侧边栏分类 &#x27;Spring Cloud&#x27;" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" aria-expanded="false" href="/light-docusaurus/docs/category/spring-security/">Spring Security</a><button aria-label="展开侧边栏分类 &#x27;Spring Security&#x27;" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--active" aria-expanded="true" href="/light-docusaurus/docs/category/spring-authorization-server/">Spring Authorization Server</a><button aria-label="折叠侧边栏分类 &#x27;Spring Authorization Server&#x27;" type="button" class="clean-btn menu__caret"></button></div><ul style="display:block;overflow:visible;height:auto" class="menu__list"><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/light-docusaurus/docs/zh-cn/spring-authorization-server/SAS-Geting-Start-Index/">SAS-Geting-Start-Index</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/light-docusaurus/docs/zh-cn/spring-authorization-server/SAS-OAuth2.1-Protocol/">SAS-OAuth2.1-Protocol</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/light-docusaurus/docs/zh-cn/spring-authorization-server/SAS-Spring-Boot-Authorization-Server/">SAS-Spring-Boot-Authorization-Server</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/light-docusaurus/docs/zh-cn/spring-authorization-server/SAS-Spring-Boot-Authorization-Server-Addition/">SAS-Spring-Boot-Authorization-Server-Addition</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/light-docusaurus/docs/zh-cn/spring-authorization-server/SAS-Device-Authorization/">SAS-Device-Authorization</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/light-docusaurus/docs/zh-cn/spring-authorization-server/SAS-Customize-Exception-Configurer/">SAS-Customize-Exception-Configurer</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/light-docusaurus/docs/zh-cn/spring-authorization-server/SAS-Token-Enhancer-And-Parser/">SAS-Token-Enhancer-And-Parser</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/light-docusaurus/docs/zh-cn/spring-authorization-server/SAS-Image-Captcha/">SAS-Image-Captcha</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/light-docusaurus/docs/zh-cn/spring-authorization-server/SAS-OAuth2-Client/">SAS-OAuth2-Client</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/light-docusaurus/docs/zh-cn/spring-authorization-server/SAS-OAuth2-Resource-Server/">SAS-OAuth2-Resource-Server</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/light-docusaurus/docs/zh-cn/spring-authorization-server/SAS-SMS-Code-Login/">SAS-SMS-Code-Login</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/light-docusaurus/docs/zh-cn/spring-authorization-server/SAS-OAuth2-Extension-Grant-Type/">SAS-OAuth2-Extension-Grant-Type</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link menu__link--active" aria-current="page" tabindex="0" href="/light-docusaurus/docs/zh-cn/spring-authorization-server/SAS-Frontend-Backend-Separate/">SAS-Frontend-Backend-Separate</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/light-docusaurus/docs/zh-cn/spring-authorization-server/SAS-Github-Gitee-Login/">SAS-Github-Gitee-Login</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/light-docusaurus/docs/zh-cn/spring-authorization-server/SAS-Wechat-Login/">SAS-Wechat-Login</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/light-docusaurus/docs/zh-cn/spring-authorization-server/SAS-Separate-Consent-And-Device-Authorize-Page/">SAS-Separate-Consent-And-Device-Authorize-Page</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/light-docusaurus/docs/zh-cn/spring-authorization-server/SAS-Spring-Cloud-Gateway/">SAS-Spring-Cloud-Gateway</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/light-docusaurus/docs/zh-cn/spring-authorization-server/SAS-Vue-Authorization-Code/">SAS-Vue-Authorization-Code</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/light-docusaurus/docs/zh-cn/spring-authorization-server/SAS-Vue-PKCE/">SAS-Vue-PKCE</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/light-docusaurus/docs/zh-cn/spring-authorization-server/SAS-Redis-Core-Service/">SAS-Redis-Core-Service</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/light-docusaurus/docs/zh-cn/spring-authorization-server/SAS-QrCode-Login/">SAS-QrCode-Login</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/light-docusaurus/docs/zh-cn/spring-authorization-server/SAS-Optimize-Customlize-UserDetailService/">SAS-Optimize-Customlize-UserDetailService</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/light-docusaurus/docs/zh-cn/spring-authorization-server/SAS-Optimize-Add-Redis-Cache/">SAS-Optimize-Add-Redis-Cache</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/light-docusaurus/docs/zh-cn/spring-authorization-server/SAS-Optimize-Persistance-JWKSource/">SAS-Optimize-Persistance-JWKSource</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/light-docusaurus/docs/zh-cn/spring-authorization-server/SAS-Optimize-Redis-Serializer-Add-Jackson-Mixin/">SAS-Optimize-Redis-Serializer-Add-Jackson-Mixin</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/light-docusaurus/docs/zh-cn/spring-authorization-server/SAS-FAQ/">SAS-FAQ</a></li></ul></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" aria-expanded="false" href="/light-docusaurus/docs/category/active-directory/">Active Directory</a><button aria-label="展开侧边栏分类 &#x27;Active Directory&#x27;" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" aria-expanded="false" href="/light-docusaurus/docs/category/database/">Database</a><button aria-label="展开侧边栏分类 &#x27;Database&#x27;" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" aria-expanded="false" href="/light-docusaurus/docs/category/git/">Git</a><button aria-label="展开侧边栏分类 &#x27;Git&#x27;" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" aria-expanded="false" href="/light-docusaurus/docs/category/linux/">Linux</a><button aria-label="展开侧边栏分类 &#x27;Linux&#x27;" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" aria-expanded="false" href="/light-docusaurus/docs/category/docker/">Docker</a><button aria-label="展开侧边栏分类 &#x27;Docker&#x27;" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" aria-expanded="false" href="/light-docusaurus/docs/category/kubernetes/">Kubernetes</a><button aria-label="展开侧边栏分类 &#x27;Kubernetes&#x27;" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" aria-expanded="false" href="/light-docusaurus/docs/category/test/">Test</a><button aria-label="展开侧边栏分类 &#x27;Test&#x27;" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" aria-expanded="false" href="/light-docusaurus/docs/category/others/">Others</a><button aria-label="展开侧边栏分类 &#x27;Others&#x27;" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/light-docusaurus/docs/zh-cn/awesome-open-source/">Awesome open source</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/light-docusaurus/docs/zh-cn/windows/">Windows</a></li></ul></nav><button type="button" title="收起侧边栏" aria-label="收起侧边栏" class="button button--secondary button--outline collapseSidebarButton_PEFL"><svg width="20" height="20" aria-hidden="true" class="collapseSidebarButtonIcon_kv0_"><g fill="#7a7a7a"><path d="M9.992 10.023c0 .2-.062.399-.172.547l-4.996 7.492a.982.982 0 01-.828.454H1c-.55 0-1-.453-1-1 0-.2.059-.403.168-.551l4.629-6.942L.168 3.078A.939.939 0 010 2.528c0-.548.45-.997 1-.997h2.996c.352 0 .649.18.828.45L9.82 9.472c.11.148.172.347.172.55zm0 0"></path><path d="M19.98 10.023c0 .2-.058.399-.168.547l-4.996 7.492a.987.987 0 01-.828.454h-3c-.547 0-.996-.453-.996-1 0-.2.059-.403.168-.551l4.625-6.942-4.625-6.945a.939.939 0 01-.168-.55 1 1 0 01.996-.997h3c.348 0 .649.18.828.45l4.996 7.492c.11.148.168.347.168.55zm0 0"></path></g></svg></button></div></div></aside><main class="docMainContainer_TBSr"><div class="container padding-top--md padding-bottom--lg"><div class="row"><div class="col docItemCol_VOVn"><div class="docItemContainer_Djhp"><article><nav class="theme-doc-breadcrumbs breadcrumbsContainer_Z_bl" aria-label="页面路径"><ul class="breadcrumbs" itemscope="" itemtype="https://schema.org/BreadcrumbList"><li class="breadcrumbs__item"><a aria-label="主页面" class="breadcrumbs__link" href="/light-docusaurus/"><svg viewBox="0 0 24 24" class="breadcrumbHomeIcon_YNFT"><path d="M10 19v-5h4v5c0 .55.45 1 1 1h3c.55 0 1-.45 1-1v-7h1.7c.46 0 .68-.57.33-.87L12.67 3.6c-.38-.34-.96-.34-1.34 0l-8.36 7.53c-.34.3-.13.87.33.87H5v7c0 .55.45 1 1 1h3c.55 0 1-.45 1-1z" fill="currentColor"></path></svg></a></li><li itemscope="" itemprop="itemListElement" itemtype="https://schema.org/ListItem" class="breadcrumbs__item"><a class="breadcrumbs__link" itemprop="item" href="/light-docusaurus/docs/category/spring-authorization-server/"><span itemprop="name">Spring Authorization Server</span></a><meta itemprop="position" content="1"></li><li itemscope="" itemprop="itemListElement" itemtype="https://schema.org/ListItem" class="breadcrumbs__item breadcrumbs__item--active"><span class="breadcrumbs__link" itemprop="name">SAS-Frontend-Backend-Separate</span><meta itemprop="position" content="2"></li></ul></nav><div class="tocCollapsible_ETCw theme-doc-toc-mobile tocMobile_ITEo"><button type="button" class="clean-btn tocCollapsibleButton_TO0P">本页总览</button></div><div class="theme-doc-markdown markdown"><header><h1>SAS-Frontend-Backend-Separate</h1></header><ul>
<li><a href="https://juejin.cn/post/7254096495184134181">Spring Authorization Server入门 (十二) 实现授权码模式使用前后端分离的登录页面</a></li>
</ul>
<blockquote>
<p>2023-12-01修改：在<a href="https://gitee.com/vains-Sofia/authorization-example/tree/session-data-redis">session-data-redis(Github)</a>分支中添加了基于<code>spring-session-data-redis</code>的实现，无需借助<code>nonceId</code>来保持认证状态，该分支已去除所有<code>nonceId</code>相关内容，需要注意的是<code>axios</code>在初始化时需要添加配置<code>withCredentials: true</code>，让请求携带<code>cookie</code>。当然一些 响应json的处理还是使用下方的内容。</p>
</blockquote>
<p>今天的主题就是使用单独部署的登录页面替换认证服务器默认的登录页面(前后端分离时使用前端的登录页面)，目前在网上能搜到的很多都是理论，没有很好的一个示例，我就按照我自己的想法写了一个实现，给大家提供一个思路，如果有什么问题或者更好的想法可以在评论区提出，谢谢。</p>
<h2 id="一实现思路分析">一、实现思路分析</h2>
<h3 id="1-先看一下在默认情况下请求在框架中的跳转情况">1. 先看一下在默认情况下请求在框架中的跳转情况</h3>
<p><img alt="img" src="/light-docusaurus/assets/images/12-1-4aebd7521e20b2dbb7b1c49937273d1e.awebp" width="1157" height="706"></p>
<p>    Spring Authorization Server(Spring Security)框架默认使用session存储用户的认证信息，这样在登录以后重定向回请求授权接口时(<code>/oauth2/authorize</code>)处理该请求的过滤器可以从<code>session</code>中获取到认证信息，从而走后边的流程，但是当这一套放在单独部署的登录页面中就不行了，在请求授权时哪怕登录过也无法获取到认证信息，因为他们不再是同一个<code>session</code>中了；所以关键点就在于怎么存储、获取认证信息。</p>
<h3 id="2-先查看下框架怎么获取认证信息">2. 先查看下框架怎么获取认证信息</h3>
<p>    在处理<code>/oauth2/authorize</code>接口的过滤器<code>OAuth2AuthorizationEndpointFilter</code>中看一下实现逻辑，看一下对于认证信息的处理，如下图</p>
<p><img alt="img" src="/light-docusaurus/assets/images/12-2-80a6b8526915d22d57fd7cf59292e3e8.awebp" width="1444" height="933"></p>
<p>先由<code>converter</code>处理，之后再由<code>provider</code>处理，之后判断认证信息是否已经认证过了，没认证过不处理，交给后边的过滤器处理，接下来看一下<code>converter</code>中的逻辑，如下  图所示</p>
<p><img alt="img" src="/light-docusaurus/assets/images/12-3-80118904c86cb72301a836629caf0f14.awebp" width="1472" height="929"></p>
<p>    如图所示，这里直接从<code>SecurityContextHolder</code>中获取的认证信息，那么接下来就需要找一下它是怎么获取认证信息并放入<code>SecurityContextHolder</code>中的。
在<code>OAuth2AuthorizationEndpointFilter</code>中打一个断点，请求一下<code>/oauth2/authorize</code>接口，</p>
<p><img alt="img" src="/light-docusaurus/assets/images/12-4-2153d20709aeaa8392926bac50eadc2d.awebp" width="1361" height="942"></p>
<p>断点断住以后查看一下过滤器链，发现在<code>OAuth2AuthorizationEndpointFilter</code>之前有一个<code>SecurityContextHolderFilter</code>过滤器，名字表达的特征很明显，接下来看一下这个过滤器中的逻辑。</p>
<p><img alt="img" src="/light-docusaurus/assets/images/12-5-b49072259a2d6ab774cec623d820d7b8.awebp" width="1490" height="967"></p>
<p>从断点截图中可以看出是从<code>securityContextRepository</code>中获取的认证信息，然后通过<code>securityContextHolderStrategy</code>保存，看一下是不是在这里设置的认证信息。</p>
<p><img alt="img" src="/light-docusaurus/assets/images/12-6-a4322cdaf0dd190bfe83a2e0e71e3dc2.awebp" width="966" height="487"></p>
<p>断点进入方法后发现将认证信息的<code>context</code>设置到了<code>contextHolder</code>中，那这里和<code>SecurityContextHolder</code>是同一个东西吗？请接着往下看</p>
<p><img alt="img" src="/light-docusaurus/assets/images/12-7-26c224b8cb63e84980282c20a832d4cb.awebp" width="1125" height="369"></p>
<p><code>SecurityContextHolder</code>的<code>getContext</code>方法是从当前类中的属性获取，接下来看一下<code>securityContextHolderStrategy</code>的定义</p>
<p><img alt="img" src="/light-docusaurus/assets/images/12-8-4b2ee3d0fdeb24faeed0e64be6a72947.awebp" width="1318" height="578"></p>
<p>它是通过调用<code>SecurityContextHolder</code>的<code>getContextHolderStrategy</code>方法完成实例化的，看下这个方法</p>
<p><img alt="img" src="/light-docusaurus/assets/images/12-9-6436dc8f6613cabc68c3271eeb40f316.awebp" width="1133" height="385"></p>
<p>    追踪到这里应该就差不多了，框架从<code>securityContextRepository</code>中获取认证信息，然后通过<code>securityContextHolderStrategy</code>放入<code>SecurityContextHolder</code>中，让后边的过滤器可以直接从<code>SecurityContextHolder</code>中获取认证信息。</p>
<p>获取认证信息的地方结束了，接下来看一下存储认证信息的地方，分析完获取的地方，存储的地方就很简单了。</p>
<h3 id="3-存储认证信息">3. 存储认证信息</h3>
<p>    看过之前文章或者其它关于登录分析的文章应该知道，框架对于登录的处理是基于<code>UsernamePasswordAuthenticationFilter</code>和父类<code>AbstractAuthenticationProcessingFilter</code>，在父类中调用子类的校验，重点是认证成功后的处理，如下图</p>
<p><img alt="img" src="/light-docusaurus/assets/images/12-10-f4784770753a6fe834798295d7e5c95f.awebp" width="1454" height="927"></p>
<p>认证成功后调用了<code>successfulAuthentication</code>方法，看一下该方法的实现</p>
<p><img alt="img" src="/light-docusaurus/assets/images/12-11-fb59640cc3f05dbf6a41441052f2e221.awebp" width="1454" height="900"></p>
<p>    其它的不是本篇文章的重点，主要是红框中的代码，这里将登陆后的认证信息存储在<code>securityContextRepository</code>中。</p>
<p>    到这里逻辑就通了，登录后将认证信息存储在<code>securityContextRepository</code>中，访问时从<code>securityContextRepository</code>中取出认证信息并放在<code>SecurityContextHolder</code>中，这样就保持了登陆状态。</p>
<h2 id="二改造分析">二、改造分析</h2>
<p>    使用前后端分离的登录页面，那么登录接口就需要响应json了， 不能再使用默认的成功/失败处理了，所以要重写登录成功和失败的处理器；重定向也不能由认证服务来重定向了，应该由前端重定向；存储认证信息的容器也不能以<code>session</code>为主了，使用redis来替换<code>session</code>。</p>
<p>     <del>使用redis后没有<code>session</code>了，也就不能确定请求是哪一个，本人拙见是在登录时携带一个唯一字符串，请求成功后前端重定向至需要认证的请求时携带该唯一字符串，这样请求时可以根据这个唯一字符串获取到认证信息。</del></p>
<blockquote>
<p>2023-07-11修改：只要用户在浏览器中访问认证服务就会生成一个<code>session</code>，所以当请求授权时或者访问其它需要登录的接口时，通过未登录处理重定向至登录页面时获取当前请求的<code>sessionId</code>，放入重定向地址的参数中；浏览器中在登录页面输入账号密码提交时携带地址栏中的<code>sessionId</code>；存取认证信息时获取<code>sessionId</code>的顺序为：请求头 ---&gt;&gt;&gt; 请求参数 ---&gt;&gt;&gt; 当前<code>session</code>；这样一来就可以通过<code>session</code>将认证服务和单独部署的登录页面中的请求串联起来了，详细实现请看下方代码</p>
</blockquote>
<p>主要就是重定向时将当前请求放入<code>target</code>参数中，当前<code>sessionId</code>放入<code>nonceId</code>参数中</p>
<blockquote>
<p>2023-07-21修改内容：oauth协议中有<code>nonce</code>参数，为防止冲突，<code>nonce</code>参数改为<code>nonceId</code></p>
</blockquote>
<p>思路清晰以后编码就很快了</p>
<ul>
<li>重写登录成功处理(响应json)。</li>
<li>重写登录失败处理(响应json)。</li>
<li>重写未登录处理，重定向到登录页面时携带当前请求url。</li>
<li>重写认证信息存取逻辑，使用redis存储认证信息。</li>
<li>将以上内容添加到Spring Authorization Server配 置中，使其在过滤器链中生效</li>
<li>前端代码编写，按照要求传递唯一字符串并在登录成功后重定向至参数中携带的地址</li>
</ul>
<h2 id="三代码实现">三、代码实现</h2>
<h3 id="1-创建loginsuccesshandler类并实现authenticationsuccesshandler接口">1. 创建<code>LoginSuccessHandler</code>类并实现<code>AuthenticationSuccessHandler</code>接口</h3>
<pre><code class="language-java">package com.example.authorization.handler;  
  
import com.example.model.Result;  
import com.example.util.JsonUtils;  
import jakarta.servlet.http.HttpServletRequest;  
import jakarta.servlet.http.HttpServletResponse;  
import org.springframework.http.MediaType;  
import org.springframework.security.core.Authentication;  
import org.springframework.security.web.authentication.AuthenticationSuccessHandler;  
  
import java.io.IOException;  
import java.nio.charset.StandardCharsets;  
  
/**  
* 登录成功处理类  
*  
* @author vains  
*/  
public class LoginSuccessHandler implements AuthenticationSuccessHandler {  
  
    @Override  
    public void onAuthenticationSuccess(HttpServletRequest request, HttpServletResponse response, Authentication authentication) throws IOException {  
        Result&lt;String&gt; success = Result.success();  
        response.setCharacterEncoding(StandardCharsets.UTF_8.name());  
        response.setContentType(MediaType.APPLICATION_JSON_VALUE);  
        response.getWriter().write(JsonUtils.objectCovertToJson(success));  
        response.getWriter().flush();  
    }  
  
}
</code></pre>
<h3 id="2-创建loginfailurehandler类并实现authenticationfailurehandler接口">2. 创建<code>LoginFailureHandler</code>类并实现<code>AuthenticationFailureHandler</code>接口</h3>
<pre><code class="language-java">package com.example.authorization.handler;  
  
import com.example.model.Result;  
import com.example.util.JsonUtils;  
import jakarta.servlet.http.HttpServletRequest;  
import jakarta.servlet.http.HttpServletResponse;  
import org.springframework.http.HttpStatus;  
import org.springframework.http.MediaType;  
import org.springframework.security.core.AuthenticationException;  
import org.springframework.security.web.authentication.AuthenticationFailureHandler;  
  
import java.io.IOException;  
import java.nio.charset.StandardCharsets;  
  
/**  
* 登录失败处理类  
*  
* @author vains  
*/  
public class LoginFailureHandler implements AuthenticationFailureHandler {  
  
    @Override  
    public void onAuthenticationFailure(HttpServletRequest request, HttpServletResponse response, AuthenticationException exception) throws IOException {  
        // 登录失败，写回401与具体的异常  
        Result&lt;String&gt; success = Result.error(HttpStatus.UNAUTHORIZED.value(), exception.getMessage());  
        response.setCharacterEncoding(StandardCharsets.UTF_8.name());  
        response.setContentType(MediaType.APPLICATION_JSON_VALUE);  
        response.getWriter().write(JsonUtils.objectCovertToJson(success));  
        response.getWriter().flush();  
    }  
  
}
</code></pre>
<h3 id="3-创建logintargetauthenticationentrypoint类并继承loginurlauthenticationentrypoint类">3. 创建<code>LoginTargetAuthenticationEntryPoint</code>类并继承<code>LoginUrlAuthenticationEntryPoint</code>类</h3>
<blockquote>
<p>2023-07-11添加逻辑：重定向地址添加<code>nonce</code>参数，该参数的值为<code>sessionId</code>，详情请查看代码</p>
</blockquote>
<pre><code class="language-java">package com.example.authorization.handler;

import com.example.constant.SecurityConstants;
import jakarta.servlet.ServletException;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import lombok.extern.slf4j.Slf4j;
import org.springframework.security.core.AuthenticationException;
import org.springframework.security.web.DefaultRedirectStrategy;
import org.springframework.security.web.RedirectStrategy;
import org.springframework.security.web.authentication.LoginUrlAuthenticationEntryPoint;
import org.springframework.security.web.util.UrlUtils;
import org.springframework.util.ObjectUtils;

import java.io.IOException;
import java.net.URLEncoder;
import java.nio.charset.StandardCharsets;

/**
 * 重定向至登录处理
 *
 * @author vains
 */
@Slf4j
public class LoginTargetAuthenticationEntryPoint extends LoginUrlAuthenticationEntryPoint {

    private final RedirectStrategy redirectStrategy = new DefaultRedirectStrategy();

    /**
     * @param loginFormUrl URL where the login page can be found. Should either be
     *                     relative to the web-app context path (include a leading {@code /}) or an absolute
     *                     URL.
     */
    public LoginTargetAuthenticationEntryPoint(String loginFormUrl) {
        super(loginFormUrl);
    }

    @Override
    public void commence(HttpServletRequest request, HttpServletResponse response, AuthenticationException authException) throws IOException, ServletException {

        // 获取登录表单的地址
        String loginForm = determineUrlToUseForThisRequest(request, response, authException);
        if (!UrlUtils.isAbsoluteUrl(loginForm)) {
            // 不是绝对路径调用父类方法处理
            super.commence(request, response, authException);
            return;
        }

        StringBuffer requestUrl = request.getRequestURL();
        if (!ObjectUtils.isEmpty(request.getQueryString())) {
            requestUrl.append(&quot;?&quot;).append(request.getQueryString());
        }

        // 2023-07-11添加逻辑：重定向地址添加nonce参数，该参数的值为sessionId
        // 绝对路径在重定向前添加target参数
        String targetParameter = URLEncoder.encode(requestUrl.toString(), StandardCharsets.UTF_8);
        String targetUrl = loginForm + &quot;?target=&quot; + targetParameter + &quot;&amp;&quot; + SecurityConstants.NONCE_HEADER_NAME + &quot;=&quot; + request.getSession(Boolean.FALSE).getId();
        log.debug(&quot;重定向至前后端分离的登录页面：{}&quot;, targetUrl);
        this.redirectStrategy.sendRedirect(request, response, targetUrl);

    }
}
</code></pre>
<h4 id="1-在securityconstants中添加nonce_header_name">1. 在<code>SecurityConstants</code>中添加<code>NONCE_HEADER_NAME</code></h4>
<p>2023-07-21修改内容：oauth协议中有<code>nonce</code>参数，为防止冲突，<code>nonce</code>参数改为<code>nonceId</code></p>
<pre><code class="language-java">/**
 * 随机字符串请求头名字
 */
public static final String NONCE_HEADER_NAME = &quot;nonceId&quot;;
</code></pre>
<h3 id="4-在support包下创建redissecuritycontextrepository并实现securitycontextrepository">4. 在support包下创建<code>RedisSecurityContextRepository</code>并实现<code>SecurityContextRepository</code></h3>
<blockquote>
<p>2023-07-11新增逻辑：如果请求头与请求参数中获取不到随机字符串nonce则获取当前session的sessionId，详情请查看代码</p>
</blockquote>
<pre><code class="language-java">package com.example.support;

import com.example.model.security.SupplierDeferredSecurityContext;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import jakarta.servlet.http.HttpSession;
import lombok.RequiredArgsConstructor;
import org.springframework.security.core.context.DeferredSecurityContext;
import org.springframework.security.core.context.SecurityContext;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.security.core.context.SecurityContextHolderStrategy;
import org.springframework.security.web.context.HttpRequestResponseHolder;
import org.springframework.security.web.context.SecurityContextRepository;
import org.springframework.stereotype.Component;
import org.springframework.util.ObjectUtils;

import java.util.function.Supplier;

import static com.example.constant.RedisConstants.DEFAULT_TIMEOUT_SECONDS;
import static com.example.constant.RedisConstants.SECURITY_CONTEXT_PREFIX_KEY;
import static com.example.constant.SecurityConstants.NONCE_HEADER_NAME;

/**
 * 基于redis存储认证信息
 *
 * @author vains
 */
@Component
@RequiredArgsConstructor
public class RedisSecurityContextRepository implements SecurityContextRepository {

    private final RedisOperator&lt;SecurityContext&gt; redisOperator;

    private final SecurityContextHolderStrategy securityContextHolderStrategy = SecurityContextHolder
            .getContextHolderStrategy();


    @Override
    public SecurityContext loadContext(HttpRequestResponseHolder requestResponseHolder) {
//        HttpServletRequest request = requestResponseHolder.getRequest();
//        return readSecurityContextFromRedis(request);
        // 方法已过时，使用 loadDeferredContext 方法
        throw new UnsupportedOperationException(&quot;Method deprecated.&quot;);
    }

    @Override
    public void saveContext(SecurityContext context, HttpServletRequest request, HttpServletResponse response) {
        String nonce = getNonce(request);
        if (ObjectUtils.isEmpty(nonce)) {
            return;
        }

        // 如果当前的context是空的，则移除
        SecurityContext emptyContext = this.securityContextHolderStrategy.createEmptyContext();
        if (emptyContext.equals(context)) {
            redisOperator.delete((SECURITY_CONTEXT_PREFIX_KEY + nonce));
        } else {
            // 保存认证信息
            redisOperator.set((SECURITY_CONTEXT_PREFIX_KEY + nonce), context, DEFAULT_TIMEOUT_SECONDS);
        }
    }

    @Override
    public boolean containsContext(HttpServletRequest request) {
        String nonce = getNonce(request);
        if (ObjectUtils.isEmpty(nonce)) {
            return false;
        }
        // 检验当前请求是否有认证信息
        return redisOperator.get((SECURITY_CONTEXT_PREFIX_KEY + nonce)) != null;
    }

    @Override
    public DeferredSecurityContext loadDeferredContext(HttpServletRequest request) {
        Supplier&lt;SecurityContext&gt; supplier = () -&gt; readSecurityContextFromRedis(request);
        return new SupplierDeferredSecurityContext(supplier, this.securityContextHolderStrategy);
    }

    /**
     * 从redis中获取认证信息
     *
     * @param request 当前请求
     * @return 认证信息
     */
    private SecurityContext readSecurityContextFromRedis(HttpServletRequest request) {
        if (request == null) {
            return null;
        }

        String nonce = getNonce(request);
        if (ObjectUtils.isEmpty(nonce)) {
            return null;
        }

        // 根据缓存id获取认证信息
        return redisOperator.get((SECURITY_CONTEXT_PREFIX_KEY + nonce));
    }

    /**
     * 先从请求头中找，找不到去请求参数中找，找不到获取当前session的id
     *  2023-07-11新增逻辑：获取当前session的sessionId
     *
     * @param request 当前请求
     * @return 随机字符串(sessionId)，这个字符串本来是前端生成，现在改为后端获取的sessionId
     */
    private String getNonce(HttpServletRequest request) {
        String nonce = request.getHeader(NONCE_HEADER_NAME);
        if (ObjectUtils.isEmpty(nonce)) {
            nonce = request.getParameter(NONCE_HEADER_NAME);
            HttpSession session = request.getSession(Boolean.FALSE);
            if (ObjectUtils.isEmpty(nonce) &amp;&amp; session != null) {
                nonce = session.getId();
            }
        }
        return nonce;
    }

}
</code></pre>
<h4 id="1-补充supplierdeferredsecuritycontext类">1. 补充<code>SupplierDeferredSecurityContext</code>类</h4>
<p>该类默认包外无法访问，将框架中的复制一份暴露出来</p>
<pre><code class="language-java">package com.example.model.security;

import java.util.function.Supplier;

import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;

import org.springframework.core.log.LogMessage;
import org.springframework.security.core.context.DeferredSecurityContext;
import org.springframework.security.core.context.SecurityContext;
import org.springframework.security.core.context.SecurityContextHolderStrategy;

/**
 * @author Steve Riesenberg
 * @since 5.8
 */
public final class SupplierDeferredSecurityContext implements DeferredSecurityContext {

    private static final Log logger = LogFactory.getLog(SupplierDeferredSecurityContext.class);

    private final Supplier&lt;SecurityContext&gt; supplier;

    private final SecurityContextHolderStrategy strategy;

    private SecurityContext securityContext;

    private boolean missingContext;

    public SupplierDeferredSecurityContext(Supplier&lt;SecurityContext&gt; supplier, SecurityContextHolderStrategy strategy) {
        this.supplier = supplier;
        this.strategy = strategy;
    }

    @Override
    public SecurityContext get() {
        init();
        return this.securityContext;
    }

    @Override
    public boolean isGenerated() {
        init();
        return this.missingContext;
    }

    private void init() {
        if (this.securityContext != null) {
            return;
        }

        this.securityContext = this.supplier.get();
        this.missingContext = (this.securityContext == null);
        if (this.missingContext) {
            this.securityContext = this.strategy.createEmptyContext();
            if (logger.isTraceEnabled()) {
                logger.trace(LogMessage.format(&quot;Created %s&quot;, this.securityContext));
            }
        }
    }

}
</code></pre>
<h3 id="5-将以上自己创建的类添加至security配置中">5. 将以上自己创建的类添加至security配置中</h3>
<h4 id="1-配置认证服务配置">1. 配置认证服务配置</h4>
<pre><code class="language-java">// 主要是以下两处配置
// 使用redis存储、读取登录的认证信息 
http.securityContext(context -&gt; context.securityContextRepository(redisSecurityContextRepository));
// 这里使用自定义的未登录处理，并设置登录地址为前端的登录地址
http
        // 当未登录时访问认证端点时重定向至login页面
        .exceptionHandling((exceptions) -&gt; exceptions
                .defaultAuthenticationEntryPointFor(
                // 这里使用自定义的未登录处理，并设置登录地址为前端的登录地址
                        new LoginTargetAuthenticationEntryPoint(&quot;http://127.0.0.1:5173&quot;),
                        new MediaTypeRequestMatcher(MediaType.TEXT_HTML)
                )
        )
</code></pre>
<pre><code class="language-java">/**
 * 配置端点的过滤器链
 *
 * @param http spring security核心配置类
 * @return 过滤器链
 * @throws Exception 抛出
 */
@Bean
public SecurityFilterChain authorizationServerSecurityFilterChain(HttpSecurity http,
                                                                  RegisteredClientRepository registeredClientRepository,
                                                                  AuthorizationServerSettings authorizationServerSettings) throws Exception {
    // 配置默认的设置，忽略认证端点的csrf校验
    OAuth2AuthorizationServerConfiguration.applyDefaultSecurity(http);

    // 新建设备码converter和provider
    DeviceClientAuthenticationConverter deviceClientAuthenticationConverter =
            new DeviceClientAuthenticationConverter(
                    authorizationServerSettings.getDeviceAuthorizationEndpoint());
    DeviceClientAuthenticationProvider deviceClientAuthenticationProvider =
            new DeviceClientAuthenticationProvider(registeredClientRepository);

    // 使用redis存储、读取登录的认证信息
    http.securityContext(context -&gt; context.securityContextRepository(redisSecurityContextRepository));

    http.getConfigurer(OAuth2AuthorizationServerConfigurer.class)
            // 开启OpenID Connect 1.0协议相关端点
            .oidc(Customizer.withDefaults())
            // 设置自定义用户确认授权页
            .authorizationEndpoint(authorizationEndpoint -&gt; authorizationEndpoint.consentPage(CUSTOM_CONSENT_PAGE_URI))
            // 设置设备码用户验证url(自定义用户验证页)
            .deviceAuthorizationEndpoint(deviceAuthorizationEndpoint -&gt;
                    deviceAuthorizationEndpoint.verificationUri(&quot;/activate&quot;)
            )
            // 设置验证设备码用户确认页面
            .deviceVerificationEndpoint(deviceVerificationEndpoint -&gt;
                    deviceVerificationEndpoint.consentPage(CUSTOM_CONSENT_PAGE_URI)
            )
            .clientAuthentication(clientAuthentication -&gt;
                    // 客户端认证添加设备码的converter和provider
                    clientAuthentication
                            .authenticationConverter(deviceClientAuthenticationConverter)
                            .authenticationProvider(deviceClientAuthenticationProvider)
            );
    http
            // 当未登录时访问认证端点时重定向至login页面
            .exceptionHandling((exceptions) -&gt; exceptions
                    .defaultAuthenticationEntryPointFor(
                            new LoginTargetAuthenticationEntryPoint(&quot;http://127.0.0.1:5173&quot;),
                            new MediaTypeRequestMatcher(MediaType.TEXT_HTML)
                    )
            )
            // 处理使用access token访问用户信息端点和客户端注册端点
            .oauth2ResourceServer((resourceServer) -&gt; resourceServer
                    .jwt(Customizer.withDefaults()));

    // 自定义短信认证登录转换器
    SmsCaptchaGrantAuthenticationConverter converter = new SmsCaptchaGrantAuthenticationConverter();
    // 自定义短信认证登录认证提供
    SmsCaptchaGrantAuthenticationProvider provider = new SmsCaptchaGrantAuthenticationProvider();
    http.getConfigurer(OAuth2AuthorizationServerConfigurer.class)
            // 让认证服务器元数据中有自定义的认证方式
            .authorizationServerMetadataEndpoint(metadata -&gt; metadata.authorizationServerMetadataCustomizer(customizer -&gt; customizer.grantType(SecurityConstants.GRANT_TYPE_SMS_CODE)))
            // 添加自定义grant_type——短信认证登录
            .tokenEndpoint(tokenEndpoint -&gt; tokenEndpoint
                    .accessTokenRequestConverter(converter)
                    .authenticationProvider(provider));

    DefaultSecurityFilterChain build = http.build();

    // 从框架中获取provider中所需的bean
    OAuth2TokenGenerator&lt;?&gt; tokenGenerator = http.getSharedObject(OAuth2TokenGenerator.class);
    AuthenticationManager authenticationManager = http.getSharedObject(AuthenticationManager.class);
    OAuth2AuthorizationService authorizationService = http.getSharedObject(OAuth2AuthorizationService.class);
    // 以上三个bean在build()方法之后调用是因为调用build方法时框架会尝试获取这些类，
    // 如果获取不到则初始化一个实例放入SharedObject中，所以要在build方法调用之后获取
    // 在通过set方法设置进provider中，但是如果在build方法之后调用authenticationProvider(provider)
    // 框架会提示unsupported_grant_type，因为已经初始化完了，在添加就不会生效了
    provider.setTokenGenerator(tokenGenerator);
    provider.setAuthorizationService(authorizationService);
    provider.setAuthenticationManager(authenticationManager);

    return build;
}
</code></pre>
<h4 id="2-配置认证相关的过滤器链资源服务器配置">2. 配置认证相关的过滤器链(资源服务器配置)</h4>
<p>配置地方跟上边差不多，自定义登录成功/失败处理，使用redis替换session的存储，因为前后端分离了，还要配置解决跨域问题的过滤器，并禁用cors与csrf。</p>
<ul>
<li>跨域过滤器一定要添加至security配置中，不然只注入ioc中对于security端点不生效！</li>
<li>跨域过滤器一定要添加至security配置中，不然只注入ioc中对于security端点不生效！</li>
<li>跨域过滤器一定要添加至security配置中，不然只注入ioc中对于security端点不生效！</li>
</ul>
<pre><code class="language-java">/**
 * 配置认证相关的过滤器链
 *
 * @param http spring security核心配置类
 * @return 过滤器链
 * @throws Exception 抛出
 */
@Bean
public SecurityFilterChain defaultSecurityFilterChain(HttpSecurity http) throws Exception {
    // 添加跨域过滤器
    http.addFilter(corsFilter());
    // 禁用 csrf 与 cors
    http.csrf(AbstractHttpConfigurer::disable);
    http.cors(AbstractHttpConfigurer::disable);
    http.authorizeHttpRequests((authorize) -&gt; authorize
                    // 放行静态资源
                    .requestMatchers(&quot;/assets/**&quot;, &quot;/webjars/**&quot;, &quot;/login&quot;, &quot;/getCaptcha&quot;, &quot;/getSmsCaptcha&quot;).permitAll()
                    .anyRequest().authenticated()
            )
            // 指定登录页面
            .formLogin(formLogin -&gt;
                    formLogin.loginPage(&quot;/login&quot;)
                            // 登录成功和失败改为写回json，不重定向了
                            .successHandler(new LoginSuccessHandler())
                            .failureHandler(new LoginFailureHandler())
            );
    // 添加BearerTokenAuthenticationFilter，将认证服务当做一个资源服务，解析请求头中的token
    http.oauth2ResourceServer((resourceServer) -&gt; resourceServer
            .jwt(Customizer.withDefaults())
            .accessDeniedHandler(SecurityUtils::exceptionHandler)
            .authenticationEntryPoint(SecurityUtils::exceptionHandler)
    );
    http
            // 当未登录时访问认证端点时重定向至login页面
            .exceptionHandling((exceptions) -&gt; exceptions
                    .defaultAuthenticationEntryPointFor(
                            new LoginTargetAuthenticationEntryPoint(&quot;http://127.0.0.1:5173&quot;),
                            new MediaTypeRequestMatcher(MediaType.TEXT_HTML)
                    )
            );

    // 使用redis存储、读取登录的认证信息
    http.securityContext(context -&gt; context.securityContextRepository(redisSecurityContextRepository));

    return http.build();
}
</code></pre>
<h4 id="3-在authorizationconfig中添加跨域过滤器">3. 在AuthorizationConfig中添加跨域过滤器</h4>
<pre><code class="language-java">/**
 * 跨域过滤器配置
 *
 * @return CorsFilter
 */
@Bean
public CorsFilter corsFilter() {

    // 初始化cors配置对象
    CorsConfiguration configuration = new CorsConfiguration();

    // 设置允许跨域的域名,如果允许携带cookie的话,路径就不能写*号, *表示所有的域名都可以跨域访问
    configuration.addAllowedOrigin(&quot;http://127.0.0.1:5173&quot;);
    // 设置跨域访问可以携带cookie
    configuration.setAllowCredentials(true);
    // 允许所有的请求方法 ==&gt; GET POST PUT Delete
    configuration.addAllowedMethod(&quot;*&quot;);
    // 允许携带任何头信息
    configuration.addAllowedHeader(&quot;*&quot;);

    // 初始化cors配置源对象
    UrlBasedCorsConfigurationSource configurationSource = new UrlBasedCorsConfigurationSource();

    // 给配置源对象设置过滤的参数
    // 参数一: 过滤的路径 == &gt; 所有的路径都要求校验是否跨域
    // 参数二: 配置类
    configurationSource.registerCorsConfiguration(&quot;/**&quot;, configuration);

    // 返回配置好的过滤器
    return new CorsFilter(configurationSource);
}
</code></pre>
<h4 id="4-redisconstants中添加常量">4. RedisConstants中添加常量</h4>
<pre><code class="language-java">/**  
 * 认证信息存储前缀  
 */  
public static final String SECURITY_CONTEXT_PREFIX_KEY = &quot;security_context:&quot;;
</code></pre>
<h4 id="5-如果没有redisoperator可以看下我之前的优化篇">5. 如果没有RedisOperator可以看下我之前的<a href="https://juejin.cn/post/7253331974050299963">优化篇</a></h4>
<h4 id="6-完整的authorizationconfig如下">6. 完整的AuthorizationConfig如下</h4>
<pre><code class="language-java">package com.example.config;

import com.example.authorization.device.DeviceClientAuthenticationConverter;
import com.example.authorization.device.DeviceClientAuthenticationProvider;
import com.example.authorization.handler.LoginFailureHandler;
import com.example.authorization.handler.LoginSuccessHandler;
import com.example.authorization.handler.LoginTargetAuthenticationEntryPoint;
import com.example.authorization.sms.SmsCaptchaGrantAuthenticationConverter;
import com.example.authorization.sms.SmsCaptchaGrantAuthenticationProvider;
import com.example.constant.SecurityConstants;
import com.example.support.RedisSecurityContextRepository;
import com.example.util.SecurityUtils;
import com.nimbusds.jose.jwk.JWKSet;
import com.nimbusds.jose.jwk.RSAKey;
import com.nimbusds.jose.jwk.source.ImmutableJWKSet;
import com.nimbusds.jose.jwk.source.JWKSource;
import com.nimbusds.jose.proc.SecurityContext;
import lombok.RequiredArgsConstructor;
import lombok.SneakyThrows;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.http.MediaType;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.security.access.annotation.Secured;
import org.springframework.security.authentication.AuthenticationManager;
import org.springframework.security.config.Customizer;
import org.springframework.security.config.annotation.authentication.configuration.AuthenticationConfiguration;
import org.springframework.security.config.annotation.method.configuration.EnableMethodSecurity;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;
import org.springframework.security.config.annotation.web.configurers.AbstractHttpConfigurer;
import org.springframework.security.core.GrantedAuthority;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.security.oauth2.core.AuthorizationGrantType;
import org.springframework.security.oauth2.core.ClientAuthenticationMethod;
import org.springframework.security.oauth2.core.oidc.OidcScopes;
import org.springframework.security.oauth2.jwt.JwtClaimsSet;
import org.springframework.security.oauth2.jwt.JwtDecoder;
import org.springframework.security.oauth2.server.authorization.JdbcOAuth2AuthorizationConsentService;
import org.springframework.security.oauth2.server.authorization.JdbcOAuth2AuthorizationService;
import org.springframework.security.oauth2.server.authorization.OAuth2AuthorizationConsentService;
import org.springframework.security.oauth2.server.authorization.OAuth2AuthorizationService;
import org.springframework.security.oauth2.server.authorization.client.JdbcRegisteredClientRepository;
import org.springframework.security.oauth2.server.authorization.client.RegisteredClient;
import org.springframework.security.oauth2.server.authorization.client.RegisteredClientRepository;
import org.springframework.security.oauth2.server.authorization.config.annotation.web.configuration.OAuth2AuthorizationServerConfiguration;
import org.springframework.security.oauth2.server.authorization.config.annotation.web.configurers.OAuth2AuthorizationServerConfigurer;
import org.springframework.security.oauth2.server.authorization.settings.AuthorizationServerSettings;
import org.springframework.security.oauth2.server.authorization.settings.ClientSettings;
import org.springframework.security.oauth2.server.authorization.token.JwtEncodingContext;
import org.springframework.security.oauth2.server.authorization.token.OAuth2TokenCustomizer;
import org.springframework.security.oauth2.server.authorization.token.OAuth2TokenGenerator;
import org.springframework.security.oauth2.server.resource.authentication.JwtAuthenticationConverter;
import org.springframework.security.oauth2.server.resource.authentication.JwtGrantedAuthoritiesConverter;
import org.springframework.security.web.DefaultSecurityFilterChain;
import org.springframework.security.web.SecurityFilterChain;
import org.springframework.security.web.util.matcher.MediaTypeRequestMatcher;
import org.springframework.web.cors.CorsConfiguration;
import org.springframework.web.cors.UrlBasedCorsConfigurationSource;
import org.springframework.web.filter.CorsFilter;

import java.security.KeyPair;
import java.security.KeyPairGenerator;
import java.security.interfaces.RSAPrivateKey;
import java.security.interfaces.RSAPublicKey;
import java.util.*;
import java.util.stream.Collectors;

/**
 * 认证配置
 * {@link EnableMethodSecurity} 开启全局方法认证，启用JSR250注解支持，启用注解 {@link Secured} 支持，
 * 在Spring Security 6.0版本中将@Configuration注解从@EnableWebSecurity, @EnableMethodSecurity, @EnableGlobalMethodSecurity
 * 和 @EnableGlobalAuthentication 中移除，使用这些注解需手动添加 @Configuration 注解
 * {@link EnableWebSecurity} 注解有两个作用:
 * 1. 加载了WebSecurityConfiguration配置类, 配置安全认证策略。
 * 2. 加载了AuthenticationConfiguration, 配置了认证信息。
 *
 * @author vains
 */
@Configuration
@EnableWebSecurity
@RequiredArgsConstructor
@EnableMethodSecurity(jsr250Enabled = true, securedEnabled = true)
public class AuthorizationConfig {

    private static final String CUSTOM_CONSENT_PAGE_URI = &quot;/oauth2/consent&quot;;

    private final RedisSecurityContextRepository redisSecurityContextRepository;

    /**
     * 配置端点的过滤器链
     *
     * @param http spring security核心配置类
     * @return 过滤器链
     * @throws Exception 抛出
     */
    @Bean
    public SecurityFilterChain authorizationServerSecurityFilterChain(HttpSecurity http,
                                                                      RegisteredClientRepository registeredClientRepository,
                                                                      AuthorizationServerSettings authorizationServerSettings) throws Exception {
        // 配置默认的设置，忽略认证端点的csrf校验
        OAuth2AuthorizationServerConfiguration.applyDefaultSecurity(http);

        // 新建设备码converter和provider
        DeviceClientAuthenticationConverter deviceClientAuthenticationConverter =
                new DeviceClientAuthenticationConverter(
                        authorizationServerSettings.getDeviceAuthorizationEndpoint());
        DeviceClientAuthenticationProvider deviceClientAuthenticationProvider =
                new DeviceClientAuthenticationProvider(registeredClientRepository);

        // 使用redis存储、读取登录的认证信息
        http.securityContext(context -&gt; context.securityContextRepository(redisSecurityContextRepository));

        http.getConfigurer(OAuth2AuthorizationServerConfigurer.class)
                // 开启OpenID Connect 1.0协议相关端点
                .oidc(Customizer.withDefaults())
                // 设置自定义用户确认授权页
                .authorizationEndpoint(authorizationEndpoint -&gt; authorizationEndpoint.consentPage(CUSTOM_CONSENT_PAGE_URI))
                // 设置设备码用户验证url(自定义用户验证页)
                .deviceAuthorizationEndpoint(deviceAuthorizationEndpoint -&gt;
                        deviceAuthorizationEndpoint.verificationUri(&quot;/activate&quot;)
                )
                // 设置验证设备码用户确认页面
                .deviceVerificationEndpoint(deviceVerificationEndpoint -&gt;
                        deviceVerificationEndpoint.consentPage(CUSTOM_CONSENT_PAGE_URI)
                )
                .clientAuthentication(clientAuthentication -&gt;
                        // 客户端认证添加设备码的converter和provider
                        clientAuthentication
                                .authenticationConverter(deviceClientAuthenticationConverter)
                                .authenticationProvider(deviceClientAuthenticationProvider)
                );
        http
                // 当未登录时访问认证端点时重定向至login页面
                .exceptionHandling((exceptions) -&gt; exceptions
                        .defaultAuthenticationEntryPointFor(
                                new LoginTargetAuthenticationEntryPoint(&quot;http://127.0.0.1:5173&quot;),
                                new MediaTypeRequestMatcher(MediaType.TEXT_HTML)
                        )
                )
                // 处理使用access token访问用户信息端点和客户端注册端点
                .oauth2ResourceServer((resourceServer) -&gt; resourceServer
                        .jwt(Customizer.withDefaults()));

        // 自定义短信认证登录转换器
        SmsCaptchaGrantAuthenticationConverter converter = new SmsCaptchaGrantAuthenticationConverter();
        // 自定义短信认证登录认证提供
        SmsCaptchaGrantAuthenticationProvider provider = new SmsCaptchaGrantAuthenticationProvider();
        http.getConfigurer(OAuth2AuthorizationServerConfigurer.class)
                // 让认证服务器元数据中有自定义的认证方式
                .authorizationServerMetadataEndpoint(metadata -&gt; metadata.authorizationServerMetadataCustomizer(customizer -&gt; customizer.grantType(SecurityConstants.GRANT_TYPE_SMS_CODE)))
                // 添加自定义grant_type——短信认证登录
                .tokenEndpoint(tokenEndpoint -&gt; tokenEndpoint
                        .accessTokenRequestConverter(converter)
                        .authenticationProvider(provider));

        DefaultSecurityFilterChain build = http.build();

        // 从框架中获取provider中所需的bean
        OAuth2TokenGenerator&lt;?&gt; tokenGenerator = http.getSharedObject(OAuth2TokenGenerator.class);
        AuthenticationManager authenticationManager = http.getSharedObject(AuthenticationManager.class);
        OAuth2AuthorizationService authorizationService = http.getSharedObject(OAuth2AuthorizationService.class);
        // 以上三个bean在build()方法之后调用是因为调用build方法时框架会尝试获取这些类，
        // 如果获取不到则初始化一个实例放入SharedObject中，所以要在build方法调用之后获取
        // 在通过set方法设置进provider中，但是如果在build方法之后调用authenticationProvider(provider)
        // 框架会提示unsupported_grant_type，因为已经初始化完了，在添加就不会生效了
        provider.setTokenGenerator(tokenGenerator);
        provider.setAuthorizationService(authorizationService);
        provider.setAuthenticationManager(authenticationManager);

        return build;
    }

    /**
     * 配置认证相关的过滤器链
     *
     * @param http spring security核心配置类
     * @return 过滤器链
     * @throws Exception 抛出
     */
    @Bean
    public SecurityFilterChain defaultSecurityFilterChain(HttpSecurity http) throws Exception {
        // 添加跨域过滤器
        http.addFilter(corsFilter());
        // 禁用 csrf 与 cors
        http.csrf(AbstractHttpConfigurer::disable);
        http.cors(AbstractHttpConfigurer::disable);
        http.authorizeHttpRequests((authorize) -&gt; authorize
                        // 放行静态资源
                        .requestMatchers(&quot;/assets/**&quot;, &quot;/webjars/**&quot;, &quot;/login&quot;, &quot;/getCaptcha&quot;, &quot;/getSmsCaptcha&quot;).permitAll()
                        .anyRequest().authenticated()
                )
                // 指定登录页面
                .formLogin(formLogin -&gt;
                        formLogin.loginPage(&quot;/login&quot;)
                                // 登录成功和失败改为写回json，不重定向了
                                .successHandler(new LoginSuccessHandler())
                                .failureHandler(new LoginFailureHandler())
                );
        // 添加BearerTokenAuthenticationFilter，将认证服务当做一个资源服务，解析请求头中的token
        http.oauth2ResourceServer((resourceServer) -&gt; resourceServer
                .jwt(Customizer.withDefaults())
                .accessDeniedHandler(SecurityUtils::exceptionHandler)
                .authenticationEntryPoint(SecurityUtils::exceptionHandler)
        );
        http
                // 当未登录时访问认证端点时重定向至login页面
                .exceptionHandling((exceptions) -&gt; exceptions
                        .defaultAuthenticationEntryPointFor(
                                new LoginTargetAuthenticationEntryPoint(&quot;http://127.0.0.1:5173&quot;),
                                new MediaTypeRequestMatcher(MediaType.TEXT_HTML)
                        )
                );

        // 使用redis存储、读取登录的认证信息
        http.securityContext(context -&gt; context.securityContextRepository(redisSecurityContextRepository));

        return http.build();
    }

    /**
     * 跨域过滤器配置
     *
     * @return CorsFilter
     */
    @Bean
    public CorsFilter corsFilter() {

        // 初始化cors配置对象
        CorsConfiguration configuration = new CorsConfiguration();

        // 设置允许跨域的域名,如果允许携带cookie的话,路径就不能写*号, *表示所有的域名都可以跨域访问
        configuration.addAllowedOrigin(&quot;http://127.0.0.1:5173&quot;);
        // 设置跨域访问可以携带cookie
        configuration.setAllowCredentials(true);
        // 允许所有的请求方法 ==&gt; GET POST PUT Delete
        configuration.addAllowedMethod(&quot;*&quot;);
        // 允许携带任何头信息
        configuration.addAllowedHeader(&quot;*&quot;);

        // 初始化cors配置源对象
        UrlBasedCorsConfigurationSource configurationSource = new UrlBasedCorsConfigurationSource();

        // 给配置源对象设置过滤的参数
        // 参数一: 过滤的路径 == &gt; 所有的路径都要求校验是否跨域
        // 参数二: 配置类
        configurationSource.registerCorsConfiguration(&quot;/**&quot;, configuration);

        // 返回配置好的过滤器
        return new CorsFilter(configurationSource);
    }

    /**
     * 自定义jwt，将权限信息放至jwt中
     *
     * @return OAuth2TokenCustomizer的实例
     */
    @Bean
    public OAuth2TokenCustomizer&lt;JwtEncodingContext&gt; oAuth2TokenCustomizer() {
        return context -&gt; {
            // 检查登录用户信息是不是UserDetails，排除掉没有用户参与的流程
            if (context.getPrincipal().getPrincipal() instanceof UserDetails user) {
                // 获取申请的scopes
                Set&lt;String&gt; scopes = context.getAuthorizedScopes();
                // 获取用户的权限
                Collection&lt;? extends GrantedAuthority&gt; authorities = user.getAuthorities();
                // 提取权限并转为字符串
                Set&lt;String&gt; authoritySet = Optional.ofNullable(authorities).orElse(Collections.emptyList()).stream()
                        // 获取权限字符串
                        .map(GrantedAuthority::getAuthority)
                        // 去重
                        .collect(Collectors.toSet());

                // 合并scope与用户信息
                authoritySet.addAll(scopes);

                JwtClaimsSet.Builder claims = context.getClaims();
                // 将权限信息放入jwt的claims中（也可以生成一个以指定字符分割的字符串放入）
                claims.claim(SecurityConstants.AUTHORITIES_KEY, authoritySet);
                // 放入其它自定内容
                // 角色、头像...
            }
        };
    }

    /**
     * 自定义jwt解析器，设置解析出来的权限信息的前缀与在jwt中的key
     *
     * @return jwt解析器 JwtAuthenticationConverter
     */
    @Bean
    public JwtAuthenticationConverter jwtAuthenticationConverter() {
        JwtGrantedAuthoritiesConverter grantedAuthoritiesConverter = new JwtGrantedAuthoritiesConverter();
        // 设置解析权限信息的前缀，设置为空是去掉前缀
        grantedAuthoritiesConverter.setAuthorityPrefix(&quot;&quot;);
        // 设置权限信息在jwt claims中的key
        grantedAuthoritiesConverter.setAuthoritiesClaimName(SecurityConstants.AUTHORITIES_KEY);

        JwtAuthenticationConverter jwtAuthenticationConverter = new JwtAuthenticationConverter();
        jwtAuthenticationConverter.setJwtGrantedAuthoritiesConverter(grantedAuthoritiesConverter);
        return jwtAuthenticationConverter;
    }


    /**
     * 将AuthenticationManager注入ioc中，其它需要使用地方可以直接从ioc中获取
     *
     * @param authenticationConfiguration 导出认证配置
     * @return AuthenticationManager 认证管理器
     */
    @Bean
    @SneakyThrows
    public AuthenticationManager authenticationManager(AuthenticationConfiguration authenticationConfiguration) {
        return authenticationConfiguration.getAuthenticationManager();
    }

    /**
     * 配置密码解析器，使用BCrypt的方式对密码进行加密和验证
     *
     * @return BCryptPasswordEncoder
     */
    @Bean
    public PasswordEncoder passwordEncoder() {
        return new BCryptPasswordEncoder();
    }

    /**
     * 配置客户端Repository
     *
     * @param jdbcTemplate    db 数据源信息
     * @param passwordEncoder 密码解析器
     * @return 基于数据库的repository
     */
    @Bean
    public RegisteredClientRepository registeredClientRepository(JdbcTemplate jdbcTemplate, PasswordEncoder passwordEncoder) {
        RegisteredClient registeredClient = RegisteredClient.withId(UUID.randomUUID().toString())
                // 客户端id
                .clientId(&quot;messaging-client&quot;)
                // 客户端秘钥，使用密码解析器加密
                .clientSecret(passwordEncoder.encode(&quot;123456&quot;))
                // 客户端认证方式，基于请求头的认证
                .clientAuthenticationMethod(ClientAuthenticationMethod.CLIENT_SECRET_BASIC)
                // 配置资源服务器使用该客户端获取授权时支持的方式
                .authorizationGrantType(AuthorizationGrantType.AUTHORIZATION_CODE)
                .authorizationGrantType(AuthorizationGrantType.REFRESH_TOKEN)
                .authorizationGrantType(AuthorizationGrantType.CLIENT_CREDENTIALS)
                // 客户端添加自定义认证
                .authorizationGrantType(new AuthorizationGrantType(SecurityConstants.GRANT_TYPE_SMS_CODE))
                // 授权码模式回调地址，oauth2.1已改为精准匹配，不能只设置域名，并且屏蔽了localhost，本机使用127.0.0.1访问
                .redirectUri(&quot;http://127.0.0.1:8080/login/oauth2/code/messaging-client-oidc&quot;)
                .redirectUri(&quot;https://www.baidu.com&quot;)
                // 该客户端的授权范围，OPENID与PROFILE是IdToken的scope，获取授权时请求OPENID的scope时认证服务会返回IdToken
                .scope(OidcScopes.OPENID)
                .scope(OidcScopes.PROFILE)
                // 自定scope
                .scope(&quot;message.read&quot;)
                .scope(&quot;message.write&quot;)
                // 客户端设置，设置用户需要确认授权
                .clientSettings(ClientSettings.builder().requireAuthorizationConsent(true).build())
                .build();

        // 基于db存储客户端，还有一个基于内存的实现 InMemoryRegisteredClientRepository
        JdbcRegisteredClientRepository registeredClientRepository = new JdbcRegisteredClientRepository(jdbcTemplate);

        // 初始化客户端
        RegisteredClient repositoryByClientId = registeredClientRepository.findByClientId(registeredClient.getClientId());
        if (repositoryByClientId == null) {
            registeredClientRepository.save(registeredClient);
        }
        // 设备码授权客户端
        RegisteredClient deviceClient = RegisteredClient.withId(UUID.randomUUID().toString())
                .clientId(&quot;device-message-client&quot;)
                // 公共客户端
                .clientAuthenticationMethod(ClientAuthenticationMethod.NONE)
                // 设备码授权
                .authorizationGrantType(AuthorizationGrantType.DEVICE_CODE)
                .authorizationGrantType(AuthorizationGrantType.REFRESH_TOKEN)
                // 自定scope
                .scope(&quot;message.read&quot;)
                .scope(&quot;message.write&quot;)
                .build();
        RegisteredClient byClientId = registeredClientRepository.findByClientId(deviceClient.getClientId());
        if (byClientId == null) {
            registeredClientRepository.save(deviceClient);
        }

        // PKCE客户端
        RegisteredClient pkceClient = RegisteredClient.withId(UUID.randomUUID().toString())
                .clientId(&quot;pkce-message-client&quot;)
                // 公共客户端
                .clientAuthenticationMethod(ClientAuthenticationMethod.NONE)
                // 授权码模式，因为是扩展授权码流程，所以流程还是授权码的流程，改变的只是参数
                .authorizationGrantType(AuthorizationGrantType.AUTHORIZATION_CODE)
                .authorizationGrantType(AuthorizationGrantType.REFRESH_TOKEN)
                // 授权码模式回调地址，oauth2.1已改为精准匹配，不能只设置域名，并且屏蔽了localhost，本机使用127.0.0.1访问
                .redirectUri(&quot;http://127.0.0.1:8080/login/oauth2/code/messaging-client-oidc&quot;)
                .clientSettings(ClientSettings.builder().requireProofKey(Boolean.TRUE).build())
                // 自定scope
                .scope(&quot;message.read&quot;)
                .scope(&quot;message.write&quot;)
                .build();
        RegisteredClient findPkceClient = registeredClientRepository.findByClientId(pkceClient.getClientId());
        if (findPkceClient == null) {
            registeredClientRepository.save(pkceClient);
        }
        return registeredClientRepository;
    }

    /**
     * 配置基于db的oauth2的授权管理服务
     *
     * @param jdbcTemplate               db数据源信息
     * @param registeredClientRepository 上边注入的客户端repository
     * @return JdbcOAuth2AuthorizationService
     */
    @Bean
    public OAuth2AuthorizationService authorizationService(JdbcTemplate jdbcTemplate, RegisteredClientRepository registeredClientRepository) {
        // 基于db的oauth2认证服务，还有一个基于内存的服务实现InMemoryOAuth2AuthorizationService
        return new JdbcOAuth2AuthorizationService(jdbcTemplate, registeredClientRepository);
    }

    /**
     * 配置基于db的授权确认管理服务
     *
     * @param jdbcTemplate               db数据源信息
     * @param registeredClientRepository 客户端repository
     * @return JdbcOAuth2AuthorizationConsentService
     */
    @Bean
    public OAuth2AuthorizationConsentService authorizationConsentService(JdbcTemplate jdbcTemplate, RegisteredClientRepository registeredClientRepository) {
        // 基于db的授权确认管理服务，还有一个基于内存的服务实现InMemoryOAuth2AuthorizationConsentService
        return new JdbcOAuth2AuthorizationConsentService(jdbcTemplate, registeredClientRepository);
    }

    /**
     * 配置jwk源，使用非对称加密，公开用于检索匹配指定选择器的JWK的方法
     *
     * @return JWKSource
     */
    @Bean
    public JWKSource&lt;SecurityContext&gt; jwkSource() {
        KeyPair keyPair = generateRsaKey();
        RSAPublicKey publicKey = (RSAPublicKey) keyPair.getPublic();
        RSAPrivateKey privateKey = (RSAPrivateKey) keyPair.getPrivate();
        RSAKey rsaKey = new RSAKey.Builder(publicKey)
                .privateKey(privateKey)
                .keyID(UUID.randomUUID().toString())
                .build();
        JWKSet jwkSet = new JWKSet(rsaKey);
        return new ImmutableJWKSet&lt;&gt;(jwkSet);
    }

    /**
     * 生成rsa密钥对，提供给jwk
     *
     * @return 密钥对
     */
    private static KeyPair generateRsaKey() {
        KeyPair keyPair;
        try {
            KeyPairGenerator keyPairGenerator = KeyPairGenerator.getInstance(&quot;RSA&quot;);
            keyPairGenerator.initialize(2048);
            keyPair = keyPairGenerator.generateKeyPair();
        } catch (Exception ex) {
            throw new IllegalStateException(ex);
        }
        return keyPair;
    }

    /**
     * 配置jwt解析器
     *
     * @param jwkSource jwk源
     * @return JwtDecoder
     */
    @Bean
    public JwtDecoder jwtDecoder(JWKSource&lt;SecurityContext&gt; jwkSource) {
        return OAuth2AuthorizationServerConfiguration.jwtDecoder(jwkSource);
    }

    /**
     * 添加认证服务器配置，设置jwt签发者、默认端点请求地址等
     *
     * @return AuthorizationServerSettings
     */
    @Bean
    public AuthorizationServerSettings authorizationServerSettings() {
        return AuthorizationServerSettings.builder()
                /*
                    设置token签发地址(http(s)://{ip}:{port}/context-path, http(s)://domain.com/context-path)
                    如果需要通过ip访问这里就是ip，如果是有域名映射就填域名，通过什么方式访问该服务这里就填什么
                 */
                .issuer(&quot;http://192.168.120.33:8080&quot;)
                .build();
    }

}
</code></pre>
<h3 id="6-编写登录页面">6. 编写登录页面</h3>
<p>前端有以下几点要求</p>
<p><del>1. 请求登录接口时需要附加一个key为nonce的参数，请求头或请求体中都可以</del></p>
<ol>
<li>请求登录接口之前获取当前地址栏中的noncenonceId参数，将其添加至请求头或请求体中。</li>
<li>请求成功后获取当前页面地址栏中的target的参数，重定向到该地址 ，<del>并携带刚才登录时携带的nonce参数</del></li>
<li>登录时区分密码模式登录与短信认证登录</li>
</ol>
<blockquote>
<p>2023-07-11修改内容：在请求登录接口时携带的<del>nonce</del> <code>nonceId</code>值从前端自己生成的随机字符串改为后端重定向过来时携带的<del>nonce</del> <code>nonceId</code>参数</p>
</blockquote>
<blockquote>
<p>2023-07-21修改内容：oauth协议中有<code>nonce</code>参数，为防止冲突，<code>nonce</code>参数改为<code>nonceId</code></p>
</blockquote>
<p>新建一个vue项目，引入<code>axios</code>和<code>naive ui</code>，这里只给出登录页面的代码，稍后我会将前端的代码上传至gitee</p>
<pre><code class="language-shell"># 安装 vite
npm install -g create-vite

# 创建项目目录
mkdir sas-frontend
cd ./sas-frontend

# 初始化项目
create-vite ./ --template vue-ts

# 安装依赖 测试运行
npm install
npm run dev

# 安装依赖
npm config set registry http://registry.npm.taobao.com
npm install axios --registry=http://registry.npm.taobao.com
npm install --save-dev naive-ui unplugin-auto-import unplugin-vue-components
</code></pre>
<pre><code class="language-vue">&lt;script setup lang=&quot;ts&quot;&gt;
import { ref } from &#x27;vue&#x27;
import HelloWorld from &#x27;./components/HelloWorld.vue&#x27;
import axios from &#x27;axios&#x27;
import { type CountdownProps, createDiscreteApi } from &#x27;naive-ui&#x27;

const { message } = createDiscreteApi([&#x27;message&#x27;])

// 定义登录提交的对象
const loginModel = ref({
  code: &#x27;&#x27;,
  username: &#x27;&#x27;,
  password: &#x27;&#x27;,
  loginType: &#x27;&#x27;,
  captchaId: &#x27;&#x27;,
  nonce: getQueryString(&#x27;nonceId&#x27;)
})

// 图形验证码的base64数据
let captchaImage = ref(&#x27;&#x27;)
// 图形验证码的值
let captchaCode = &#x27;&#x27;
// 是否开始倒计时
const counterActive = ref(false)

/**
 * 获取图形验证码
 */
const getCaptcha = () =&gt; {
  axios({
    method: &#x27;GET&#x27;,
    url: &#x27;http://192.168.1.102:8080/getCaptcha&#x27;
  }).then((r) =&gt; {
    let result = r.data
    if (result.success) {
      captchaCode = result.data.code
      captchaImage.value = result.data.imageData
      loginModel.value.captchaId = result.data.captchaId
    } else {
      message.warning(result.message)
    }
  })
}

/**
 * 提交登录表单
 */
const submitLogin = () =&gt; {
  loginModel.value.loginType = &#x27;passwordLogin&#x27;
  axios({
    method: &#x27;post&#x27;,
    url: &#x27;http://192.168.1.102:8080/login&#x27;,
    headers: {
      nonceId: loginModel.value.nonce,
      &#x27;Content-Type&#x27;: &#x27;application/x-www-form-urlencoded&#x27;
    },
    data: loginModel.value
  }).then((r) =&gt; {
    let result = r.data
    if (result.success) {
      // message.info(`登录成功`)
      let target = getQueryString(&#x27;target&#x27;)
      if (target) {
        window.location.href = target
      }
    } else {
      message.warning(result.message)
    }
  })
}

/**
 * 提交短信登录表单
 */
const submitSmsLogin = () =&gt; {
  loginModel.value.loginType = &#x27;smsCaptcha&#x27;
  axios({
    method: &#x27;post&#x27;,
    url: &#x27;http://192.168.1.102:8080/login&#x27;,
    headers: {
      nonceId: loginModel.value.nonce,
      &#x27;Content-Type&#x27;: &#x27;application/x-www-form-urlencoded&#x27;
    },
    data: loginModel.value
  }).then((r) =&gt; {
    let result = r.data
    if (result.success) {
      message.info(`登录成功`)
      let target = getQueryString(&#x27;target&#x27;)
      if (target) {
        window.location.href = target
      }
    } else {
      message.warning(result.message)
    }
  })
}

/**
 * 获取短信验证码
 */
const getSmsCaptcha = () =&gt; {
  if (!loginModel.value.username) {
    message.warning(&#x27;请先输入手机号.&#x27;)
    return
  }
  if (!loginModel.value.code) {
    message.warning(&#x27;请先输入验证码.&#x27;)
    return
  }
  if (loginModel.value.code !== captchaCode) {
    message.warning(&#x27;验证码错误.&#x27;)
    return
  }
  axios({
    method: &#x27;get&#x27;,
    url: `http://192.168.1.102:8080/getSmsCaptcha?phone=${loginModel.value.username}`
  }).then((r) =&gt; {
    let result = r.data
    if (result.success) {
      message.info(`获取短信验证码成功，固定为：${result.data}`)
      counterActive.value = true
    } else {
      message.warning(result.message)
    }
  })
}

/**
 * 切换时更新验证码
 */
const handleUpdateValue = () =&gt; {
  getCaptcha()
}

/**
 * 倒计时结束
 */
const onFinish = () =&gt; {
  counterActive.value = false
}

/**
 * 倒计时显示内容
 */
const renderCountdown: CountdownProps[&#x27;render&#x27;] = ({ hours, minutes, seconds }) =&gt; {
  return `${seconds}`
}

/**
 * 获取地址栏参数
 * @param name 地址栏参数的key
 */
function getQueryString(name: string) {
  var reg = new RegExp(&#x27;(^|&amp;)&#x27; + name + &#x27;=([^&amp;]*)(&amp;|$)&#x27;, &#x27;i&#x27;)

  var r = window.location.search.substr(1).match(reg)

  if (r != null) {
    return unescape(r[2])
  }

  return null
}

getCaptcha()
&lt;/script&gt;

&lt;template&gt;
  &lt;header&gt;
    &lt;img alt=&quot;Vue logo&quot; class=&quot;logo&quot; src=&quot;./assets/logo.svg&quot; width=&quot;125&quot; height=&quot;125&quot; /&gt;

    &lt;div class=&quot;wrapper&quot;&gt;
      &lt;HelloWorld msg=&quot;统一认证平台&quot; /&gt;
    &lt;/div&gt;
  &lt;/header&gt;

  &lt;main&gt;
    &lt;n-card title=&quot;&quot;&gt;
      &lt;n-tabs
        default-value=&quot;signin&quot;
        size=&quot;large&quot;
        justify-content=&quot;space-evenly&quot;
        @update:value=&quot;handleUpdateValue&quot;
      &gt;
        &lt;n-tab-pane name=&quot;signin&quot; tab=&quot;账号登录&quot;&gt;
          &lt;n-form&gt;
            &lt;n-form-item-row label=&quot;用户名&quot;&gt;
              &lt;n-input v-model:value=&quot;loginModel.username&quot; placeholder=&quot;手机号 / 邮箱&quot; /&gt;
            &lt;/n-form-item-row&gt;
            &lt;n-form-item-row label=&quot;密码&quot;&gt;
              &lt;n-input
                v-model:value=&quot;loginModel.password&quot;
                type=&quot;password&quot;
                show-password-on=&quot;mousedown&quot;
                placeholder=&quot;密码&quot;
              /&gt;
            &lt;/n-form-item-row&gt;
            &lt;n-form-item-row label=&quot;验证码&quot;&gt;
              &lt;n-input-group&gt;
                &lt;n-input v-model:value=&quot;loginModel.code&quot; placeholder=&quot;请输入验证码&quot; /&gt;
                &lt;n-image
                  @click=&quot;getCaptcha&quot;
                  width=&quot;130&quot;
                  height=&quot;34&quot;
                  :src=&quot;captchaImage&quot;
                  preview-disabled
                /&gt;
              &lt;/n-input-group&gt;
            &lt;/n-form-item-row&gt;
          &lt;/n-form&gt;
          &lt;n-button type=&quot;info&quot; @click=&quot;submitLogin&quot; block strong&gt; 登录 &lt;/n-button&gt;
        &lt;/n-tab-pane&gt;
        &lt;n-tab-pane name=&quot;signup&quot; tab=&quot;短信登录&quot;&gt;
          &lt;n-form&gt;
            &lt;n-form-item-row label=&quot;手机号&quot;&gt;
              &lt;n-input v-model:value=&quot;loginModel.username&quot; placeholder=&quot;手机号 / 邮箱&quot; /&gt;
            &lt;/n-form-item-row&gt;
            &lt;n-form-item-row label=&quot;验证码&quot;&gt;
              &lt;n-input-group&gt;
                &lt;n-input v-model:value=&quot;loginModel.code&quot; placeholder=&quot;请输入验证码&quot; /&gt;
                &lt;n-image
                  @click=&quot;getCaptcha&quot;
                  width=&quot;130&quot;
                  height=&quot;34&quot;
                  :src=&quot;captchaImage&quot;
                  preview-disabled
                /&gt;
              &lt;/n-input-group&gt;
            &lt;/n-form-item-row&gt;
            &lt;n-form-item-row label=&quot;验证码&quot;&gt;
              &lt;n-input-group&gt;
                &lt;n-input v-model:value=&quot;loginModel.password&quot; placeholder=&quot;请输入验证码&quot; /&gt;
                &lt;n-button
                  type=&quot;info&quot;
                  @click=&quot;getSmsCaptcha&quot;
                  style=&quot;width: 130px&quot;
                  :disabled=&quot;counterActive&quot;
                &gt;
                  获取验证码
                  &lt;span v-if=&quot;counterActive&quot;&gt;
                    (
                    &lt;n-countdown
                      :render=&quot;renderCountdown&quot;
                      :on-finish=&quot;onFinish&quot;
                      :duration=&quot;59 * 1000&quot;
                      :active=&quot;counterActive&quot;
                    /&gt;
                    )&lt;/span
                  &gt;
                &lt;/n-button&gt;
              &lt;/n-input-group&gt;
            &lt;/n-form-item-row&gt;
          &lt;/n-form&gt;
          &lt;n-button type=&quot;info&quot; @click=&quot;submitSmsLogin&quot; block strong&gt; 登录 &lt;/n-button&gt;
        &lt;/n-tab-pane&gt;
      &lt;/n-tabs&gt;
    &lt;/n-card&gt;
  &lt;/main&gt;
&lt;/template&gt;

&lt;style scoped&gt;
header {
  line-height: 1.5;
}

.logo {
  display: block;
  margin: 0 auto 2rem;
}

@media (min-width: 1024px) {
  header {
    display: flex;
    place-items: center;
    padding-right: calc(var(--section-gap) / 2);
  }

  .logo {
    margin: 0 2rem 0 0;
  }

  header .wrapper {
    display: flex;
    place-items: flex-start;
    flex-wrap: wrap;
  }
}
&lt;/style&gt;
</code></pre>
<p><strong>示例项目只是一个很简陋的页面，大家使用自己的页面即可(如果有前端大佬整个漂亮的登录页面就好了，求一个漂亮的登录页面)</strong></p>
<p>到此为止，编码部分就结束了，接下来就该测试了(老三样了，理论、编码、测试)</p>
<h2 id="四测试">四、测试</h2>
<h3 id="1-组装url发起授权请求">1. 组装url发起授权请求</h3>
<pre><code class="language-shell">http://192.168.1.102:8080/oauth2/authorize?client_id=messaging-client&amp;response_type=code&amp;scope=message.read&amp;redirect_uri=http://127.0.0.1:8000/login/oauth2/code/messaging-client-oidc
</code></pre>
<h3 id="2-检测到未登录重定向至vue项目的登录页面">2. 检测到未登录，重定向至vue项目的登录页面</h3>
<p><del>重定向时将当前请求放入target参数中</del></p>
<p>重定向时将当前请求放入target参数中，当前<code>sessionId</code>放入<code>nonce</code>参数中</p>
<p><img alt="img" src="/light-docusaurus/assets/images/12-12-a7ca56995740e1826227d5fbe4058c2d.awebp" width="1920" height="981"></p>
<p>查看一下network，认证服务按规则携带target与nonce参数重定向，没有问题</p>
<p><img alt="img" src="/light-docusaurus/assets/images/12-13-6b5b6a61c83c79eb1f64bd409d853d2a.awebp" width="1920" height="981"></p>
<h3 id="3-输入账号密码提交">3. 输入账号密码提交</h3>
<p><img alt="img" src="/light-docusaurus/assets/images/12-14-da0c8fa42194ab9636a425a73cd756b2.awebp" width="1920" height="985"></p>
<p>查看network</p>
<p><img alt="img" src="/light-docusaurus/assets/images/12-15-6cd252828fd7045087b1be4f44f7ab88.awebp" width="1920" height="986"></p>
<p>      <del>登录成功后会重定向回<code>/oauth2/authorize</code>接口并携带<code>nonce</code>参数，<code>/oauth2/authorize</code>根据<code>nonce</code>获取到认证信息后会生成一个<code>code</code>，然后携带<code>code</code>跳转至回调地址。</del></p>
<p>      不需要携 带任何参数，因为在重定向至登录之前已经获取到<code>sessionId</code>，并根据<code>sessionId</code>存储登录时的认证信息，所以重定向回<code>/oauth2/authorize</code>接口时能够根据<code>sessionId</code>获取到认证信息。获取到认证信息后检测到未授权确认，重定向至授权确认页面。</p>
<h4 id="4-授权确认提交">4. 授权确认提交</h4>
<p><img alt="img" src="/light-docusaurus/assets/images/12-16-19b964ea148606db61680db88d1bd137.awebp" width="1919" height="982"></p>
<p>授权确认后生成code并携带code重定向至回调地址(<code>redirect_uri</code>)</p>
<p><img alt="img" src="/light-docusaurus/assets/images/12-17-4b919bae52a3121ce9d3f68d8efb7623.awebp" width="1920" height="183"></p>
<h2 id="五写在最后">五、写在最后</h2>
<p>   <del>在踩了不知道多少坑以后终于算是实现了这个东西，但是目前只支持不需要授权确认的客户端，如果需要授权确认那么就会在重定向至授权确认页面时因为获取不到登录信息而重定向至登录页面，这里也比较坑，没有能够更改授权确认请求的地方，只能另辟蹊径修改现在的<code>RedisSecurityContextRepository</code>从而使授权确认请求也能获取到认证信息，就是在获取认证信息后存入<code>session</code>中一份，因为从<code>/oauth2/authorize</code>重定向至授权确认页面是同一个<code>session</code>，所以存入<code>session</code>后就可以获取了，但是我觉得既然都已经前后端分离了，也就没必要在加授权确认了；当然也不排除有需要这东西的人，后期看看有没有需要的，如果有需要的我会写一下扩展篇。</del></p>
<p>        现在改为通过<code>sessionId</code>串联认证服务与单独部署的登录页面的请求，也就不会出现只能获取一次认证信息的问题了，只要在同一个浏览器中访问认证服务，那么使用的<code>session</code>就只会是同一个，  当从其它系统跳转至认证服务时只要登录过就不需要在登录了，可以直接根据浏览器与认证服务之间产生的<code>session</code>的id获取到对应的认证信息，认证信息的存活时间就是在redis中设置的key的存活时间。</p>
<p>        虽然现在也是靠<code>session</code>关联，但现在将原先存储在<code>session</code>中的认证信息存储到了redis中，缩小了服务器存储<code>session</code>所需的空间，也可以通过<code>sessionId</code>将其关联起来，解决了认证服务与登录页面不在同一域从而因为<code>session</code>的不同而获取不到认证信息的问题。这也符合sso的特点，其它域名下的服务需要认证时需要跳转到登录页面登录，登录后另外的服务再次请求认证服务认证时就不需要认证了，可以直接获取到认证信息。</p>
<p>        本来想写点基础的东西，但是兄弟们太相信我了，净整些高端操作，唉 (╯°Д°)╯︵ ┻━┻</p>
<p>要是有问题请在评论区提出，以防误人子弟</p>
<p>代码已提交至Gitee的<code>授权码模式前后端分离的登录页面</code>分支，如果有遗漏内容大家也可以拉取一下完整代码看看。</p>
<p><a href="https://gitee.com/vains-Sofia/authorization-example/tree/%E6%8E%88%E6%9D%83%E7%A0%81%E6%A8%A1%E5%BC%8F%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BB%E7%9A%84%E7%99%BB%E5%BD%95%E9%A1%B5%E9%9D%A2/">仓库地址</a></p></div><footer class="theme-doc-footer docusaurus-mt-lg"><div class="theme-doc-footer-edit-meta-row row"><div class="col"><a href="https://github.com/lorchr/light-docusaurus/tree/main/docs/zh-cn/spring-authorization-server/12-SAS-Frontend-Backend-Separate.md" target="_blank" rel="noopener noreferrer" class="theme-edit-this-page"><svg fill="currentColor" height="20" width="20" viewBox="0 0 40 40" class="iconEdit_Z9Sw" aria-hidden="true"><g><path d="m34.5 11.7l-3 3.1-6.3-6.3 3.1-3q0.5-0.5 1.2-0.5t1.1 0.5l3.9 3.9q0.5 0.4 0.5 1.1t-0.5 1.2z m-29.5 17.1l18.4-18.5 6.3 6.3-18.4 18.4h-6.3v-6.2z"></path></g></svg>编辑此页</a></div><div class="col lastUpdated_vwxv"></div></div></footer></article><nav class="pagination-nav docusaurus-mt-lg" aria-label="文件选项卡"><a class="pagination-nav__link pagination-nav__link--prev" href="/light-docusaurus/docs/zh-cn/spring-authorization-server/SAS-OAuth2-Extension-Grant-Type/"><div class="pagination-nav__sublabel">上一页</div><div class="pagination-nav__label">SAS-OAuth2-Extension-Grant-Type</div></a><a class="pagination-nav__link pagination-nav__link--next" href="/light-docusaurus/docs/zh-cn/spring-authorization-server/SAS-Github-Gitee-Login/"><div class="pagination-nav__sublabel">下一页</div><div class="pagination-nav__label">SAS-Github-Gitee-Login</div></a></nav></div></div><div class="col col--3"><div class="tableOfContents_bqdL thin-scrollbar theme-doc-toc-desktop"><ul class="table-of-contents table-of-contents__left-border"><li><a href="#一实现思路分析" class="table-of-contents__link toc-highlight">一、实现思路分析</a><ul><li><a href="#1-先看一下在默认情况下请求在框架中的跳转情况" class="table-of-contents__link toc-highlight">1. 先看一下在默认情况下请求在框架中的跳转情况</a></li><li><a href="#2-先查看下框架怎么获取认证信息" class="table-of-contents__link toc-highlight">2. 先查看下框架怎么获取认证信息</a></li><li><a href="#3-存储认证信息" class="table-of-contents__link toc-highlight">3. 存储认证信息</a></li></ul></li><li><a href="#二改造分析" class="table-of-contents__link toc-highlight">二、改造分析</a></li><li><a href="#三代码实现" class="table-of-contents__link toc-highlight">三、代码实现</a><ul><li><a href="#1-创建loginsuccesshandler类并实现authenticationsuccesshandler接口" class="table-of-contents__link toc-highlight">1. 创建<code>LoginSuccessHandler</code>类并实现<code>AuthenticationSuccessHandler</code>接口</a></li><li><a href="#2-创建loginfailurehandler类并实现authenticationfailurehandler接口" class="table-of-contents__link toc-highlight">2. 创建<code>LoginFailureHandler</code>类并实现<code>AuthenticationFailureHandler</code>接口</a></li><li><a href="#3-创建logintargetauthenticationentrypoint类并继承loginurlauthenticationentrypoint类" class="table-of-contents__link toc-highlight">3. 创建<code>LoginTargetAuthenticationEntryPoint</code>类并继承<code>LoginUrlAuthenticationEntryPoint</code>类</a></li><li><a href="#4-在support包下创建redissecuritycontextrepository并实现securitycontextrepository" class="table-of-contents__link toc-highlight">4. 在support包下创建<code>RedisSecurityContextRepository</code>并实现<code>SecurityContextRepository</code></a></li><li><a href="#5-将以上自己创建的类添加至security配置中" class="table-of-contents__link toc-highlight">5. 将以上自己创建的类添加至security配置中</a></li><li><a href="#6-编写登录页面" class="table-of-contents__link toc-highlight">6. 编写登录页面</a></li></ul></li><li><a href="#四测试" class="table-of-contents__link toc-highlight">四、测试</a><ul><li><a href="#1-组装url发起授权请求" class="table-of-contents__link toc-highlight">1. 组装url发起授权请求</a></li><li><a href="#2-检测到未登录重定向至vue项目的登录页面" class="table-of-contents__link toc-highlight">2. 检测到未登录，重定向至vue项目的登录页面</a></li><li><a href="#3-输入账号密码提交" class="table-of-contents__link toc-highlight">3. 输入账号密码提交</a></li></ul></li><li><a href="#五写在最后" class="table-of-contents__link toc-highlight">五、写在最后</a></li></ul></div></div></div></div></main></div></div></div><footer class="footer footer--dark"><div class="container container-fluid"><div class="row footer__links"><div class="col footer__col"><div class="footer__title">Docs</div><ul class="footer__items clean-list"><li class="footer__item"><a class="footer__link-item" href="/light-docusaurus/docs/category/guide/">Torch</a></li><li class="footer__item"><a class="footer__link-item" href="/light-docusaurus/middleware/">Middleware</a></li><li class="footer__item"><a class="footer__link-item" href="/light-docusaurus/electron/">Electron</a></li></ul></div><div class="col footer__col"><div class="footer__title">Community</div><ul class="footer__items clean-list"><li class="footer__item"><a href="https://stackoverflow.com/questions/tagged/lorchr" target="_blank" rel="noopener noreferrer" class="footer__link-item">Stack Overflow<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li><li class="footer__item"><a href="https://discordapp.com/invite/lorchr" target="_blank" rel="noopener noreferrer" class="footer__link-item">Discord<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li><li class="footer__item"><a href="https://twitter.com/lorchr" target="_blank" rel="noopener noreferrer" class="footer__link-item">Twitter<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li></ul></div><div class="col footer__col"><div class="footer__title">More</div><ul class="footer__items clean-list"><li class="footer__item"><a class="footer__link-item" href="/light-docusaurus/blog/">Blog</a></li><li class="footer__item"><a class="footer__link-item" href="/light-docusaurus/diy/">DIY</a></li><li class="footer__item"><a href="https://github.com/lorchr/light-docusaurus" target="_blank" rel="noopener noreferrer" class="footer__link-item">GitHub<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li></ul></div><div class="col footer__col"><div class="footer__title">Offical</div><ul class="footer__items clean-list"><li class="footer__item"><a href="https://docusaurus.io" target="_blank" rel="noopener noreferrer" class="footer__link-item">Home<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li><li class="footer__item"><a href="https://github.com/facebook/docusaurus" target="_blank" rel="noopener noreferrer" class="footer__link-item">Github<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li><li class="footer__item"><a href="https://docusaurus.io/docs/playground" target="_blank" rel="noopener noreferrer" class="footer__link-item">Playground<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li></ul></div></div><div class="footer__bottom text--center"><div class="footer__copyright">Copyright © 2024 Light-Docusaurus, Inc. Built with Docusaurus.</div></div></div></footer></div>
</body>
</html>