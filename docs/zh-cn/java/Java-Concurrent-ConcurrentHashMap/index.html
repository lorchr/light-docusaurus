<!doctype html>
<html lang="zh-Hans" dir="ltr" class="docs-wrapper plugin-docs plugin-id-default docs-version-current docs-doc-page docs-doc-id-zh-cn/java/Java-Concurrent-ConcurrentHashMap" data-has-hydrated="false">
<head>
<meta charset="UTF-8">
<meta name="generator" content="Docusaurus v3.2.1">
<title data-rh="true">Java-Concurrent-ConcurrentHashMap | Light Docusaurus</title><meta data-rh="true" name="viewport" content="width=device-width,initial-scale=1"><meta data-rh="true" name="twitter:card" content="summary_large_image"><meta data-rh="true" property="og:image" content="https://lorchr.github.io/light-docusaurus/img/docusaurus-social-card.jpg"><meta data-rh="true" name="twitter:image" content="https://lorchr.github.io/light-docusaurus/img/docusaurus-social-card.jpg"><meta data-rh="true" property="og:url" content="https://lorchr.github.io/light-docusaurus/docs/zh-cn/java/Java-Concurrent-ConcurrentHashMap/"><meta data-rh="true" property="og:locale" content="zh_Hans"><meta data-rh="true" name="docusaurus_locale" content="zh-Hans"><meta data-rh="true" name="docsearch:language" content="zh-Hans"><meta data-rh="true" name="docusaurus_version" content="current"><meta data-rh="true" name="docusaurus_tag" content="docs-default-current"><meta data-rh="true" name="docsearch:version" content="current"><meta data-rh="true" name="docsearch:docusaurus_tag" content="docs-default-current"><meta data-rh="true" property="og:title" content="Java-Concurrent-ConcurrentHashMap | Light Docusaurus"><meta data-rh="true" name="description" content="- Java并发系列[9]----ConcurrentHashMap源码分析"><meta data-rh="true" property="og:description" content="- Java并发系列[9]----ConcurrentHashMap源码分析"><link data-rh="true" rel="icon" href="/light-docusaurus/img/favicon.ico"><link data-rh="true" rel="canonical" href="https://lorchr.github.io/light-docusaurus/docs/zh-cn/java/Java-Concurrent-ConcurrentHashMap/"><link data-rh="true" rel="alternate" href="https://lorchr.github.io/light-docusaurus/docs/zh-cn/java/Java-Concurrent-ConcurrentHashMap/" hreflang="zh-Hans"><link data-rh="true" rel="alternate" href="https://lorchr.github.io/light-docusaurus/docs/zh-cn/java/Java-Concurrent-ConcurrentHashMap/" hreflang="x-default"><link data-rh="true" rel="preconnect" href="https://TLGHDZ3Y2I-dsn.algolia.net" crossorigin="anonymous"><link rel="alternate" type="application/rss+xml" href="/light-docusaurus/blog/rss.xml" title="Light Docusaurus RSS Feed">
<link rel="alternate" type="application/atom+xml" href="/light-docusaurus/blog/atom.xml" title="Light Docusaurus Atom Feed">



<link rel="search" type="application/opensearchdescription+xml" title="Light Docusaurus" href="/light-docusaurus/opensearch.xml"><link rel="stylesheet" href="/light-docusaurus/assets/css/styles.10a62360.css">
<script src="/light-docusaurus/assets/js/runtime~main.018e30f2.js" defer="defer"></script>
<script src="/light-docusaurus/assets/js/main.4b4e5c80.js" defer="defer"></script>
</head>
<body class="navigation-with-keyboard">
<script>!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){try{return new URLSearchParams(window.location.search).get("docusaurus-theme")}catch(t){}}()||function(){try{return localStorage.getItem("theme")}catch(t){}}();t(null!==e?e:"light")}(),function(){try{const c=new URLSearchParams(window.location.search).entries();for(var[t,e]of c)if(t.startsWith("docusaurus-data-")){var a=t.replace("docusaurus-data-","data-");document.documentElement.setAttribute(a,e)}}catch(t){}}()</script><div id="__docusaurus"><div role="region" aria-label="跳到主要内容"><a class="skipToContent_fXgn" href="#__docusaurus_skipToContent_fallback">跳到主要内容</a></div><nav aria-label="主导航" class="navbar navbar--fixed-top"><div class="navbar__inner"><div class="navbar__items"><button aria-label="切换导航栏" aria-expanded="false" class="navbar__toggle clean-btn" type="button"><svg width="30" height="30" viewBox="0 0 30 30" aria-hidden="true"><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><a class="navbar__brand" href="/light-docusaurus/"><div class="navbar__logo"><img src="/light-docusaurus/img/logo.svg" alt="Torch Logo" class="themedComponent_mlkZ themedComponent--light_NVdE"><img src="/light-docusaurus/img/logo.svg" alt="Torch Logo" class="themedComponent_mlkZ themedComponent--dark_xIcU"></div><b class="navbar__title text--truncate">Torch</b></a><a aria-current="page" class="navbar__item navbar__link navbar__link--active" href="/light-docusaurus/docs/category/guide/">Torch</a><a class="navbar__item navbar__link" href="/light-docusaurus/blog/">Blog</a><a class="navbar__item navbar__link" href="/light-docusaurus/middleware/">Middleware</a><a class="navbar__item navbar__link" href="/light-docusaurus/electron/">Electron</a><a class="navbar__item navbar__link" href="/light-docusaurus/postman/">Postman</a><a class="navbar__item navbar__link" href="/light-docusaurus/diy/">DIY</a></div><div class="navbar__items navbar__items--right"><div class="navbar__item dropdown dropdown--hoverable dropdown--right"><a href="#" aria-haspopup="true" aria-expanded="false" role="button" class="navbar__link"><svg viewBox="0 0 24 24" width="20" height="20" aria-hidden="true" class="iconLanguage_nlXk"><path fill="currentColor" d="M12.87 15.07l-2.54-2.51.03-.03c1.74-1.94 2.98-4.17 3.71-6.53H17V4h-7V2H8v2H1v1.99h11.17C11.5 7.92 10.44 9.75 9 11.35 8.07 10.32 7.3 9.19 6.69 8h-2c.73 1.63 1.73 3.17 2.98 4.56l-5.09 5.02L4 19l5-5 3.11 3.11.76-2.04zM18.5 10h-2L12 22h2l1.12-3h4.75L21 22h2l-4.5-12zm-2.62 7l1.62-4.33L19.12 17h-3.24z"></path></svg>简体中文</a><ul class="dropdown__menu"><li><a href="/light-docusaurus/docs/zh-cn/java/Java-Concurrent-ConcurrentHashMap/" target="_self" rel="noopener noreferrer" class="dropdown__link dropdown__link--active" lang="zh-Hans">简体中文</a></li></ul></div><a href="https://github.com/lorchr/light-docusaurus" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link">GitHub<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a><div class="toggle_vylO colorModeToggle_DEke"><button class="clean-btn toggleButton_gllP toggleButtonDisabled_aARS" type="button" disabled="" title="切换浅色/暗黑模式（当前为浅色模式）" aria-label="切换浅色/暗黑模式（当前为浅色模式）" aria-live="polite"><svg viewBox="0 0 24 24" width="24" height="24" class="lightToggleIcon_pyhR"><path fill="currentColor" d="M12,9c1.65,0,3,1.35,3,3s-1.35,3-3,3s-3-1.35-3-3S10.35,9,12,9 M12,7c-2.76,0-5,2.24-5,5s2.24,5,5,5s5-2.24,5-5 S14.76,7,12,7L12,7z M2,13l2,0c0.55,0,1-0.45,1-1s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S1.45,13,2,13z M20,13l2,0c0.55,0,1-0.45,1-1 s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S19.45,13,20,13z M11,2v2c0,0.55,0.45,1,1,1s1-0.45,1-1V2c0-0.55-0.45-1-1-1S11,1.45,11,2z M11,20v2c0,0.55,0.45,1,1,1s1-0.45,1-1v-2c0-0.55-0.45-1-1-1C11.45,19,11,19.45,11,20z M5.99,4.58c-0.39-0.39-1.03-0.39-1.41,0 c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0s0.39-1.03,0-1.41L5.99,4.58z M18.36,16.95 c-0.39-0.39-1.03-0.39-1.41,0c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0c0.39-0.39,0.39-1.03,0-1.41 L18.36,16.95z M19.42,5.99c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06c-0.39,0.39-0.39,1.03,0,1.41 s1.03,0.39,1.41,0L19.42,5.99z M7.05,18.36c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06 c-0.39,0.39-0.39,1.03,0,1.41s1.03,0.39,1.41,0L7.05,18.36z"></path></svg><svg viewBox="0 0 24 24" width="24" height="24" class="darkToggleIcon_wfgR"><path fill="currentColor" d="M9.37,5.51C9.19,6.15,9.1,6.82,9.1,7.5c0,4.08,3.32,7.4,7.4,7.4c0.68,0,1.35-0.09,1.99-0.27C17.45,17.19,14.93,19,12,19 c-3.86,0-7-3.14-7-7C5,9.07,6.81,6.55,9.37,5.51z M12,3c-4.97,0-9,4.03-9,9s4.03,9,9,9s9-4.03,9-9c0-0.46-0.04-0.92-0.1-1.36 c-0.98,1.37-2.58,2.26-4.4,2.26c-2.98,0-5.4-2.42-5.4-5.4c0-1.81,0.89-3.42,2.26-4.4C12.92,3.04,12.46,3,12,3L12,3z"></path></svg></button></div><div class="navbarSearchContainer_Bca1"><button type="button" class="DocSearch DocSearch-Button" aria-label="搜索"><span class="DocSearch-Button-Container"><svg width="20" height="20" class="DocSearch-Search-Icon" viewBox="0 0 20 20" aria-hidden="true"><path d="M14.386 14.386l4.0877 4.0877-4.0877-4.0877c-2.9418 2.9419-7.7115 2.9419-10.6533 0-2.9419-2.9418-2.9419-7.7115 0-10.6533 2.9418-2.9419 7.7115-2.9419 10.6533 0 2.9419 2.9418 2.9419 7.7115 0 10.6533z" stroke="currentColor" fill="none" fill-rule="evenodd" stroke-linecap="round" stroke-linejoin="round"></path></svg><span class="DocSearch-Button-Placeholder">搜索</span></span><span class="DocSearch-Button-Keys"></span></button></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div></nav><div id="__docusaurus_skipToContent_fallback" class="main-wrapper mainWrapper_z2l0"><div class="docsWrapper_hBAB"><button aria-label="回到顶部" class="clean-btn theme-back-to-top-button backToTopButton_sjWU" type="button"></button><div class="docRoot_UBD9"><aside class="theme-doc-sidebar-container docSidebarContainer_YfHR"><div class="sidebarViewport_aRkj"><div class="sidebar_njMd"><nav aria-label="文档侧边栏" class="menu thin-scrollbar menu_SIkG"><ul class="theme-doc-sidebar-menu menu__list"><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" href="/light-docusaurus/docs/category/guide/">Guide</a><button aria-label="展开侧边栏分类 &#x27;Guide&#x27;" aria-expanded="false" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" href="/light-docusaurus/docs/category/develop-environment/">Develop Environment</a><button aria-label="展开侧边栏分类 &#x27;Develop Environment&#x27;" aria-expanded="false" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--active" href="/light-docusaurus/docs/category/java-jvm/">Java (JVM)</a><button aria-label="折叠侧边栏分类 &#x27;Java (JVM)&#x27;" aria-expanded="true" type="button" class="clean-btn menu__caret"></button></div><ul style="display:block;overflow:visible;height:auto" class="menu__list"><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/light-docusaurus/docs/zh-cn/java/Java-Concurrent-AbstractQueuedSynchronizer/">Java-Concurrent-AbstractQueuedSynchronizer</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/light-docusaurus/docs/zh-cn/java/Java-Concurrent-ReentrantLock/">Java-Concurrent-ReentrantLock</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/light-docusaurus/docs/zh-cn/java/Java-Concurrent-Semaphore/">Java-Concurrent-Semaphore</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/light-docusaurus/docs/zh-cn/java/Java-Concurrent-CountDownlatch/">Java-Concurrent-CountDownlatch</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/light-docusaurus/docs/zh-cn/java/Java-Concurrent-CyclicBarrier/">Java-Concurrent-CyclicBarrier</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link menu__link--active" aria-current="page" tabindex="0" href="/light-docusaurus/docs/zh-cn/java/Java-Concurrent-ConcurrentHashMap/">Java-Concurrent-ConcurrentHashMap</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/light-docusaurus/docs/zh-cn/java/Java-Concurrent-ThreadPoolExecutor/">Java-Concurrent-ThreadPoolExecutor</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/light-docusaurus/docs/zh-cn/java/AbstractQueuedSynchronizer-In-Action/">AbstractQueuedSynchronizer-In-Action</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/light-docusaurus/docs/zh-cn/java/CompletableFuture-Getting-Start/">CompletableFuture-Getting-Start</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/light-docusaurus/docs/zh-cn/java/CompletableFuture-Usage/">CompletableFuture-Usage</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/light-docusaurus/docs/zh-cn/java/CompletableFuture-In-Action/">CompletableFuture-In-Action</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/light-docusaurus/docs/zh-cn/java/Bytecode-Toolkit-Javassist/">Bytecode-Toolkit-Javassist</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/light-docusaurus/docs/zh-cn/java/GC-Exception-Analysis/">GC-Exception-Analysis</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/light-docusaurus/docs/zh-cn/java/Java-Instrumentation-JavaAgent/">Java-Instrumentation-JavaAgent</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/light-docusaurus/docs/zh-cn/java/JVM-Stack-And Heap-Dump/">JVM-Stack-And Heap-Dump</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/light-docusaurus/docs/zh-cn/java/Http-Client-Skip-Https-Check/">Http-Client-Skip-Https-Check</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/light-docusaurus/docs/zh-cn/java/Java-Error-Check/">Java-Error-Check</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/light-docusaurus/docs/zh-cn/java/Java-Agent-1/">Java-Agent-1</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/light-docusaurus/docs/zh-cn/java/Java-Lock/">Java-Lock</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/light-docusaurus/docs/zh-cn/java/Java-Generic-Type/">Java-Generic-Type</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/light-docusaurus/docs/zh-cn/java/Build-Native-Image-With-GraalVM/">Build-Native-Image-With-GraalVM</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/light-docusaurus/docs/zh-cn/java/Garbge-Collect-Algrthim/">Garbge-Collect-Algrthim</a></li></ul></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" href="/light-docusaurus/docs/category/spring-boot/">Spring Boot</a><button aria-label="展开侧边栏分类 &#x27;Spring Boot&#x27;" aria-expanded="false" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" href="/light-docusaurus/docs/category/spring-cloud/">Spring Cloud</a><button aria-label="展开侧边栏分类 &#x27;Spring Cloud&#x27;" aria-expanded="false" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" href="/light-docusaurus/docs/category/spring-security/">Spring Security</a><button aria-label="展开侧边栏分类 &#x27;Spring Security&#x27;" aria-expanded="false" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" href="/light-docusaurus/docs/category/spring-authorization-server/">Spring Authorization Server</a><button aria-label="展开侧边栏分类 &#x27;Spring Authorization Server&#x27;" aria-expanded="false" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" href="/light-docusaurus/docs/category/active-directory/">Active Directory</a><button aria-label="展开侧边栏分类 &#x27;Active Directory&#x27;" aria-expanded="false" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" href="/light-docusaurus/docs/category/database/">Database</a><button aria-label="展开侧边栏分类 &#x27;Database&#x27;" aria-expanded="false" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" href="/light-docusaurus/docs/category/git/">Git</a><button aria-label="展开侧边栏分类 &#x27;Git&#x27;" aria-expanded="false" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" href="/light-docusaurus/docs/category/linux/">Linux</a><button aria-label="展开侧边栏分类 &#x27;Linux&#x27;" aria-expanded="false" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" href="/light-docusaurus/docs/category/docker/">Docker</a><button aria-label="展开侧边栏分类 &#x27;Docker&#x27;" aria-expanded="false" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" href="/light-docusaurus/docs/category/kubernetes/">Kubernetes</a><button aria-label="展开侧边栏分类 &#x27;Kubernetes&#x27;" aria-expanded="false" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" href="/light-docusaurus/docs/category/test/">Test</a><button aria-label="展开侧边栏分类 &#x27;Test&#x27;" aria-expanded="false" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" href="/light-docusaurus/docs/category/others/">Others</a><button aria-label="展开侧边栏分类 &#x27;Others&#x27;" aria-expanded="false" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/light-docusaurus/docs/zh-cn/awesome-open-source/">Awesome open source</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/light-docusaurus/docs/zh-cn/windows/">Windows</a></li></ul></nav><button type="button" title="收起侧边栏" aria-label="收起侧边栏" class="button button--secondary button--outline collapseSidebarButton_PEFL"><svg width="20" height="20" aria-hidden="true" class="collapseSidebarButtonIcon_kv0_"><g fill="#7a7a7a"><path d="M9.992 10.023c0 .2-.062.399-.172.547l-4.996 7.492a.982.982 0 01-.828.454H1c-.55 0-1-.453-1-1 0-.2.059-.403.168-.551l4.629-6.942L.168 3.078A.939.939 0 010 2.528c0-.548.45-.997 1-.997h2.996c.352 0 .649.18.828.45L9.82 9.472c.11.148.172.347.172.55zm0 0"></path><path d="M19.98 10.023c0 .2-.058.399-.168.547l-4.996 7.492a.987.987 0 01-.828.454h-3c-.547 0-.996-.453-.996-1 0-.2.059-.403.168-.551l4.625-6.942-4.625-6.945a.939.939 0 01-.168-.55 1 1 0 01.996-.997h3c.348 0 .649.18.828.45l4.996 7.492c.11.148.168.347.168.55zm0 0"></path></g></svg></button></div></div></aside><main class="docMainContainer_TBSr"><div class="container padding-top--md padding-bottom--lg"><div class="row"><div class="col docItemCol_VOVn"><div class="docItemContainer_Djhp"><article><nav class="theme-doc-breadcrumbs breadcrumbsContainer_Z_bl" aria-label="页面路径"><ul class="breadcrumbs" itemscope="" itemtype="https://schema.org/BreadcrumbList"><li class="breadcrumbs__item"><a aria-label="主页面" class="breadcrumbs__link" href="/light-docusaurus/"><svg viewBox="0 0 24 24" class="breadcrumbHomeIcon_YNFT"><path d="M10 19v-5h4v5c0 .55.45 1 1 1h3c.55 0 1-.45 1-1v-7h1.7c.46 0 .68-.57.33-.87L12.67 3.6c-.38-.34-.96-.34-1.34 0l-8.36 7.53c-.34.3-.13.87.33.87H5v7c0 .55.45 1 1 1h3c.55 0 1-.45 1-1z" fill="currentColor"></path></svg></a></li><li itemscope="" itemprop="itemListElement" itemtype="https://schema.org/ListItem" class="breadcrumbs__item"><a class="breadcrumbs__link" itemprop="item" href="/light-docusaurus/docs/category/java-jvm/"><span itemprop="name">Java (JVM)</span></a><meta itemprop="position" content="1"></li><li itemscope="" itemprop="itemListElement" itemtype="https://schema.org/ListItem" class="breadcrumbs__item breadcrumbs__item--active"><span class="breadcrumbs__link" itemprop="name">Java-Concurrent-ConcurrentHashMap</span><meta itemprop="position" content="2"></li></ul></nav><div class="tocCollapsible_ETCw theme-doc-toc-mobile tocMobile_ITEo"><button type="button" class="clean-btn tocCollapsibleButton_TO0P">本页总览</button></div><div class="theme-doc-markdown markdown"><header><h1>Java-Concurrent-ConcurrentHashMap</h1></header><ul>
<li><a href="https://www.cnblogs.com/liuyun1995/p/8631264.html" target="_blank" rel="noopener noreferrer">Java并发系列[9]----ConcurrentHashMap源码分析</a></li>
</ul>
<p>我们知道哈希表是一种非常高效的数据结构，设计优良的哈希函数可以使其上的增删改查操作达到<code>O(1)</code>级别。Java为我们提供了一个现成的哈希结构，那就是<code>HashMap</code>类，在前面的文章中我曾经介绍过<code>HashMap</code>类，知道它的所有方法都未进行同步，因此在多线程环境中是不安全的。为此，Java为我们提供了另外一个<code>HashTable</code>类，它对于多线程同步的处理非常简单粗暴，那就是在<code>HashMap</code>的基础上对其所有方法都使用<code>synchronized</code>关键字进行加锁。这种方法虽然简单，但导致了一个问题，那就是在同一时间内只能由一个线程去操作哈希表。即使这些线程都只是进行读操作也必须要排队，这在竞争激烈的多线程环境中极为影响性能。本篇介绍的<code>ConcurrentHashMap</code>就是为了解决这个问题的，它的内部使用分段锁将锁进行细粒度化，从而使得多个线程能够同时操作哈希表，这样极大的提高了性能。下图是其内部结构的示意图。</p>
<p><img decoding="async" loading="lazy" alt="img" src="/light-docusaurus/assets/images/ConcurrentHashMap-1-d312947793fdf0b990570750e736a40f.png" width="589" height="917" class="img_ev3q"></p>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="1-concurrenthashmap有哪些成员变量">1. ConcurrentHashMap有哪些成员变量？<a href="#1-concurrenthashmap有哪些成员变量" class="hash-link" aria-label="1. ConcurrentHashMap有哪些成员变量？的直接链接" title="1. ConcurrentHashMap有哪些成员变量？的直接链接">​</a></h2>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">//默认初始化容量</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">static final int DEFAULT_INITIAL_CAPACITY = 16;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">//默认加载因子</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">static final float DEFAULT_LOAD_FACTOR = 0.75f;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">//默认并发级别</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">static final int DEFAULT_CONCURRENCY_LEVEL = 16;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">//集合最大容量</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">static final int MAXIMUM_CAPACITY = 1 &lt;&lt; 30;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">//分段锁的最小数量</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">static final int MIN_SEGMENT_TABLE_CAPACITY = 2;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">//分段锁的最大数量</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">static final int MAX_SEGMENTS = 1 &lt;&lt; 16;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">//加锁前的重试次数</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">static final int RETRIES_BEFORE_LOCK = 2;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">//分段锁的掩码值</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">final int segmentMask;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">//分段锁的移位值</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">final int segmentShift;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">//分段锁数组</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">final Segment&lt;K,V&gt;[] segments;</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>在阅读完本篇文章之前，相信读者不能理解这些成员变量的具体含义和作用，不过请读者们耐心看下去，后面将会在具体场景中一一介绍到这些成员变量的作用。在这里读者只需对这些成员变量留个眼熟即可。但是仍有个别变量是我们现在需要了解的，例如<code>Segment</code>数组代表分段锁集合，并发级别则代表分段锁的数量(也意味有多少线程可以同时操作)，初始化容量代表整个容器的容量，加载因子代表容器元素可以达到多满的一种程度。</p>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="2-分段锁的内部结构是怎样的">2. 分段锁的内部结构是怎样的？<a href="#2-分段锁的内部结构是怎样的" class="hash-link" aria-label="2. 分段锁的内部结构是怎样的？的直接链接" title="2. 分段锁的内部结构是怎样的？的直接链接">​</a></h2>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">//分段锁</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">static final class Segment&lt;K,V&gt; extends ReentrantLock implements Serializable {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //自旋最大次数</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    static final int MAX_SCAN_RETRIES = Runtime.getRuntime().availableProcessors() &gt; 1 ? 64 : 1;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //哈希表</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    transient volatile HashEntry&lt;K,V&gt;[] table;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //元素总数</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    transient int count;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //修改次数</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    transient int modCount;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //元素阀值</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    transient int threshold;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //加载因子</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    final float loadFactor;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //省略以下内容</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    ...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p><code>Segment</code>是<code>ConcurrentHashMap</code>的静态内部类，可以看到它继承自ReentrantLock，因此它在本质上是一个锁。它在内部持有一个<code>HashEntry</code>数组(哈希表)，并且保证所有对该数组的增删改查方法都是线程安全的，具体是怎样实现的后面会讲到。所有对<code>ConcurrentHashMap</code>的增删改查操作都可以委托<code>Segment</code>来进行，因此<code>ConcurrentHashMap</code>能够保证在多线程环境下是安全的。又因为不同的<code>Segment</code>是不同的锁，所以多线程可以同时操作不同的<code>Segment</code>，也就意味着多线程可以同时操作<code>ConcurrentHashMap</code>，这样就能避免<code>HashTable</code>的缺陷，从而极大的提高性能。</p>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="3-concurrenthashmap初始化时做了些什么">3. ConcurrentHashMap初始化时做了些什么？<a href="#3-concurrenthashmap初始化时做了些什么" class="hash-link" aria-label="3. ConcurrentHashMap初始化时做了些什么？的直接链接" title="3. ConcurrentHashMap初始化时做了些什么？的直接链接">​</a></h2>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">//核心构造器</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">@SuppressWarnings(&quot;unchecked&quot;)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public ConcurrentHashMap(int initialCapacity, float loadFactor, int concurrencyLevel) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (!(loadFactor &gt; 0) || initialCapacity &lt; 0 || concurrencyLevel &lt;= 0) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        throw new IllegalArgumentException();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //确保并发级别不大于限定值</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (concurrencyLevel &gt; MAX_SEGMENTS) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        concurrencyLevel = MAX_SEGMENTS;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    int sshift = 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    int ssize = 1;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //保证ssize为2的幂, 且是最接近的大于等于并发级别的数</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    while (ssize &lt; concurrencyLevel) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        ++sshift;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        ssize &lt;&lt;= 1;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //计算分段锁的移位值</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    this.segmentShift = 32 - sshift;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //计算分段锁的掩码值</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    this.segmentMask = ssize - 1;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //总的初始容量不能大于限定值</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (initialCapacity &gt; MAXIMUM_CAPACITY) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        initialCapacity = MAXIMUM_CAPACITY;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //获取每个分段锁的初始容量</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    int c = initialCapacity / ssize;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //分段锁容量总和不小于初始总容量</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (c * ssize &lt; initialCapacity) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        ++c;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    int cap = MIN_SEGMENT_TABLE_CAPACITY;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //保证cap为2的幂, 且是最接近的大于等于c的数</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    while (cap &lt; c) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        cap &lt;&lt;= 1;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //新建一个Segment对象模版</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Segment&lt;K,V&gt; s0 = new Segment&lt;K,V&gt;(loadFactor, (int)(cap * loadFactor), (HashEntry&lt;K,V&gt;[])new HashEntry[cap]);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //新建指定大小的分段锁数组</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Segment&lt;K,V&gt;[] ss = (Segment&lt;K,V&gt;[])new Segment[ssize];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //使用UnSafe给数组第0个元素赋值</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    UNSAFE.putOrderedObject(ss, SBASE, s0);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    this.segments = ss;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p><code>ConcurrentHashMap</code>有多个构造器，但是上面贴出的是它的核心构造器，其他构造器都通过调用它来完成初始化。核心构造器需要传入三个参数，分别是初始容量，加载因子和并发级别。在前面介绍成员变量时我们可以知道默认的初始容量为16，加载因子为0.75f，并发级别为16。现在我们看到核心构造器的代码，首先是通过传入的<code>concurrencyLevel</code>来计算出<code>ssize</code>，<code>ssize</code>是<code>Segment</code>数组的长度，它必须保证是2的幂，这样就可以通过<code>hash&amp;ssize-1</code>来计算分段锁在数组中的下标。由于传入的<code>concurrencyLevel</code>不能保证是2的幂，所以不能直接用它来当作<code>Segment</code>数组的长度，因此我们要找到一个最接近<code>concurrencyLevel</code>的2的幂，用它来作为数组的长度。假如现在传入的<code>concurrencyLevel=15</code>，通过上面代码可以计算出<code>ssize=16</code>，<code>sshift=4</code>。接下来立马可以算出<code>segmentShift=16，segmentMask=15</code>。注意这里的<code>segmentShift</code>是分段锁的移位值，<code>segmentMask</code>是分段锁的掩码值，这两个值是用来计算分段锁在数组中的下标，在下面我们会讲到。在算出分段锁的个数<code>ssize</code>之后，就可以根据传入的总容量来计算每个分段锁的容量，它的值<code>c = initialCapacity / ssize</code>。分段锁的容量也就是<code>HashEntry</code>数组的长度，同样也必须保证是2的幂，而上面算出的c的值不能保证这一点，所以不能直接用c作为<code>HashEntry</code>数组的长度，需要另外找到一个最接近c的2的幂，将这个值赋给cap，然后用cap来作为<code>HashEntry</code>数组的长度。现在我们有了<code>ssize</code>和<code>cap</code>，就可以新建分段锁数组Segment[]和元素数组<code>HashEntry[]</code>了。注意，与JDK1.6不同是的，在JDK1.7中只新建了<code>Segment</code>数组，并没有对它初始化，初始化Segment的操作留到了插入操作时进行。</p>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="4-通过怎样的方式来定位锁和定位元素">4. 通过怎样的方式来定位锁和定位元素？<a href="#4-通过怎样的方式来定位锁和定位元素" class="hash-link" aria-label="4. 通过怎样的方式来定位锁和定位元素？的直接链接" title="4. 通过怎  样的方式来定位锁和定位元素？的直接链接">​</a></h2>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">//根据哈希码获取分段锁</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">@SuppressWarnings(&quot;unchecked&quot;)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">private Segment&lt;K,V&gt; segmentForHash(int h) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    long u = (((h &gt;&gt;&gt; segmentShift) &amp; segmentMask) &lt;&lt; SSHIFT) + SBASE;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    return (Segment&lt;K,V&gt;) UNSAFE.getObjectVolatile(segments, u);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">//根据哈希码获取元素</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">@SuppressWarnings(&quot;unchecked&quot;)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">static final &lt;K,V&gt; HashEntry&lt;K,V&gt; entryForHash(Segment&lt;K,V&gt; seg, int h) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    HashEntry&lt;K,V&gt;[] tab;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    return (seg == null || (tab = seg.table) == null) ? null :</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    (HashEntry&lt;K,V&gt;) UNSAFE.getObjectVolatile(tab, ((long)(((tab.length - 1) &amp; h)) &lt;&lt; TSHIFT) + TBASE);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>在JDK1.7中是通过<code>UnSafe</code>来获取数组元素的，因此这里比JDK1.6多了些计算数组元素偏移量的代码，这些代码我们暂时不关注，现在我们只需知道下面这两点：
a. 通过哈希码计算分段锁在数组中的下标：<code>(h &gt;&gt;&gt; segmentShift) &amp; segmentMask</code>。
b. 通过哈希码计算元素在数组中的下标：<code>(tab.length - 1) &amp; h</code>。
现在我们假设传给构造器的两个参数为<code>initialCapacity=128, concurrencyLevel=16</code>。根据计算可以得到<code>ssize=16, sshift=4，segmentShift=28，segmentMask=15</code>。同样，算得每个分段锁内的<code>HashEntry</code>数组的长度为8，所以<code>tab.length-1=7</code>。根据这些值，我们通过下图来解释如何根据同一个哈希码来定位分段锁和元素。</p>
<p><img decoding="async" loading="lazy" alt="img" src="data:image/png;base64,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" width="834" height="274" class="img_ev3q"></p>
<p>可以看到分段锁和元素的定位都是通过元素的哈希码来决定的。定位分段锁是取哈希码的高位值(从32位处取起)，定位元素是取的哈希码的低位值。现在有个问题，它们一个从32位的左端取起，一个从32位的右端取起，那么会在某个时刻产生冲突吗？我们在成员变量里可以找到<code>MAXIMUM_CAPACITY = 1 &lt;&lt; 30</code>，<code>MAX_SEGMENTS = 1 &lt;&lt; 16</code>，这说明定位分段锁和定位元素使用的总的位数不超过30，并且定位分段锁使用的位数不超过16，所以至少还隔着2位的空余，因此是不会产生冲突的。</p>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="5-查找元素具体是怎样实现的">5. 查找元素具体是怎样实现的？<a href="#5-查找元素具体是怎样实现的" class="hash-link" aria-label="5. 查找元素具体是怎样实现的？的直接链接" title="5. 查找元素具体是怎样实现的？的直接链接">​</a></h2>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">//根据key获取value</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public V get(Object key) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Segment&lt;K,V&gt; s;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    HashEntry&lt;K,V&gt;[] tab;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //使用哈希函数计算哈希码</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    int h = hash(key);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //根据哈希码计算分段锁的索引</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    long u = (((h &gt;&gt;&gt; segmentShift) &amp; segmentMask) &lt;&lt; SSHIFT) + SBASE;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //获取分段锁和对应的哈希表</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if ((s = (Segment&lt;K,V&gt;)UNSAFE.getObjectVolatile(segments, u)) != null &amp;&amp; (tab = s.table) != null) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        //根据哈希码获取链表头结点, 再对链表进行遍历</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        for (HashEntry&lt;K,V&gt; e = (HashEntry&lt;K,V&gt;) UNSAFE.getObjectVolatile</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                 (tab, ((long)(((tab.length - 1) &amp; h)) &lt;&lt; TSHIFT) + TBASE);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">             e != null; e = e.next) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            K k;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            //根据key和hash找到对应元素后返回value值</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            if ((k = e.key) == key || (e.hash == h &amp;&amp; key.equals(k))) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                return e.value;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    return null;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>在JDK1.6中分段锁的get方法是通过下标来访问数组元素的，而在JDK1.7中是通过<code>UnSafe</code>的<code>getObjectVolatile</code>方法来读取数组中的元素。为啥要这样做？我们知道虽然<code>Segment</code>对象持有的<code>HashEntry</code>数组引用是<code>volatile</code>类型的，但是数组内的元素引用不是<code>volatile</code>类型的，因此多线程对数组元素的修改是不安全的，可能会在数组中读取到尚未构造完成的对象。在JDK1.6中是通过第二次加锁读取来保证安全的，而JDK1.7中通过<code>UnSafe</code>的<code>getObjectVolatile</code>方法来读取同样也是为了保证这一点。使用<code>getObjectVolatile</code>方法读取数组元素需要先获得元素在数组中的偏移量，在这里根据哈希码计算得到分段锁在数组中的偏移量为u，然后通过偏移量u来尝试读取分段锁。由于分段锁数组在构造时没进行初始化，因此可能读出来一个空值，所以需要先进行判断。在确定  分段锁和它内部的哈希表都不为空之后，再通过哈希码读取<code>HashEntry</code>数组的元素，根据上面的结构图可以看到，这时获得的是链表的头结点。之后再从头到尾的对链表进行遍历查找，如果找到对应的值就将其返回，否则就返回null。以上就是整个查找元素的过程。</p>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="6-插入元素具体是怎样实现的">6. 插入元素具体是怎样实现的？<a href="#6-插入元素具体是怎样实现的" class="hash-link" aria-label="6. 插入元素具体是怎样实现的？的直接链接" title="6. 插入元素具体是怎样实现的？的直接链接">​</a></h2>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">//向集合添加键值对(若存在则替换)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">@SuppressWarnings(&quot;unchecked&quot;)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public V put(K key, V value) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Segment&lt;K,V&gt; s;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //传入的value不能为空</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (value == null) throw new NullPointerException();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //使用哈希函数计算哈希码</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    int hash = hash(key);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //根据哈希码计算分段锁的下标</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    int j = (hash &gt;&gt;&gt; segmentShift) &amp; segmentMask;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //根据下标去尝试获取分段锁</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if ((s = (Segment&lt;K,V&gt;)UNSAFE.getObject(segments, (j &lt;&lt; SSHIFT) + SBASE)) == null) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        //获得的分段锁为空就去构造一个</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        s = ensureSegment(j);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //调用分段锁的put方法</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    return s.put(key, hash, value, false);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">//向集合添加键值对(不存在才添加)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">@SuppressWarnings(&quot;unchecked&quot;)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public V putIfAbsent(K key, V value) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Segment&lt;K,V&gt; s;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //传入的value不能为空</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (value == null) throw new NullPointerException();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //使用哈希函数计算哈希码</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    int hash = hash(key);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //根据哈希码计算分段锁的下标</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    int j = (hash &gt;&gt;&gt; segmentShift) &amp; segmentMask;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //根据下标去尝试获取分段锁</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if ((s = (Segment&lt;K,V&gt;)UNSAFE.getObject(segments, (j &lt;&lt; SSHIFT) + SBASE)) == null) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        //获得的分段锁为空就去构造一个</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        s = ensureSegment(j);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //调用分段锁的put方法</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    return s.put(key, hash, value, true);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p><code>ConcurrentHashMap</code>中有两个添加键值对的方法，通过put方法添加时如果存在则会进行覆盖，通过<code>putIfAbsent</code>方法添加时如果存在则不进行覆盖，这两个方法都是调用分段锁的<code>put</code>方法来完成操作，只是传入的最后一个参数不同而已。在上面代码中我们可以看到首先是根据key的哈希码来计算出分段锁在数组中的下标，然后根据下标使用<code>UnSafe</code>类<code>getObject</code>方法来读取分段锁。由于在构造<code>ConcurrentHashMap</code>时没有对<code>Segment</code>数组中的元素初始化，所以可能读到一个空值，这时会先通过ensureSegment方法新建一个分段锁。获取到分段锁之后再调用它的<code>put</code>方法完成添加操作，下面我们来看看具体是怎样操作的。</p>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">//添加键值对</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">final V put(K key, int hash, V value, boolean onlyIfAbsent) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //尝试获取锁, 若失败则进行自旋</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    HashEntry&lt;K,V&gt; node = tryLock() ? null : scanAndLockForPut(key, hash, value);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    V oldValue;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    try {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        HashEntry&lt;K,V&gt;[] tab = table;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        //计算元素在数组中的下标</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        int index = (tab.length - 1) &amp; hash;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        //根据下标获取链表头结点</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        HashEntry&lt;K,V&gt; first = entryAt(tab, index);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        for (HashEntry&lt;K,V&gt; e = first;;) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            //遍历链表寻找该元素, 找到则进行替换</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            if (e != null) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                K k;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                if ((k = e.key) == key || (e.hash == hash &amp;&amp; key.equals(k))) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    oldValue = e.value;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    //根据参数决定是否替换旧值</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    if (!onlyIfAbsent) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        e.value = value;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        ++modCount;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    break;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                e = e.next;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            //没找到则在链表添加一个结点</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            } else {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                //将node结点插入链表头部</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                if (node != null) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    node.setNext(first);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                } else {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    node = new HashEntry&lt;K,V&gt;(hash, key, value, first);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                //插入结点后将元素总是加1</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                int c = count + 1;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                //元素超过阀值则进行扩容</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                if (c &gt; threshold &amp;&amp; tab.length &lt; MAXIMUM_CAPACITY) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    rehash(node);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                //否则就将哈希表指定下标替换为node结点</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                } else {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    setEntryAt(tab, index, node);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                ++modCount;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                count = c;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                oldValue = null;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                break;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    } finally {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        unlock();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    return oldValue;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>为保证线程安全，分段锁中的put操作是需要进行加锁的，所以线程一开始就会去获取锁，如果获取成功就继续执行，若获取失败则调用<code>scanAndLockForPut</code>方法进行自旋，在自旋过程中会先去扫描哈希表去查找指定的key，如果key不存在就会新建一个<code>HashEntry</code>返回，这样在获取到锁之后就不必再去新建了，为的是在等待锁的过程中顺便做些事情，不至于白白浪费时间，可见作者的良苦用心。具体自旋方法我们后面再细讲，现在先把关注点拉回来，线程在成功获取到锁之后会根据计算到的下标，获取指定下标的元素。此时获取到的是链表的头结点，如果头结点不为空就对链表进行遍历查找，找到之后再根据<code>onlyIfAbsent</code>参数的值决定是否进行替换。如果遍历没找到就会新建一个<code>HashEntry</code>指向头结点，此时如果自旋时创建了<code>HashEntry</code>，则直接将它的<code>next</code>指向当前头结点，如果自旋时没有创建就在这里新建一个<code>HashEntry</code>并指向头结点。在向链表添加元素之后检查元素总数是否超过阀值，如果超过就调用<code>rehash</code>进行扩容，没超过的话就直接将数组对应下标的元素引用指向新添加的node。setEntryAt方法内部是通过调用<code>UnSafe</code>的<code>putOrderedObject</code>方法来更改数组元素引用的，这样就保证了其他线程在读取时可以读到最新的值。</p>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="7-删除元素具体是怎样实现的">7. 删除元素具体是怎样实现的？<a href="#7-删除元素具体是怎样实现的" class="hash-link" aria-label="7. 删除元素具体是怎样实现的？的直接链接" title="7. 删除元素具体是怎样实现的？的直接链接">​</a></h2>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">//删除指定元素(找到对应元素后直接删除)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public V remove(Object key) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //使用哈希函数计算哈希码</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    int hash = hash(key);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //根据哈希码获取分段锁的索引</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Segment&lt;K,V&gt; s = segmentForHash(hash);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //调用分段锁的remove方法</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    return s == null ? null : s.remove(key, hash, null);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">//删除指定元素(查找值等于给定值才删除)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public boolean remove(Object key, Object value) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //使用哈希函数计算哈希码</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    int hash = hash(key);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Segment&lt;K,V&gt; s;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //确保分段锁不为空才调用remove方法</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    return value != null &amp;&amp; (s = segmentForHash(hash)) != null &amp;&amp; s.remove(key, hash, value) != null;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>ConcurrentHashMap提供了两种删除操作，一种是找到后直接删除，一种是找到后先比较再删除。这 两种删除方法都是先根据<code>key</code>的哈希码找到对应的分段锁后，再通过调用分段锁的<code>remove</code>方法完成删除操作。下面我们来看看分段锁的<code>remove</code>方法。</p>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">//删除指定元素</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">final V remove(Object key, int hash, Object value) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //尝试获取锁, 若失败则进行自旋</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (!tryLock()) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        scanAndLock(key, hash);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    V oldValue = null;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    try {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        HashEntry&lt;K,V&gt;[] tab = table;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        //计算元素在数组中的下标</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        int index = (tab.length - 1) &amp; hash;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        //根据下标取得数组元素(链表头结点)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        HashEntry&lt;K,V&gt; e = entryAt(tab, index);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        HashEntry&lt;K,V&gt; pred = null;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        //遍历链表寻找要删除的元素</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        while (e != null) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            K k;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            //next指向当前结点的后继结点</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            HashEntry&lt;K,V&gt; next = e.next;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            //根据key和hash寻找对应结点</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            if ((k = e.key) == key || (e.hash == hash &amp;&amp; key.equals(k))) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                V v = e.value;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                //传入的value不等于v就跳过, 其他情况就进行删除操作</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                if (value == null || value == v || value.equals(v)) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    //如果pred为空则代表要删除的结点为头结点</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    if (pred == null) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        //重新设置链表头结点</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        setEntryAt(tab, index, next);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    } else {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        //设置pred结点的后继为next结点</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        pred.setNext(next);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    ++modCount;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    --count;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    //记录元素删除之前的值</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    oldValue = v;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                break;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            //若e不是要找的结点就将pred引用指向它</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            pred = e;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            //检查下一个结点</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            e = next;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    } finally {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        unlock();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    return oldValue;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>在删除分段锁中的元素时需要先获取锁，如果获取失败就调用<code>scanAndLock</code>方法进行自旋，如果获取成功就执行下一步，首先计算数组下标然后通过下标获取<code>HashEntry</code>数组的元素，这里获得了链表的头结点，接下来就是对链表进行遍历查找，在此之前先用<code>next</code>指针记录当前结点的后继结点，然后对比key和hash看看是否是要找的结点，如果是的话就执行下一个if判断。满足<code>value</code>为空或者<code>value</code>的值等于结点当前值这两个条件就会进入到if语句中进行删除操作，否则直接跳过。在if语句中执行删除操作时会有两种情况，如果当前  结点为头结点则直接将<code>next</code>结点设置为头结点，如果当前结点不是头结点则将pred结点的后继设置为<code>next</code>结点。这里的pred结点表示当前结点的前继结点，每次在要检查下一个结点之前就将pred指向当前结点，这就保证了pred结点总是当前结点的前继结点。注意，与JDK1.6不同，在JDK1.7中<code>HashEntry</code>对象的<code>next</code>变量不是final的，因此这里可以通过直接修改<code>next</code>引用的值来删除元素，由于<code>next</code>变量是<code>volatile</code>类型的，所以读线程可以马上读到最新的值。</p>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="8-替换元素具体是怎样实现的">8. 替换元素具体是怎样实现的？<a href="#8-替换元素具体是怎样实现的" class="hash-link" aria-label="8. 替换元素具体是怎样实现的？的直接链接" title="8. 替换元素具体是怎样实现的？的直接链接">​</a></h2>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">//替换指定元素(CAS操作)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public boolean replace(K key, V oldValue, V newValue) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //使用哈希函数计算哈希码</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    int hash = hash(key);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //保证oldValue和newValue不为空</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (oldValue == null || newValue == null) throw new NullPointerException();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //根据哈希码获取分段锁的索引</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Segment&lt;K,V&gt; s = segmentForHash(hash);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //调用分段锁的replace方法</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    return s != null &amp;&amp; s.replace(key, hash, oldValue, newValue);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">//替换元素操作(CAS操作)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">final boolean replace(K key, int hash, V oldValue, V newValue) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //尝试获取锁, 若失败则进行自旋</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (!tryLock()) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        scanAndLock(key, hash);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    boolean replaced = false;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    try {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        HashEntry&lt;K,V&gt; e;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        //通过hash直接找到头结点然后对链表遍历</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        for (e = entryForHash(this, hash); e != null; e = e.next) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            K k;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            //根据key和hash找到要替换的结点</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            if ((k = e.key) == key || (e.hash == hash &amp;&amp; key.equals(k))) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                //如果指定的当前值正确则进行替换</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                if (oldValue.equals(e.value)) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    e.value = newValue;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    ++modCount;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    replaced = true;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                //否则不进行任何操作直接返回</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                break;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    } finally {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        unlock();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    return replaced;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p><code>ConcurrentHashMap</code>同样提供了两种替换操作，一种是找到后直接替换，另一种是找到后先比较再替换(CAS操作)。这两种操作的实现大致是相同的，只是CAS操作在替换前多了一层比较操作，因此我们只需简单了解其中一种操作即可。这里拿CAS操作进行分析，还是老套路，首先根据key的哈希码找到对应的分段锁，然后调用它的<code>replace</code>方法。进入分段锁中的<code>replace</code>方法后需要先去获取锁，如果获取失败则进行自旋，如果获取成功则进行下一步。首先根据<code>hash</code>码获取链表头结点，然后根据<code>key</code>和<code>hash</code>进行遍历查找，找到了对应的元素之后，比较给定的<code>oldValue</code>是否是当前值，如果不是则放弃修改，如果是则用新值进行替换。由于<code>HashEntry</code>对象的value域是<code>volatile</code>类型的，因此可以直接替换。</p>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="9-自旋时具体做了些什么">9. 自旋时具体做了些什么？<a href="#9-自旋时具体做了些什么" class="hash-link" aria-label="9. 自旋时具体做了些什么？的直接链接" title="9. 自旋时具体做了些什么？的直接链接">​</a></h2>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">//自旋等待获取锁(put操作)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">private HashEntry&lt;K,V&gt; scanAndLockForPut(K key, int hash, V value) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //根据哈希码获取头结点</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    HashEntry&lt;K,V&gt; first = entryForHash(this, hash);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    HashEntry&lt;K,V&gt; e = first;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    HashEntry&lt;K,V&gt; node = null;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    int retries = -1;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //在while循环内自旋</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    while (!tryLock()) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        HashEntry&lt;K,V&gt; f;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (retries &lt; 0) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            //如果头结点为空就新建一个node</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            if (e == null) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                if (node == null) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    node = new HashEntry&lt;K,V&gt;(hash, key, value, null);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                retries = 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            //否则就遍历链表定位该结点</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            } else if (key.equals(e.key)) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                retries = 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            } else {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                e = e.next;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">          //retries每次在这加1, 并判断是否超过最大值</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        } else if (++retries &gt; MAX_SCAN_RETRIES) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            lock();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            break;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">          //retries为偶数时去判断first有没有改变</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        } else if ((retries &amp; 1) == 0 &amp;&amp; (f = entryForHash(this, hash)) != first) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            e = first = f;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            retries = -1;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    return node;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">//自旋等待获取锁(remove和replace操作)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">private void scanAndLock(Object key, int hash) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //根据哈希码获取链表头结点</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    HashEntry&lt;K,V&gt; first = entryForHash(this, hash);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    HashEntry&lt;K,V&gt; e = first;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    int retries = -1;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //在while循环里自旋</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    while (!tryLock()) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        HashEntry&lt;K,V&gt; f;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (retries &lt; 0) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            //遍历链表定位到该结点</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            if (e == null || key.equals(e.key)) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                retries = 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            } else {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                e = e.next;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">          //retries每次在这加1, 并判断是否超过最大值</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        } else if (++retries &gt; MAX_SCAN_RETRIES) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            lock();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            break;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">          //retries为偶数时去判断first有没有改变</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        } else if ((retries &amp; 1) == 0 &amp;&amp; (f = entryForHash(this, hash)) != first) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            e = first = f;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            retries = -1;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>在前面我们讲到过，分段锁中的<code>put</code>，<code>remove</code>，<code>replace</code>这些操作都会要求先去获取锁，只有成功获得锁之后才能进行下一步操作，如果获取失败就会进行自旋。自旋操作也是在JDK1.7中添加的，为了避免线程频繁的挂起和唤醒，以此提高并发操作时的性能。在<code>put</code>方法中调用的是<code>scanAndLockForPut</code>，在<code>remove</code>和<code>replace</code>方法中调用的是<code>scanAndLock</code>。这两种自旋方法大致是相同的，这里我们只分析<code>scanAndLockForPut</code>方法。首先还是先根据<code>hash</code>码获得链表头结点，之后线程会进入<code>while</code>循环中执行，退出该循环的唯一方式是成功获取锁，而在这期间线程不会被挂起。刚进入循环时<code>retries</code>的值为-1，这时线程不会马上再去尝试获取锁，而是先去寻找到key对应的结点(没找到会新建一个)，然后再将<code>retries</code>设为0，接下来就会一次次的尝试获取锁，对应<code>retries</code>的值也会每次加1，直到超过最大尝试次数如果还没获取到锁，就会调用lock方法进行阻塞获取。在尝试获取锁的期间，还会每隔一次(<code>retries</code>为偶数)去检查头结点是否被改变，如果被改变则将<code>retries</code>重置回-1，然后再重走一遍刚才的流程。这就是线程自旋时所做的操作，需注意的是如果在自旋时检测到头结点已被改变，则会延长线程的自旋时间。</p>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="10-哈希表扩容时都做了哪些操作">10. 哈希表扩容时都做了哪些操作？<a href="#10-哈希表扩容时都做了哪些操作" class="hash-link" aria-label="10. 哈希表扩容时都做了哪些操作？的直接链接" title="10. 哈希表扩容时都做了哪些操作？的直接链接">​</a></h2>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">//再哈希</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">@SuppressWarnings(&quot;unchecked&quot;)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">private void rehash(HashEntry&lt;K,V&gt; node) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //获取旧哈希表的引用</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    HashEntry&lt;K,V&gt;[] oldTable = table;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //获取旧哈希表的容量</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    int oldCapacity = oldTable.length;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //计算新哈希表的容量(为旧哈希表的2倍)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    int newCapacity = oldCapacity &lt;&lt; 1;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //计算新的元素阀值</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    threshold = (int)(newCapacity * loadFactor);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //新建一个HashEntry数组</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    HashEntry&lt;K,V&gt;[] newTable = (HashEntry&lt;K,V&gt;[]) new HashEntry[newCapacity];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //生成新的掩码值</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    int sizeMask = newCapacity - 1;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //遍历旧表的所有元素</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    for (int i = 0; i &lt; oldCapacity ; i++) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        //取得链表头结点</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        HashEntry&lt;K,V&gt; e = oldTable[i];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (e != null) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            HashEntry&lt;K,V&gt; next = e.next;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            //计算元素在新表中的索引</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            int idx = e.hash &amp; sizeMask;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            //next为空表明链表只有一个结点</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            if (next == null) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                //直接把该结点放到新表中</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                newTable[idx] = e;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }else {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                HashEntry&lt;K,V&gt; lastRun = e;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                int lastIdx = idx;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                //定位lastRun结点, 将lastRun之后的结点直接放到新表中</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                for (HashEntry&lt;K,V&gt; last = next; last != null; last = last.next) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    int k = last.hash &amp; sizeMask;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    if (k != lastIdx) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        lastIdx = k;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        lastRun = last;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                newTable[lastIdx] = lastRun;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                //遍历在链表lastRun结点之前的元素, 将它们依次复制到新表中</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                for (HashEntry&lt;K,V&gt; p = e; p != lastRun; p = p.next) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    V v = p.value;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    int h = p.hash;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    int k = h &amp; sizeMask;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    HashEntry&lt;K,V&gt; n = newTable[k];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    newTable[k] = new HashEntry&lt;K,V&gt;(h, p.key, v, n);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //计算传入结点在新表中的下标</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    int nodeIndex = node.hash &amp; sizeMask;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //将传入结点添加到链表头结点</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    node.setNext(newTable[nodeIndex]);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //将新表指定下标元素换成传入结点</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    newTable[nodeIndex] = node;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //将哈希表引用指向新表</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    table = newTable;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p><code>rehash</code>方法在<code>put</code>方法中被调用，我们知道在<code>put</code>方法时会新建元素并添加到哈希数组中，随着元素的增多发生哈希冲突的可能性越大，哈希表的性能也会随之下降。因此每次<code>put</code>操作时都会检查元素总数是否超过阀值，如果超过则调用rehash方法进行扩容。因为数组长度一旦确定则不能再被改变，因此需要新建一个数组来替换原先的数组。从代码中可以知道新创建的数组长度为原数组的2倍(<code>oldCapacity &lt;&lt; 1</code>)。创建好新数组后需要将旧数组中的所有元素移到新数组中，因此需要计算每个元素在新数组中的下标。计算新下标的过程如下图所示。</p>
<p><img decoding="async" loading="lazy" alt="img" src="data:image/png;base64,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" width="763" height="184" class="img_ev3q"></p>
<p>我们知道下标直接取的是哈希码的后几位，由于新数组的容量是直接用旧数组容量右移1位得来的，因此掩码位数向右增加1位，取到的哈希码位数也向右增加1位。如上图，若旧的掩码值为111，则元素下标为101，扩容后新的掩码值为1111，则计算出元素的新下标为0101。由于同一条链表上的元素下标是相同的，现在假设链表所有元素的下标为101，在扩容后该链表元素的新下标只有0101或1101这两种情况，因此数组扩容会打乱原先的链表并将链表元素分成两批。在计算出新下标后需要将元素移动到新数组中，在<code>HashMap</code>中通过直接修改<code>next</code>引用导致了多线程的死锁。虽然在<code>ConcurrentHashMap</code>中通过加锁避免了这种情况，但是我们知道<code>next</code>域是<code>volatile</code>类型的，它的改动能立马被读线程读取到，因此为保证线程安全采用复制元素来迁移数组。但是对链表中每个元素都进行复制有点影响性能，作者发现链表尾部有许多元素的<code>next</code>是不变的，它们在新数组中的下标是相同的，因此可以考虑整体移动这部分元素。具统计实际操作中只有<code>1/6</code>的元素是必须复制的，所以整体移动链表尾部元素(<code>lastRun</code>后面的元素)是可以提升一定性能的。</p>
<p><strong>注：</strong> 本篇文章基于JDK1.7版本。</p></div><footer class="theme-doc-footer docusaurus-mt-lg"><div class="row margin-top--sm theme-doc-footer-edit-meta-row"><div class="col"><a href="https://github.com/lorchr/light-docusaurus/tree/main/docs/zh-cn/java/6-Java-Concurrent-ConcurrentHashMap.md" target="_blank" rel="noopener noreferrer" class="theme-edit-this-page"><svg fill="currentColor" height="20" width="20" viewBox="0 0 40 40" class="iconEdit_Z9Sw" aria-hidden="true"><g><path d="m34.5 11.7l-3 3.1-6.3-6.3 3.1-3q0.5-0.5 1.2-0.5t1.1 0.5l3.9 3.9q0.5 0.4 0.5 1.1t-0.5 1.2z m-29.5 17.1l18.4-18.5 6.3 6.3-18.4 18.4h-6.3v-6.2z"></path></g></svg>编辑此页</a></div><div class="col lastUpdated_JAkA"></div></div></footer></article><nav class="pagination-nav docusaurus-mt-lg" aria-label="文件选项卡"><a class="pagination-nav__link pagination-nav__link--prev" href="/light-docusaurus/docs/zh-cn/java/Java-Concurrent-CyclicBarrier/"><div class="pagination-nav__sublabel">上一页</div><div class="pagination-nav__label">Java-Concurrent-CyclicBarrier</div></a><a class="pagination-nav__link pagination-nav__link--next" href="/light-docusaurus/docs/zh-cn/java/Java-Concurrent-ThreadPoolExecutor/"><div class="pagination-nav__sublabel">下一页</div><div class="pagination-nav__label">Java-Concurrent-ThreadPoolExecutor</div></a></nav></div></div><div class="col col--3"><div class="tableOfContents_bqdL thin-scrollbar theme-doc-toc-desktop"><ul class="table-of-contents table-of-contents__left-border"><li><a href="#1-concurrenthashmap有哪些成员变量" class="table-of-contents__link toc-highlight">1. ConcurrentHashMap有哪些成员变量？</a></li><li><a href="#2-分段锁的内部结构是怎样的" class="table-of-contents__link toc-highlight">2. 分段锁的内部结构是怎样的？</a></li><li><a href="#3-concurrenthashmap初始化时做了些什么" class="table-of-contents__link toc-highlight">3. ConcurrentHashMap初始化时做了些什么？</a></li><li><a href="#4-通过怎样的方式来定位锁和定位元素" class="table-of-contents__link toc-highlight">4. 通过怎样的方式来定位锁和定位元素？</a></li><li><a href="#5-查找元素具体是怎样实现的" class="table-of-contents__link toc-highlight">5. 查找元素具体是怎样实现的？</a></li><li><a href="#6-插入元素具体是怎样实现的" class="table-of-contents__link toc-highlight">6. 插入元素具体是怎样实现的？</a></li><li><a href="#7-删除元素具体是怎样实现的" class="table-of-contents__link toc-highlight">7. 删除元素具体 是怎样实现的？</a></li><li><a href="#8-替换元素具体是怎样实现的" class="table-of-contents__link toc-highlight">8. 替换元素具体是怎样实现的？</a></li><li><a href="#9-自旋时具体做了些什么" class="table-of-contents__link toc-highlight">9. 自旋时具体做了些什么？</a></li><li><a href="#10-哈希表扩容时都做了哪些操作" class="table-of-contents__link toc-highlight">10. 哈希表扩容时都做了哪些操作？</a></li></ul></div></div></div></div></main></div></div></div><footer class="footer footer--dark"><div class="container container-fluid"><div class="row footer__links"><div class="col footer__col"><div class="footer__title">Docs</div><ul class="footer__items clean-list"><li class="footer__item"><a class="footer__link-item" href="/light-docusaurus/docs/category/guide/">Torch</a></li><li class="footer__item"><a class="footer__link-item" href="/light-docusaurus/middleware/">Middleware</a></li><li class="footer__item"><a class="footer__link-item" href="/light-docusaurus/electron/">Electron</a></li></ul></div><div class="col footer__col"><div class="footer__title">Community</div><ul class="footer__items clean-list"><li class="footer__item"><a href="https://stackoverflow.com/questions/tagged/lorchr" target="_blank" rel="noopener noreferrer" class="footer__link-item">Stack Overflow<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li><li class="footer__item"><a href="https://discordapp.com/invite/lorchr" target="_blank" rel="noopener noreferrer" class="footer__link-item">Discord<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li><li class="footer__item"><a href="https://twitter.com/lorchr" target="_blank" rel="noopener noreferrer" class="footer__link-item">Twitter<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li></ul></div><div class="col footer__col"><div class="footer__title">More</div><ul class="footer__items clean-list"><li class="footer__item"><a class="footer__link-item" href="/light-docusaurus/blog/">Blog</a></li><li class="footer__item"><a class="footer__link-item" href="/light-docusaurus/diy/">DIY</a></li><li class="footer__item"><a href="https://github.com/lorchr/light-docusaurus" target="_blank" rel="noopener noreferrer" class="footer__link-item">GitHub<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li></ul></div><div class="col footer__col"><div class="footer__title">Offical</div><ul class="footer__items clean-list"><li class="footer__item"><a href="https://docusaurus.io" target="_blank" rel="noopener noreferrer" class="footer__link-item">Home<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li><li class="footer__item"><a href="https://github.com/facebook/docusaurus" target="_blank" rel="noopener noreferrer" class="footer__link-item">Github<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li><li class="footer__item"><a href="https://docusaurus.io/docs/playground" target="_blank" rel="noopener noreferrer" class="footer__link-item">Playground<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li></ul></div></div><div class="footer__bottom text--center"><div class="footer__copyright">Copyright © 2024 Light-Docusaurus, Inc. Built with Docusaurus.</div></div></div></footer></div>
</body>
</html>