<!doctype html>
<html lang="zh-Hans" dir="ltr" class="docs-wrapper plugin-docs plugin-id-default docs-version-current docs-doc-page docs-doc-id-zh-cn/java/Java-Generic-Type" data-has-hydrated="false">
<head>
<meta charset="UTF-8">
<meta name="generator" content="Docusaurus v3.0.1">
<title data-rh="true">Java-Generic-Type | Light Docusaurus</title><meta data-rh="true" name="viewport" content="width=device-width,initial-scale=1"><meta data-rh="true" name="twitter:card" content="summary_large_image"><meta data-rh="true" property="og:image" content="https://lorchr.github.io/light-docusaurus/img/docusaurus-social-card.jpg"><meta data-rh="true" name="twitter:image" content="https://lorchr.github.io/light-docusaurus/img/docusaurus-social-card.jpg"><meta data-rh="true" property="og:url" content="https://lorchr.github.io/light-docusaurus/docs/zh-cn/java/Java-Generic-Type/"><meta data-rh="true" property="og:locale" content="zh_Hans"><meta data-rh="true" name="docusaurus_locale" content="zh-Hans"><meta data-rh="true" name="docsearch:language" content="zh-Hans"><meta data-rh="true" name="docusaurus_version" content="current"><meta data-rh="true" name="docusaurus_tag" content="docs-default-current"><meta data-rh="true" name="docsearch:version" content="current"><meta data-rh="true" name="docsearch:docusaurus_tag" content="docs-default-current"><meta data-rh="true" property="og:title" content="Java-Generic-Type | Light Docusaurus"><meta data-rh="true" name="description" content="- java泛型，你真的懂吗？"><meta data-rh="true" property="og:description" content="- java泛型，你真的懂吗？"><link data-rh="true" rel="icon" href="/light-docusaurus/img/favicon.ico"><link data-rh="true" rel="canonical" href="https://lorchr.github.io/light-docusaurus/docs/zh-cn/java/Java-Generic-Type/"><link data-rh="true" rel="alternate" href="https://lorchr.github.io/light-docusaurus/docs/zh-cn/java/Java-Generic-Type/" hreflang="zh-Hans"><link data-rh="true" rel="alternate" href="https://lorchr.github.io/light-docusaurus/docs/zh-cn/java/Java-Generic-Type/" hreflang="x-default"><link data-rh="true" rel="preconnect" href="https://TLGHDZ3Y2I-dsn.algolia.net" crossorigin="anonymous"><link rel="alternate" type="application/rss+xml" href="/light-docusaurus/blog/rss.xml" title="Light Docusaurus RSS Feed">
<link rel="alternate" type="application/atom+xml" href="/light-docusaurus/blog/atom.xml" title="Light Docusaurus Atom Feed">



<link rel="search" type="application/opensearchdescription+xml" title="Light Docusaurus" href="/light-docusaurus/opensearch.xml"><link rel="stylesheet" href="/light-docusaurus/assets/css/styles.609e5209.css">
<script src="/light-docusaurus/assets/js/runtime~main.e1ee5690.js" defer="defer"></script>
<script src="/light-docusaurus/assets/js/main.689ca179.js" defer="defer"></script>
</head>
<body class="navigation-with-keyboard">
<script>!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){try{return new URLSearchParams(window.location.search).get("docusaurus-theme")}catch(t){}}()||function(){try{return localStorage.getItem("theme")}catch(t){}}();t(null!==e?e:"light")}(),function(){try{const c=new URLSearchParams(window.location.search).entries();for(var[t,e]of c)if(t.startsWith("docusaurus-data-")){var a=t.replace("docusaurus-data-","data-");document.documentElement.setAttribute(a,e)}}catch(t){}}()</script><div id="__docusaurus"><div role="region" aria-label="跳到主要内容"><a class="skipToContent_fXgn" href="#__docusaurus_skipToContent_fallback">跳到主要内容</a></div><nav aria-label="主导航" class="navbar navbar--fixed-top"><div class="navbar__inner"><div class="navbar__items"><button aria-label="切换导航栏" aria-expanded="false" class="navbar__toggle clean-btn" type="button"><svg width="30" height="30" viewBox="0 0 30 30" aria-hidden="true"><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><a class="navbar__brand" href="/light-docusaurus/"><div class="navbar__logo"><img src="/light-docusaurus/img/logo.svg" alt="Torch Logo" class="themedComponent_mlkZ themedComponent--light_NVdE"><img src="/light-docusaurus/img/logo.svg" alt="Torch Logo" class="themedComponent_mlkZ themedComponent--dark_xIcU"></div><b class="navbar__title text--truncate">Torch</b></a><a aria-current="page" class="navbar__item navbar__link navbar__link--active" href="/light-docusaurus/docs/category/guide/">Torch</a><a class="navbar__item navbar__link" href="/light-docusaurus/blog/">Blog</a><a class="navbar__item navbar__link" href="/light-docusaurus/middleware/">Middleware</a><a class="navbar__item navbar__link" href="/light-docusaurus/electron/">Electron</a><a class="navbar__item navbar__link" href="/light-docusaurus/postman/">Postman</a><a class="navbar__item navbar__link" href="/light-docusaurus/diy/">DIY</a></div><div class="navbar__items navbar__items--right"><div class="navbar__item dropdown dropdown--hoverable dropdown--right"><a href="#" aria-haspopup="true" aria-expanded="false" role="button" class="navbar__link"><svg viewBox="0 0 24 24" width="20" height="20" aria-hidden="true" class="iconLanguage_nlXk"><path fill="currentColor" d="M12.87 15.07l-2.54-2.51.03-.03c1.74-1.94 2.98-4.17 3.71-6.53H17V4h-7V2H8v2H1v1.99h11.17C11.5 7.92 10.44 9.75 9 11.35 8.07 10.32 7.3 9.19 6.69 8h-2c.73 1.63 1.73 3.17 2.98 4.56l-5.09 5.02L4 19l5-5 3.11 3.11.76-2.04zM18.5 10h-2L12 22h2l1.12-3h4.75L21 22h2l-4.5-12zm-2.62 7l1.62-4.33L19.12 17h-3.24z"></path></svg>简体中文</a><ul class="dropdown__menu"><li><a href="/light-docusaurus/docs/zh-cn/java/Java-Generic-Type/" target="_self" rel="noopener noreferrer" class="dropdown__link dropdown__link--active" lang="zh-Hans">简体中文</a></li></ul></div><a href="https://github.com/lorchr/light-docusaurus" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link">GitHub<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a><div class="toggle_vylO colorModeToggle_DEke"><button class="clean-btn toggleButton_gllP toggleButtonDisabled_aARS" type="button" disabled="" title="切换浅色/暗黑模式（当前为浅色模式）" aria-label="切换浅色/暗黑模式（当前为浅色模式）" aria-live="polite"><svg viewBox="0 0 24 24" width="24" height="24" class="lightToggleIcon_pyhR"><path fill="currentColor" d="M12,9c1.65,0,3,1.35,3,3s-1.35,3-3,3s-3-1.35-3-3S10.35,9,12,9 M12,7c-2.76,0-5,2.24-5,5s2.24,5,5,5s5-2.24,5-5 S14.76,7,12,7L12,7z M2,13l2,0c0.55,0,1-0.45,1-1s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S1.45,13,2,13z M20,13l2,0c0.55,0,1-0.45,1-1 s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S19.45,13,20,13z M11,2v2c0,0.55,0.45,1,1,1s1-0.45,1-1V2c0-0.55-0.45-1-1-1S11,1.45,11,2z M11,20v2c0,0.55,0.45,1,1,1s1-0.45,1-1v-2c0-0.55-0.45-1-1-1C11.45,19,11,19.45,11,20z M5.99,4.58c-0.39-0.39-1.03-0.39-1.41,0 c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0s0.39-1.03,0-1.41L5.99,4.58z M18.36,16.95 c-0.39-0.39-1.03-0.39-1.41,0c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0c0.39-0.39,0.39-1.03,0-1.41 L18.36,16.95z M19.42,5.99c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06c-0.39,0.39-0.39,1.03,0,1.41 s1.03,0.39,1.41,0L19.42,5.99z M7.05,18.36c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06 c-0.39,0.39-0.39,1.03,0,1.41s1.03,0.39,1.41,0L7.05,18.36z"></path></svg><svg viewBox="0 0 24 24" width="24" height="24" class="darkToggleIcon_wfgR"><path fill="currentColor" d="M9.37,5.51C9.19,6.15,9.1,6.82,9.1,7.5c0,4.08,3.32,7.4,7.4,7.4c0.68,0,1.35-0.09,1.99-0.27C17.45,17.19,14.93,19,12,19 c-3.86,0-7-3.14-7-7C5,9.07,6.81,6.55,9.37,5.51z M12,3c-4.97,0-9,4.03-9,9s4.03,9,9,9s9-4.03,9-9c0-0.46-0.04-0.92-0.1-1.36 c-0.98,1.37-2.58,2.26-4.4,2.26c-2.98,0-5.4-2.42-5.4-5.4c0-1.81,0.89-3.42,2.26-4.4C12.92,3.04,12.46,3,12,3L12,3z"></path></svg></button></div><div class="navbarSearchContainer_Bca1"><button type="button" class="DocSearch DocSearch-Button" aria-label="搜索"><span class="DocSearch-Button-Container"><svg width="20" height="20" class="DocSearch-Search-Icon" viewBox="0 0 20 20"><path d="M14.386 14.386l4.0877 4.0877-4.0877-4.0877c-2.9418 2.9419-7.7115 2.9419-10.6533 0-2.9419-2.9418-2.9419-7.7115 0-10.6533 2.9418-2.9419 7.7115-2.9419 10.6533 0 2.9419 2.9418 2.9419 7.7115 0 10.6533z" stroke="currentColor" fill="none" fill-rule="evenodd" stroke-linecap="round" stroke-linejoin="round"></path></svg><span class="DocSearch-Button-Placeholder">搜索</span></span><span class="DocSearch-Button-Keys"></span></button></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div></nav><div id="__docusaurus_skipToContent_fallback" class="main-wrapper mainWrapper_z2l0"><div class="docsWrapper_hBAB"><button aria-label="回到顶部" class="clean-btn theme-back-to-top-button backToTopButton_sjWU" type="button"></button><div class="docRoot_UBD9"><aside class="theme-doc-sidebar-container docSidebarContainer_YfHR"><div class="sidebarViewport_aRkj"><div class="sidebar_njMd"><nav aria-label="文档侧边栏" class="menu thin-scrollbar menu_SIkG"><ul class="theme-doc-sidebar-menu menu__list"><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" aria-expanded="false" href="/light-docusaurus/docs/category/guide/">Guide</a><button aria-label="展开侧边栏分类 &#x27;Guide&#x27;" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" aria-expanded="false" href="/light-docusaurus/docs/category/develop-environment/">Develop Environment</a><button aria-label="展开侧边栏分类 &#x27;Develop Environment&#x27;" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--active" aria-expanded="true" href="/light-docusaurus/docs/category/java-jvm/">Java (JVM)</a><button aria-label="折叠侧边栏分类 &#x27;Java (JVM)&#x27;" type="button" class="clean-btn menu__caret"></button></div><ul style="display:block;overflow:visible;height:auto" class="menu__list"><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/light-docusaurus/docs/zh-cn/java/Java-Concurrent-AbstractQueuedSynchronizer/">Java-Concurrent-AbstractQueuedSynchronizer</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/light-docusaurus/docs/zh-cn/java/Java-Concurrent-ReentrantLock/">Java-Concurrent-ReentrantLock</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/light-docusaurus/docs/zh-cn/java/Java-Concurrent-Semaphore/">Java-Concurrent-Semaphore</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/light-docusaurus/docs/zh-cn/java/Java-Concurrent-CountDownlatch/">Java-Concurrent-CountDownlatch</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/light-docusaurus/docs/zh-cn/java/Java-Concurrent-CyclicBarrier/">Java-Concurrent-CyclicBarrier</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/light-docusaurus/docs/zh-cn/java/Java-Concurrent-ConcurrentHashMap/">Java-Concurrent-ConcurrentHashMap</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/light-docusaurus/docs/zh-cn/java/Java-Concurrent-ThreadPoolExecutor/">Java-Concurrent-ThreadPoolExecutor</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/light-docusaurus/docs/zh-cn/java/AbstractQueuedSynchronizer-In-Action/">AbstractQueuedSynchronizer-In-Action</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/light-docusaurus/docs/zh-cn/java/CompletableFuture-Getting-Start/">CompletableFuture-Getting-Start</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/light-docusaurus/docs/zh-cn/java/CompletableFuture-Usage/">CompletableFuture-Usage</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/light-docusaurus/docs/zh-cn/java/CompletableFuture-In-Action/">CompletableFuture-In-Action</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/light-docusaurus/docs/zh-cn/java/Bytecode-Toolkit-Javassist/">Bytecode-Toolkit-Javassist</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/light-docusaurus/docs/zh-cn/java/GC-Exception-Analysis/">GC-Exception-Analysis</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/light-docusaurus/docs/zh-cn/java/Java-Instrumentation-JavaAgent/">Java-Instrumentation-JavaAgent</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/light-docusaurus/docs/zh-cn/java/JVM-Stack-And Heap-Dump/">JVM-Stack-And Heap-Dump</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/light-docusaurus/docs/zh-cn/java/Http-Client-Skip-Https-Check/">Http-Client-Skip-Https-Check</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/light-docusaurus/docs/zh-cn/java/Java-Error-Check/">Java-Error-Check</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/light-docusaurus/docs/zh-cn/java/Java-Agent-1/">Java-Agent-1</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/light-docusaurus/docs/zh-cn/java/Java-Lock/">Java-Lock</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link menu__link--active" aria-current="page" tabindex="0" href="/light-docusaurus/docs/zh-cn/java/Java-Generic-Type/">Java-Generic-Type</a></li></ul></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" aria-expanded="false" href="/light-docusaurus/docs/category/spring-boot/">Spring Boot</a><button aria-label="展开侧边栏分类 &#x27;Spring Boot&#x27;" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" aria-expanded="false" href="/light-docusaurus/docs/category/spring-cloud/">Spring Cloud</a><button aria-label="展开侧边栏分类 &#x27;Spring Cloud&#x27;" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" aria-expanded="false" href="/light-docusaurus/docs/category/spring-security/">Spring Security</a><button aria-label="展开侧边栏分类 &#x27;Spring Security&#x27;" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" aria-expanded="false" href="/light-docusaurus/docs/category/spring-authorization-server/">Spring Authorization Server</a><button aria-label="展开侧边栏分类 &#x27;Spring Authorization Server&#x27;" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" aria-expanded="false" href="/light-docusaurus/docs/category/active-directory/">Active Directory</a><button aria-label="展开侧边栏分类 &#x27;Active Directory&#x27;" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" aria-expanded="false" href="/light-docusaurus/docs/category/database/">Database</a><button aria-label="展开侧边栏分类 &#x27;Database&#x27;" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" aria-expanded="false" href="/light-docusaurus/docs/category/git/">Git</a><button aria-label="展开侧边栏分类 &#x27;Git&#x27;" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" aria-expanded="false" href="/light-docusaurus/docs/category/linux/">Linux</a><button aria-label="展开侧边栏分类 &#x27;Linux&#x27;" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" aria-expanded="false" href="/light-docusaurus/docs/category/docker/">Docker</a><button aria-label="展开侧边栏分类 &#x27;Docker&#x27;" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" aria-expanded="false" href="/light-docusaurus/docs/category/kubernetes/">Kubernetes</a><button aria-label="展开侧边栏分类 &#x27;Kubernetes&#x27;" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" aria-expanded="false" href="/light-docusaurus/docs/category/test/">Test</a><button aria-label="展开侧边栏分类 &#x27;Test&#x27;" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" aria-expanded="false" href="/light-docusaurus/docs/category/others/">Others</a><button aria-label="展开侧边栏分类 &#x27;Others&#x27;" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/light-docusaurus/docs/zh-cn/awesome-open-source/">Awesome open source</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/light-docusaurus/docs/zh-cn/windows/">Windows</a></li></ul></nav><button type="button" title="收起侧边栏" aria-label="收起侧边栏" class="button button--secondary button--outline collapseSidebarButton_PEFL"><svg width="20" height="20" aria-hidden="true" class="collapseSidebarButtonIcon_kv0_"><g fill="#7a7a7a"><path d="M9.992 10.023c0 .2-.062.399-.172.547l-4.996 7.492a.982.982 0 01-.828.454H1c-.55 0-1-.453-1-1 0-.2.059-.403.168-.551l4.629-6.942L.168 3.078A.939.939 0 010 2.528c0-.548.45-.997 1-.997h2.996c.352 0 .649.18.828.45L9.82 9.472c.11.148.172.347.172.55zm0 0"></path><path d="M19.98 10.023c0 .2-.058.399-.168.547l-4.996 7.492a.987.987 0 01-.828.454h-3c-.547 0-.996-.453-.996-1 0-.2.059-.403.168-.551l4.625-6.942-4.625-6.945a.939.939 0 01-.168-.55 1 1 0 01.996-.997h3c.348 0 .649.18.828.45l4.996 7.492c.11.148.168.347.168.55zm0 0"></path></g></svg></button></div></div></aside><main class="docMainContainer_TBSr"><div class="container padding-top--md padding-bottom--lg"><div class="row"><div class="col docItemCol_VOVn"><div class="docItemContainer_Djhp"><article><nav class="theme-doc-breadcrumbs breadcrumbsContainer_Z_bl" aria-label="页面路径"><ul class="breadcrumbs" itemscope="" itemtype="https://schema.org/BreadcrumbList"><li class="breadcrumbs__item"><a aria-label="主页面" class="breadcrumbs__link" href="/light-docusaurus/"><svg viewBox="0 0 24 24" class="breadcrumbHomeIcon_YNFT"><path d="M10 19v-5h4v5c0 .55.45 1 1 1h3c.55 0 1-.45 1-1v-7h1.7c.46 0 .68-.57.33-.87L12.67 3.6c-.38-.34-.96-.34-1.34 0l-8.36 7.53c-.34.3-.13.87.33.87H5v7c0 .55.45 1 1 1h3c.55 0 1-.45 1-1z" fill="currentColor"></path></svg></a></li><li itemscope="" itemprop="itemListElement" itemtype="https://schema.org/ListItem" class="breadcrumbs__item"><a class="breadcrumbs__link" itemprop="item" href="/light-docusaurus/docs/category/java-jvm/"><span itemprop="name">Java (JVM)</span></a><meta itemprop="position" content="1"></li><li itemscope="" itemprop="itemListElement" itemtype="https://schema.org/ListItem" class="breadcrumbs__item breadcrumbs__item--active"><span class="breadcrumbs__link" itemprop="name">Java-Generic-Type</span><meta itemprop="position" content="2"></li></ul></nav><div class="tocCollapsible_ETCw theme-doc-toc-mobile tocMobile_ITEo"><button type="button" class="clean-btn tocCollapsibleButton_TO0P">本页总览</button></div><div class="theme-doc-markdown markdown"><header><h1>Java-Generic-Type</h1></header><ul>
<li><a href="https://mp.weixin.qq.com/s/Y6wkdzG8DpUwZrOEbabBtQ">java泛型，你真的懂吗？</a></li>
</ul>
<p>本文主要讲解泛型类型的解析，泛型算是必须要掌握的一块硬核知识，在很多地方都会用到，这块如果理解了，在阅读其他框架源码的时候会让你更容易一些，看完本文之后大家对泛型也有一个新的认识。</p>
<p>关于泛型的解析上面，我们需要先了解一些类和接口，这些比较关键，这些都位于<code>java.lang.reflect</code>包中，类图如下：</p>
<p>图片</p>
<p>下面一个个来解释。</p>
<h2 id="type接口">Type接口</h2>
<p>这是一个顶层接口，java中的任何类 型都可以用这个来表示，这个接口是Java编程语言中所有类型的公共超接口。这些类型包括原始类型、泛型类型、泛型变量类型、通配符类型、泛型数组类型、数组类型等各种类型。</p>
<p>这个接口代码比较简单，源码：</p>
<pre><code class="language-java">public interface Type {
    /**
     * Returns a string describing this type, including information
     * about any type parameters.
     *
     * @implSpec The default implementation calls {@code toString}.
     *
     * @return a string describing this type
     * @since 1.8
     */
    default String getTypeName() {
        return toString();
    }
}
</code></pre>
<p>这个接口只有一个方法getTypeName，用于返回具体类型的名称，是一个默认方法，默认会调用当前类的toString方法，实现类也可以对这个方法重写。</p>
<h2 id="genericdeclaration接口">GenericDeclaration接口</h2>
<p>所有声明泛型变量的公共接口，这个接口中定义了一个方法：</p>
<pre><code class="language-java">public TypeVariable&lt;?&gt;[] getTypeParameters()
</code></pre>
<p>这个方法用于获取声明的泛型变量类型清单。</p>
<p>泛型变量可以在类和方法中进行声明，从上面类图中也可以看出来，java中任何类可以使用Class对象表示，方法可以用Method类表示，类图中可以知，Class类和Method类实现了<code>GenericDeclaration</code>接口，所以可以调用他们的<code>getTypeParameters</code>方法获取其声明的泛型参数列表。</p>
<h3 id="类中定义泛型变量类型">类中定义泛型变量类型</h3>
<pre><code class="language-java">public class Demo1&lt;T1, T2 extends Integer, T3 extends Demo1I1 &amp; Demo1I2&gt;
</code></pre>
<p>上面代码表示Demo1这个类中声明了3个泛型变量类型：T1、T2、T3，所以如果去调用这个类的Clas对象中的getTypeParameters方法可以获取到这三个泛型变量的信息，文章后面有案例演示。</p>
<h3 id="方法 中定义泛型变量类型">方法中定义泛型变量类型</h3>
<pre><code class="language-java">public &lt;T1, T2 extends Integer, T3 extends Demo2I1 &amp; Demo2I2&gt; T3 m1(T1 t1, T2 t2, T3 t3, String s) {
    return t3;
}
</code></pre>
<p>上面m1方法中声明了三个泛型类型变量：T1、T2、T3；java中可以方法的任何信息都可以通过Method对象来获取，Mehod类实现了<code>GenericDeclaration</code>接口，所以Method类中实现了<code>GenericDeclaration</code>接口中的<code>getTypeParameters</code>方法，调用这个方法就可以获取m1方法中3个泛型变量类型的信息，文章后面有案例演示。</p>
<h2 id="class类">Class类</h2>
<p>这个比较常见，Class类的对象表示JVM中一个类或者接口，每个java对象被加载到jvm中都会表现为一个Class类型的对象，java中的数组也被映射为Class对象，所有元素类型相同且维数相同的数组都共享一个class对象，通过Class对象可以获取类或者接口中的任何信息，比如：类名、类中声明的泛型信息、类的修饰符、类的父类信息、类的接口信息、类中的任何方法信息、类中任何字段信息等等。</p>
<h3 id="class对象获取方式">Class对象获取方式</h3>
<p>在程序中我们可以通过3中方式获取Class对象：</p>
<ol>
<li><code>类名.class</code></li>
<li><code>对象.getClass()</code></li>
<li><code>Class.forName(&quot;类或者接口的完整名称&quot;)</code></li>
</ol>
<h3 id="常用的方法">常用的方法</h3>
<h4 id="field-getfields"><code>Field[] getFields()</code></h4>
<p>这个方法会返回当前类的以及其所有父类、父类的父类中所有public类型的字段。</p>
<h4 id="field-getdeclaredfields"><code>Field[] getDeclaredFields()</code></h4>
<p>这个方法会返回当前类中所有字段（和修饰符无关），也就说不管这个字段是<code>public</code>还是<code>private</code>或者是<code>protected</code>，都会返回，有一点需要注意，只返回自己内部定义的字段，不包含其父类中的，这点需要注意，和getFields是有区别的。</p>
<h4 id="method-getmethods"><code>Method[] getMethods()</code></h4>
<p>这个方法会返回当前类的以及其所有父类的、父类的父类的、自己实现的接口、父接口继承的接口中的所有public类型的方法，需要注意一下，接口中的方法默认都是public类型的，接口中的方法public修饰符是可以省略的。</p>
<h4 id="method-getdeclaredmethods"><code>Method[] getDeclaredMethods()</code></h4>
<p>返回当前类中定义的所有方法，不管这个方法修饰符是什么类型的，注意只包含自己内部定义的方法，不包含当前类的父类或者其实现的接口中定义的。</p>
<h4 id="type-getgenericsuperclass"><code>Type getGenericSuperclass()</code></h4>
<p>返回父类的类型信息，如果父类是泛型类型，会返回超类中泛型的详细信息，这个方法比较关键，后面会有详细案例。</p>
<h4 id="typevariableclasst-gettypeparameters"><code>TypeVariable&lt;Class&lt;T&gt;&gt;[] getTypeParameters()</code></h4>
<p>Class类继承了<code>java.lang.reflect.GenericDeclaration</code>接口，上面这个方法是在<code>GenericDeclaration</code>接口中定义的，Class类中实现了这个接口，用于返回当前类中声明的泛型变量参数列表。</p>
<h2 id="method类">Method类</h2>
<p>这个类用来表示java中的任何一个方法，通过这个类可以获取java中方法的任何信息，比如：方法的修饰符、方法名称、方法的参数、方法返回值、方法中声明的泛型参数列表等方法的一切信息。</p>
<h3 id="常用的方法-1">常用的方法</h3>
<h4 id="string-getname"><code>String getName()</code></h4>
<p>用来获取方法的名称。</p>
<h4 id="type-getgenericparametertypes"><code>Type[] getGenericParameterTypes()</code></h4>
<p>返回方法的参数信息，如果参数是泛型类型的，会返回泛型的详细信息，这个方法后面会演示。</p>
<h4 id="type-getgenericreturntype"><code>Type getGenericReturnType()</code></h4>
<p>返回方法的返回值类型，如果返回值是泛型的，会包含泛型的详细信息。</p>
<h4 id="typevariablemethod-gettypeparameters"><code>TypeVariable&lt;Method&gt;[] getTypeParameters()</code></h4>
<p>Method类继承了<code>java.lang.reflect.GenericDeclaration</code>接口，上面这个方法是在<code>GenericDeclaration</code>接口中定义的，Method类中实现了这个接口，用于返回当前方法中声明的泛型变量参数列表。</p>
<h2 id="field类">Field类</h2>
<p>这个类用来表示java中的字段，通过这个类可以获取java中字段的任何信息，比如：字段的修饰符、字段名称、字段类型、泛型字段的类型等字段的一切信息。</p>
<h3 id="常用的方法-2">常用的方法</h3>
<h4 id="string-getname-1"><code>String getName()</code></h4>
<p>获取字段的名称。</p>
<h4 id="class-gettype"><code>Class&lt;?&gt; getType()</code></h4>
<p>获取字段类型所属的Class对象。</p>
<h4 id="type-getgenerictype"><code>Type getGenericType()</code></h4>
<p>获取字段的类型，如果字段是泛型类型的，会返回泛型类型的详细信息；如果字段不是泛型类型的，和getType返回的结果是一样的。</p>
<h4 id="class-getdeclaringclass"><code>Class&lt;?&gt; getDeclaringClass()</code></h4>
<p>获取这个字段是在哪个类中声明的，也就是当前字段所属的类。</p>
<h2 id="parameterizedtype接口">ParameterizedType接口</h2>
<p>这个接口表示参数化类型，例如<code>List&lt;String&gt;</code>、<code>Map&lt;Integer,String&gt;</code>、<code>UserMapper&lt;UserModel&gt;</code>这种带有泛型的类型。</p>
<h2 id="常用方法">常用方法</h2>
<p>这个接口中定义了3个方法，都比较重要，来看一下。</p>
<h3 id="type-getactualtypearguments"><code>Type[] getActualTypeArguments()</code></h3>
<p>获取泛型类型中的类型列表，就是<code>&lt;&gt;</code>中包含的参数列表， 如：<code>List&lt;String&gt;</code>泛型类型列表只有一个是<code>String</code>，而<code>Map&lt;Integer,String&gt;</code>泛型类型中包含2个类型：<code>Integer</code>和<code>String</code>，<code>UserMapper&lt;UserModel&gt;</code>泛型类型为<code>UserModel</code>，实际上就是<code>&lt;和&gt;</code>中间包含的类型列表。</p>
<h3 id="type-getrawtype"><code>Type getRawType()</code></h3>
<p>返回参数化类型中的原始类型，比如：<code>List&lt;String&gt;</code>的原始类型为<code>List</code>，<code>UserMapper&lt;UserModel&gt;</code>原始类型为<code>UserMapper</code>，也就是<code>&lt;</code>符号前面的部分。</p>
<h3 id="type--getownertype"><code>Type[]  getOwnerType()</code></h3>
<p>返回当前类型所属的类型。例如存在<code>A&lt;T&gt;</code>类，其中定义了内部类<code>InnerA&lt;I&gt;</code>，则<code>InnerA&lt;I&gt;</code>所属的类型为<code>A&lt;I&gt;</code>，如果是顶层类型则返回null。这种关系比较常见的示例是<code>Map&lt;K,V&gt;</code>接口与<code>Map.Entry&lt;K,V&gt;</code>接口，<code>Map&lt;K,V&gt;</code>接口是<code>Map.Entry&lt;K,V&gt;</code>接口的所有者。</p>
<h2 id="typevariable接口">TypeVariable接口</h2>
<p>这个接口表示的是泛型变量，例如：<code>List&lt;T&gt;</code>中的T就是类型变量；而<code>class C1&lt;T1,T2,T3&gt;{}</code>表示一个类，这个类中定义了3个泛型变量类型，分别是T1、T2和T2，泛型变量在java中使用<code>TypeVariable</code>接口来表示，可以通过这个接口提供的方法获取泛型变量类型的详细信息。</p>
<h3 id="常用的方法-3">常用的方法</h3>
<h4 id="type-getbounds"><code>Type[] getBounds()</code></h4>
<p>获取泛型变量类型的上边界，如果未明确什么上边界默认为Object。例如：<code>class Test&lt;K extend Person&gt;</code>中K的上边界只有一个，是<code>Person</code>；而<code>class Test&lt;T extend List &amp; Iterable&gt;</code>中T的上边界有2 个，是List和Iterable</p>
<h4 id="d-getgenericdeclaration"><code>D getGenericDeclaration()</code></h4>
<p>获取声明该泛型变量的原始类型，例如：<code>class Test&lt;K extend Person&gt;</code>中的K为泛型变量，这个泛型变量时Test类定义的时候声明的，说明如果调用<code>getGenericDeclaration</code>方法返回的就是Test对应的Class对象。</p>
<p>还有方法中也可以定义泛型类型的变量，如果在方法中定义，那么上面这个方法返回的就是定义泛型变量的方法了，返回的就是Method对象。</p>
<h4 id="string-getname-2"><code>String getName()</code></h4>
<p>获取在源码中定义时的名字，如：<code>class Test&lt;K extend Person&gt;</code>就是K；<code>class Test1&lt;T&gt;</code>中就是T。</p>
<h2 id="wildcardtype接口">WildcardType接口</h2>
<p>表示的是通配符泛型，通配符使用问号表示，例如：? extends Number和? super Integer。</p>
<h3 id="常用方法-1">常用方法</h3>
<p>接口中定义了2个方法。</p>
<h4 id="type-getupperbounds"><code>Type[] getUpperBounds()</code></h4>
<p>返回泛型变量的上边界列表。</p>
<h4 id="type-getlowerbounds"><code>Type[] getLowerBounds()</code></h4>
<p>返回泛型变量的下边界列表。</p>
<h2 id="genericarraytype接口">GenericArrayType接口</h2>
<p>表示的是数组类型，且数组中的元素是<code>ParameterizedType</code>或者<code>TypeVariable</code>。</p>
<p>例如：<code>List&lt;String&gt;[]</code>或者<code>T[]</code>。</p>
<h3 id="常用方法-2">常用方法</h3>
<p>这个接口只有一个方法：</p>
<h4 id="type-getgenericcomponenttype"><code>Type getGenericComponentType()</code></h4>
<p>这个方法返回数组的组成元素。</p>
<p>上面的大家多看几遍，下面开始上案例，加深对上面的理解和应用，信息量会比较大，慢慢理解。</p>
<h2 id="泛型变量">泛型变量</h2>
<p>泛型变量可以在类中和方法中定义。</p>
<p>泛型变量类型的使用<code>TypeVariable</code>接口来表示，所以可以通过<code>TypeVariable</code>接口获取泛型变量的所有信息。</p>
<p>下面我们分别来看看类中定义泛型变量和方法中定义泛型变量的用法以及泛型变量信息的获取。</p>
<h2 id="类中定义泛型变量">类中定义泛型变量</h2>
<h3 id="语法">语法</h3>
<pre><code class="language-java">class 类名&lt;泛型变量1,泛型变量2,泛型变量3 extends 上边界1,泛型变量4 extends 上边界类型1 &amp; 上边界类型2 &amp; 上边界类型3&gt;
</code></pre>
<ul>
<li>
<p>泛型变量需要在类名后面的括号中定义</p>
</li>
<li>
<p>每个类中可以定义多个泛型变量，多个泛型变量之间用逗号隔开</p>
</li>
<li>
<p>泛型变量可以通过extends关键字指定上边界，上边界可以对泛型变量起到了限定的作用，上边界可以指定0到多个，多个之间需要用&amp;符号隔开，如果不指定上边界，默认上边界为Object类型</p>
</li>
</ul>
<p>案例代码</p>
<pre><code class="language-java">package com.javacode2018.chat05.demo11;

import java.lang.reflect.Type;
import java.lang.reflect.TypeVariable;

interface Demo1I1 { //@1
}

interface Demo1I2 { //@2
}

/**
 * 类中泛型变量案例
 *
 * @param &lt;T1&gt;
 * @param &lt;T2&gt;
 * @param &lt;T3&gt;
 */
public class Demo1&lt;T1, T2 extends Integer, T3 extends Demo1I1 &amp; Demo1I2&gt; { //@3

    public static void main(String[] args) {
        TypeVariable&lt;Class&lt;Demo1&gt;&gt;[] typeParameters = Demo1.class.getTypeParameters();//@4
        for (TypeVariable&lt;Class&lt;Demo1&gt;&gt; typeParameter : typeParameters) {
            System.out.println(&quot;变量名称:&quot; + typeParameter.getName());
            System.out.println(&quot;这个变量在哪声明的:&quot; + typeParameter.getGenericDeclaration());
            Type[] bounds = typeParameter.getBounds();
            System.out.println(&quot;这个变量上边界数量:&quot; + bounds.length);
            System.out.println(&quot;这个变量上边界清单:&quot;);
            for (Type bound : bounds) {
                System.out.println(bound.getTypeName());
            }
            System.out.println(&quot;--------------------&quot;);
        }
    }
}
</code></pre>
<p>代码解读：</p>
<ol>
<li>
<p>@1：创建了接口Demo1I1，后面会用到</p>
</li>
<li>
<p>@2：创建接口Demo1I2，后面会用到这个接口</p>
</li>
<li>
<p>@3：创建了一个类Demo1，注意这个类是泛型类型的，泛型中定义了3个泛型类型变量，分别是：T1、T2、T3，这三个变量是有区别的。</p>
<p>T1没有限制上边界，默认上边界就是Object类型了。</p>
<p>注意T2的写法:</p>
<pre><code class="language-java">T2 extends Integer
</code></pre>
<p>这个通过extends限定了T2的上边界为Integer。</p>
<p>再来看看T3的写法，比较特别：</p>
<pre><code class="language-java">T3 extends I1 &amp; I2
</code></pre>
<p>T3的上边界有多个，多个边界之间需要用&amp;连接起来，T3有2个上边界，分别是两个接口Demo1I1和Demo1I2。</p>
</li>
<li>
<p>@4：这行代码用来调用了Class对象的<code>getTypeParameters</code>方法，这个方法会返回当前类上定义的泛型变量类型列表，当前类上定义了3个泛型变量类型，泛型变量类型在java中使用TypeVariable接口表示的。</p>
</li>
</ol>
<p>后面的for循环就是输出泛型变量的信息了，我们来运行一下看看效果：</p>
<pre><code class="language-shell">变量名称:T1
这个变量在哪声明的:class com.javacode2018.chat05.demo11.Demo1
这个变量上边界数量:1
这个变量上边界清单:
java.lang.Object
--------------------
变量名称:T2
这个变量在哪声明的:class com.javacode2018.chat05.demo11.Demo1
这个变量上边界数量:1
这个变量上边界清单:
java.lang.Integer
--------------------
变量名称:T3
这个变量在哪声明的:class com.javacode2018.chat05.demo11.Demo1
这个变量上边界数量:2
这个变量上边界清单:
com.javacode2018.chat05.demo11.Demo1I1
com.javacode2018.chat05.demo11.Demo1I2
--------------------
</code></pre>
<p>输出中可以看到3个泛型变量都是在当前类Demo1中定义的，每个泛型变量的名称，以及泛型变量的上边界信息都详细输出来了。</p>
<h2 id="方法中定义泛型变量">方法中定义泛型变量</h2>
<h3 id="语法-1">语法</h3>
<pre><code class="language-java">方法修饰符 &lt;泛型变量1,泛型变量2,泛型变量3 extends 上边界1,泛型变量4 extends 上边界类型1 &amp; 上边界类型2 &amp; 上边界类型3&gt; 方法名称(参数1类型 参数1名称,参数2类型 参数2名称)
</code></pre>
<ul>
<li>
<p>泛型变量需要在方法名称前面的括号中定义</p>
</li>
<li>
<p>方法中可以定义多个泛型变量，多个泛型变量之间用逗号隔开</p>
</li>
<li>
<p>泛型变量可以通过extends关键字指定上边界，上边界可以对泛型变量起到了限定的作用，上边界可以指定0到多个，多个之间需要用&amp;符号隔开，如果不指定上边界，默认上边界为Object类型</p>
</li>
</ul>
<p>案例代码</p>
<pre><code class="language-java">package com.javacode2018.chat05.demo11;


import java.lang.reflect.Method;
import java.lang.reflect.Type;
import java.lang.reflect.TypeVariable;

interface Demo2I1 { //@1
}

interface Demo2I2 { //@2
}

/**
 * 泛型方法中的泛型变量
 */
public class Demo2 {

    public &lt;T1, T2 extends Integer, T3 extends Demo2I1 &amp; Demo2I2&gt; T3 m1(T1 t1, T2 t2, T3 t3, String s) {//@3
        return t3;
    }

    public static void main(String[] args) {
        //获取Demo2中声明的所有方法
        Method[] methods = Demo2.class.getDeclaredMethods();
        Method m1 = null;
        //找到m1方法
        for (Method method : methods) {
            if (method.getName().equals(&quot;m1&quot;)) {
                m1 = method;
                break;
            }
        }

        //获取方法的泛型参数列表
        System.out.println(&quot;m1方法参数类型列表信息:----------&quot;);
        Type[] genericParameterTypes = m1.getGenericParameterTypes();
        for (Type genericParameterType : genericParameterTypes) {
            //3个参数都是泛型变量类型的，对应java中的TypeVariable
            if (genericParameterType instanceof TypeVariable) {
                TypeVariable pt = (TypeVariable) genericParameterType;
                System.out.println(&quot;变量类型名称:&quot; + pt.getTypeName());
                System.out.println(&quot;变量名称:&quot; + pt.getName());
                System.out.println(&quot;这个变量在哪声明的:&quot; + pt.getGenericDeclaration());
                Type[] bounds = pt.getBounds();
                System.out.println(&quot;这个变量上边界数量:&quot; + bounds.length);
                System.out.println(&quot;这个变量上边界清单:&quot;);
                for (Type bound : bounds) {
                    System.out.println(bound.getTypeName());
                }
            } else if (genericParameterType instanceof Class) {
                Class pt = (Class) genericParameterType;
                System.out.println(&quot;参数类型名称:&quot; + pt.getTypeName());
                System.out.println(&quot;参数类名:&quot; + pt.getName());
            }
            System.out.println(&quot;--------------------&quot;);
        }

        //获取方法的返回值，也是一个泛型变量
        System.out.println(&quot;m1方法返回值类型信息:----------&quot;);
        Type genericReturnType = m1.getGenericReturnType();
        if (genericReturnType instanceof TypeVariable) {
            TypeVariable pt = (TypeVariable) genericReturnType;
            System.out.println(&quot;变量名称:&quot; + pt.getName());
            System.out.println(&quot;这个变量在哪声明的:&quot; + pt.getGenericDeclaration());
            Type[] bounds = pt.getBounds();
            System.out.println(&quot;这个变量上边界数量:&quot; + bounds.length);
            System.out.println(&quot;这个变量上边界清单:&quot;);
            for (Type bound : bounds) {
                System.out.println(bound.getTypeName());
            }
            System.out.println(&quot;--------------------&quot;);
        }

        //获取方法中声明的泛型参数列表
        System.out.println(&quot;m1方法中声明的泛型变量类型列表:----------&quot;);
        TypeVariable&lt;Method&gt;[] typeParameters = m1.getTypeParameters();
        for (TypeVariable&lt;Method&gt; pt : typeParameters) {
            System.out.println(&quot;变量类型名称:&quot; + pt.getTypeName());
            System.out.println(&quot;变量名称:&quot; + pt.getName());
            System.out.println(&quot;这个变量在哪声明的:&quot; + pt.getGenericDeclaration());
            Type[] bounds = pt.getBounds();
            System.out.println(&quot;这个变量上边界数量:&quot; + bounds.length);
            System.out.println(&quot;这个变量上边界清单:&quot;);
            for (Type bound : bounds) {
                System.out.println(bound.getTypeName());
            }
            System.out.println(&quot;--------------------&quot;);
        }

    }
}
</code></pre>
<ol>
<li>
<p>@1 @2声明接口，下面会使用。</p>
</li>
<li>
<p>@3 这行比较特别，创建了一个方法，如下：</p>
</li>
</ol>
<pre><code class="language-java">public &lt;T1, T2 extends Integer, T3 extends Demo2I1 &amp; Demo2I2&gt; T3 m1(T1 t1, T2 t2, T3 t3, String s)
</code></pre>
<p>m1方法前面的<code>&lt;&gt;</code>括号中定义了3个泛型类型变量，方法有4个参数，前3个参数的类型为泛型变量类型的，第4个参数为String类型的。</p>
<p>泛型变量类型在java中使用<code>TypeVariable</code>表示，前3个参数都是泛型变量类型的，所以最后他们的信息都可以使用<code>TypeVariable</code>接口获取，最后一个参数是String类型的，这个是非泛型类型，使用Class类型来表示。</p>
<p>上面代码中先获取m1方法对应的Method对象，然后通过Method中的方法获取了方法参数的列表，方法的返回值详细的泛型信息，方法中声明的3个泛型变量的详细信息。</p>
<h2 id="泛型类型">泛型类型</h2>
<h3 id="泛型类型定义的语法">泛型类型定义的语法</h3>
<pre><code class="language-java">具体类型&lt;类型1,类型2,类型3&gt;
</code></pre>
<ul>
<li>
<p>泛型类型可以作为方法的参数、方法的返回值、泛型类（这3种一会举例）</p>
</li>
<li>
<p><code>&lt;&gt;</code>中的泛型的实际参数列表，可以有多个，可以是任意类型的，比如：String类型、自定义类型、泛型变量类型、泛型通配符类型(?表示通配符，这个一会后面会讲)</p>
</li>
<li>
<p>泛型类型的信息在java中使用ParameterizedType接口来表示，可以通过这个接口作为入口获取泛型的具体详细信息。</p>
</li>
</ul>
<p>比如：<code>List&lt;String&gt;</code>、<code>Map&lt;Integer,String&gt;</code>、<code>UserMapper&lt;UserModel&gt;</code>，<code>List</code>这些都是泛型类型，这些泛型的信息都可以通过<code>ParameterizedType</code>来表示，然后通过这个接口中的方法获取这些泛型的具体信息。</p>
<p>下面来详解3种泛型类型。</p>
<h2 id="方法中泛型参数和泛型返回值">方法中泛型参数和泛型返回值</h2>
<p>方法的参数为泛型类型或者返回值为泛型类型，我们来获取这些泛型类型的信息。</p>
<p>案例代码</p>
<pre><code class="language-java">package com.javacode2018.chat05.demo11;

import java.lang.reflect.Method;
import java.lang.reflect.ParameterizedType;
import java.lang.reflect.Type;
import java.lang.reflect.TypeVariable;
import java.util.List;
import java.util.stream.Collectors;

/**
 * 泛型参数
 */
public class Demo4&lt;T&gt; {//@0

    public class C1 {//@1
        /**
         * m1方法参数和返回值都是泛型类型，泛型的实际类型是泛型变量类型T，T是在Demo4中声明的
         *
         * @param list
         * @return
         */
        public List&lt;T&gt; m1(List&lt;T&gt; list) {//@2
            //对list做一些操作
            return list;
        }
    }


    public static void main(String[] args) throws NoSuchMethodException {
        //获取m1方法
        Method m1 = Demo4.C1.class.getMethod(&quot;m1&quot;, List.class);
        //调用Method中的getGenericParameterTypes方法可以获取参数类型列表，包含了详细的泛型信息
        Type arg1Type = m1.getGenericParameterTypes()[0];
        //m1方法有1个参数是泛型类型的，泛型类型java中用ParameterizedType接口表示
        System.out.println(&quot;----------m1方法参数类型信息------------&quot;);
        if (arg1Type instanceof ParameterizedType) {//@3
            ParameterizedType parameterizedType = (ParameterizedType) arg1Type;
            System.out.println(&quot;原始类型：&quot; + parameterizedType.getRawType());
            System.out.println(&quot;所属的类型:&quot; + parameterizedType.getOwnerType());
            Type[] actualTypeArguments = parameterizedType.getActualTypeArguments();
            //泛型中第一个参数的类型是T，T是泛型变量，泛型变量对应java中的TypeVariable接口
            Type oneType = actualTypeArguments[0];//@4
            System.out.println(&quot;@5:&quot; + oneType.getClass());//@5
            if (oneType instanceof TypeVariable) {
                System.out.println(&quot;这个参数是个泛型变量类型！&quot;);
                TypeVariable&lt;Class&lt;Demo4&gt;&gt; oneActualType = (TypeVariable) oneType;
                System.out.println(&quot;变量名称:&quot; + oneActualType.getName());
                System.out.println(&quot;这个变量在哪声明的:&quot; + oneActualType.getGenericDeclaration());
                Type[] bounds = oneActualType.getBounds();
                System.out.println(&quot;这个变量上边界数量:&quot; + bounds.length);
                System.out.println(&quot;这个变量上边界清单:&quot;);
                for (Type bound : bounds) {
                    System.out.println(bound.getTypeName());
                }
            }
        }

        System.out.println(&quot;----------m1方法返回值类型信息------------&quot;);
        //m1方法返回值是泛型类型的，泛型类型java中用ParameterizedType接口表示
        //Method类中的getGenericReturnType方法可以获取方法的返回值，如果返回值是泛型类型的，会获取泛型类型对应的具体类型，此处返回的是List&lt;String&gt;类型的，java中使用ParameterizedType接口表示
        Type returnType = m1.getGenericReturnType();
        if (returnType instanceof ParameterizedType) {//@6
            ParameterizedType parameterizedType = (ParameterizedType) returnType;
            System.out.println(&quot;原始类型：&quot; + parameterizedType.getRawType());
            System.out.println(&quot;所属的类型:&quot; + parameterizedType.getOwnerType());
            Type[] actualTypeArguments = parameterizedType.getActualTypeArguments();
            //泛型中第一个参数的类型是T，T是泛型变量，泛型变量对应java中的TypeVariable接口
            Type oneType = actualTypeArguments[0];//@7
            System.out.println(&quot;@8:&quot; + oneType.getClass());//@8
            if (oneType instanceof TypeVariable) {
                System.out.println(&quot;返回值是个泛型变量类型！&quot;);
                TypeVariable&lt;Class&lt;Demo4&gt;&gt; oneActualType = (TypeVariable) oneType;
                System.out.println(&quot;变量名称:&quot; + oneActualType.getName());
                System.out.println(&quot;这个变量在哪声明的:&quot; + oneActualType.getGenericDeclaration());
                Type[] bounds = oneActualType.getBounds();
                System.out.println(&quot;这个变量上边界数量:&quot; + bounds.length);
                System.out.println(&quot;这个变量上边界清单:&quot;);
                for (Type bound : bounds) {
                    System.out.println(bound.getTypeName());
                }
                System.out.println(&quot;--------------------&quot;);
            }
        }
    }

}
</code></pre>
<p>代码解读：</p>
<ol>
<li>
<p>@0：<code>Demo1&lt;T&gt;</code>声明了一个泛型类型的变量T；T是个泛型类型的变量，泛型类型的变量在java中使用<code>TypeVariable</code>来表示。</p>
</li>
<li>
<p>@1：创建了一个类C1，注意这个类是在Demo1的内部声明的，说明C1是一个内部类。</p>
</li>
<li>
<p>@2：创建了方法m1，m1的参数和返回值都是泛型类型的<code>List&lt;T&gt;</code>，泛型类型在java中用<code>ParameterizedType</code>接口表示；而<code>List&lt;T&gt;</code>泛型类型中还有一个类型T，T是泛型变量类型的，在java中使用<code>TypeVariable</code>接口表示。</p>
</li>
</ol>
<p>上面代码中输出了m1方法参数的泛型的详细信息。</p>
<p>我们来运行看一下结果：</p>
<pre><code class="language-shell">----------m1方法参数类型信息------------
原始类型：interface java.util.List
所属的类型:null
@5:class sun.reflect.generics.reflectiveObjects.TypeVariableImpl
这个参数是个泛型变量类型！
变量名称:T
这个变量在哪声明的:class com.javacode2018.chat05.demo11.Demo4
这个变量上边界数量:1
这个变量上边界清单:
java.lang.Object
----------m1方法返回值类型信息------------
原始类型：interface java.util.List
所属的类型:null
@8:class sun.reflect.generics.reflectiveObjects.TypeVariableImpl
返回值是个泛型变量类型！
变量名称:T
这个变量在哪声明的:class com.javacode2018.chat05.demo11.Demo4
这个变量上边界数量:1
这个变量上边界清单:
java.lang.Object
--------------------
</code></pre>
<h2 id="泛型类">泛型类</h2>
<h3 id="泛型类的定义">泛型类的定义</h3>
<pre><code class="language-java">类修饰符 类名&lt;类型1,类型2,类型n&gt;{
}
</code></pre>
<p>上面是定义了一个泛型类，<code>&lt;&gt;</code>中包含的是一些可以变类型的列表，实际上我们创建这个类的对象的时候，会明确指定<code>&lt;&gt;</code>中包含的具体类型 。</p>
<p>比如我们熟悉的<code>HashMap</code>就是一个泛型类，来看看这个类的定义：</p>
<pre><code class="language-java">public class HashMap&lt;K,V&gt;
</code></pre>
<p>K和V是泛型变量类型的，具体是什么类型，可以在创建<code>HashMap</code>的时候去随意指定。</p>
<p>现在我们想获取泛型对象<code>&lt;&gt;</code>中包含的具体的类型，怎么获取？</p>
<p>比如下面代码：</p>
<pre><code class="language-java">package com.javacode2018.chat05.demo11;

public class Demo5&lt;T1, T2&gt; { //@1
    public void m1(Demo5&lt;T1, T2&gt; demo) { //@2
        System.out.println(demo.getClass());
    }

    public static void main(String[] args) {
        Demo5&lt;String, Integer&gt; demo5 = new Demo5&lt;&gt;();//@3
        demo5.m1(demo5);
    }
}
</code></pre>
<ol>
<li>
<p>@1：Demo5类中定义了两个泛型变量类型T1和T2。</p>
</li>
<li>
<p>@2：m1方法参数类型为Demo5，在这个方法内部如果我们想获取这个参数具体的详细类型信息，上面的代码是获取不到的，只能获取到demo5参数所属的类型是Demo5，但是无法获取到Demo5中的T1和T2这两个泛型变量类型对应的具体类型。</p>
</li>
</ol>
<p>运行一下上面代码输出：</p>
<pre><code class="language-java">class com.javacode2018.chat05.demo11.Demo5
</code></pre>
<p>Class对象中有个方法比较牛逼：</p>
<pre><code class="language-java">public Type getGenericSuperclass()
</code></pre>
<p>这个方法相当牛逼，可以获取到父类中泛型详细信息。</p>
<p>来看一个案例就明白了：</p>
<pre><code class="language-java">package com.javacode2018.chat05.demo11;

import java.lang.reflect.ParameterizedType;
import java.lang.reflect.Type;

//泛型类
class Demo&lt;T1, T2&gt; {//@0

}

public class Demo6 extends Demo&lt;String, Integer&gt; { //@1

    public static void main(String[] args) {
        Demo6 demo6 = new Demo6();
        //demo6Class对应的是Demo6的Class对象
        Class&lt;? extends Demo6&gt; demo6Class = demo6.getClass();//@2

        //获取Demo6的父类的详细类型信息，包含泛型信息
        Type genericSuperclass = demo6Class.getGenericSuperclass(); //@3
        // 泛型类型用ParameterizedType接口表示，输出看一下是不是这个接口类型的
        System.out.println(genericSuperclass.getClass()); //@4
        if (genericSuperclass instanceof ParameterizedType) { //@5
            ParameterizedType pt = (ParameterizedType) genericSuperclass;
            System.out.println(pt.getRawType());
            Type[] actualTypeArguments = pt.getActualTypeArguments();
            for (Type actualTypeArgument : actualTypeArguments) {
                System.out.println(actualTypeArgument.getTypeName());
            }
            System.out.println(pt.getOwnerType());
        }
    }

}
</code></pre>
<p>运行输出：</p>
<pre><code class="language-shell">com.javacode2018.chat05.demo11.Demo6
class sun.reflect.generics.reflectiveObjects.ParameterizedTypeImpl
class com.javacode2018.chat05.demo11.Demo
java.lang.String
java.lang.Integer
null
</code></pre>
<p>代码解读：</p>
<ol>
<li>
<p>@0：声明了一个泛型类，泛型类中定义了两个泛型变量的类型T1和T2，这两个变量的具体类型，可以在创建对象的时候指定任意具体的类型。</p>
</li>
<li>
<p>@1：这个比较特殊了，创建了类Demo6，这个类继承了Demo类，并且注意Demo后面的部分<code>&lt;String, Integer&gt;</code>，这个指定了具体的类型了，此时T1的具体类型就是String类型了，T2对应的具体类型就是Integer类型了。</p>
</li>
<li>
<p>@2：获取Demo6对应的Class对象</p>
</li>
<li>
<p>@3：这行代码比较关键，这个调用了Class类中的<code>getGenericSuperclass</code>方法，这个方法可以获取当前类父类的具体类型信息，如果父类是泛型，则会返回泛型详细信息，泛型类型在java中用<code>ParameterizedType</code>接口表示，所以@3代码返回的类型一定是<code>ParameterizedType</code>接口类型的了。</p>
</li>
<li>
<p>@4：输出了<code>genericSuperclass</code>变量的类型，注意上面第2行输出：<code>ParameterizedTypeImpl</code>，这个是<code>ParameterizedType</code>接口的一个实现类。</p>
</li>
<li>
<p>@5：这个地方加了个判断，判断是不是<code>ParameterizedType</code>类型的，然后if内部输出了泛型类型的具体的信息，调用了<code>ParameterizedType</code>接口中的3个方法去获取了具体的参数类型的信息，输出中的5/6行可以看到输出了具体的类型String和Integer。</p>
</li>
</ol>
<p>根据上面代码的原理，我们可以将下面的代码进行改造：</p>
<pre><code class="language-java">package com.javacode2018.chat05.demo11;

public class Demo5&lt;T1, T2&gt; { //@1
    public void m1(Demo5&lt;T1, T2&gt; demo5) { //@2
        System.out.println(demo5.getClass());
    }

    public static void main(String[] args) {
        Demo5&lt;String, Integer&gt; demo5 = new Demo5&lt;&gt;();//@3
        demo5.m1(demo5);
    }
}
</code></pre>
<p>如果我们想获取Demo5的具体信息，需要给Demo5创建一个之类才可以，此处我们可以使用java中的匿名内部类来友好的解决这个问题，将上面代码变换一下，变成下面这样：</p>
<pre><code class="language-java">package com.javacode2018.chat05.demo11;

import java.lang.reflect.ParameterizedType;
import java.lang.reflect.Type;

public class Demo5&lt;T1, T2&gt; { //@1
    public void m1(Demo5&lt;T1, T2&gt; demo) { //@2
        //demo6Class对应的是Demo6的Class对象
        Class&lt;? extends Demo5&gt; demoClass = demo.getClass();
        //获取Demo6的父类的详细类型信息，包含泛型信息
        Type genericSuperclass = demoClass.getGenericSuperclass();
        // 泛型类型用ParameterizedType接口表示，输出看一下是不是这个接口类型的
        System.out.println(genericSuperclass.getClass());
        if (genericSuperclass instanceof ParameterizedType) {
            ParameterizedType pt = (ParameterizedType) genericSuperclass;
            System.out.println(pt.getRawType());
            Type[] actualTypeArguments = pt.getActualTypeArguments();
            for (Type actualTypeArgument : actualTypeArguments) {
                System.out.println(actualTypeArgument.getTypeName());
            }
            System.out.println(pt.getOwnerType());
        }
    }

    public static void main(String[] args) {
        Demo5&lt;String, Integer&gt; demo5 = new Demo5&lt;String, Integer&gt;() {
        };//@3
        demo5.m1(demo5);
    }
}
</code></pre>
<p>关键代码在@3，这个地方利用了一个匿名内部类，相当于创建了Demo5的一个子类，并且指定了Demo5中两个泛型变量类型的具体类型。</p>
<p>运行代码输出：</p>
<pre><code class="language-shell">class sun.reflect.generics.reflectiveObjects.ParameterizedTypeImpl
class com.javacode2018.chat05.demo11.Demo5
java.lang.String
java.lang.Integer
null
</code></pre>
<p>这次我们获取到了泛型类中具体的类型了。</p>
<p>这种玩法在fastjson中有用到，再来看个案例：</p>
<pre><code class="language-java">package com.javacode2018.chat05.demo11;

import com.alibaba.fastjson.JSON;
import com.alibaba.fastjson.TypeReference;
import lombok.*;

import java.io.Serializable;

public class Demo7 {
    /**
     * 通用的返回值类型
     *
     * @param &lt;T&gt;
     */
    @Getter
    @Setter
    @ToString
    @Builder
    @NoArgsConstructor
    @AllArgsConstructor
    public static class Result&lt;T&gt; implements Serializable { //@1
        private String code;
        private String subCode;
        private String msg;
        private T data;
    }

    @Getter
    @Setter
    @Builder
    @ToString
    @NoArgsConstructor
    @AllArgsConstructor
    public static class UserModel { //@2
        private Integer id;
        private String name;
    }

    /**
     * 返回一个用户信息
     *
     * @return
     */
    public static Result&lt;UserModel&gt; getUser() { //@3
        UserModel userModel = UserModel.builder().id(1).name(&quot;路人甲Java&quot;).build();
        Result&lt;UserModel&gt; result = Result.&lt;UserModel&gt;builder().code(&quot;1&quot;).subCode(null).msg(&quot;操作成功&quot;).data(userModel).build();
        return result;
    }

    /**
     * 用户json信息
     *
     * @return
     */
    public static String getUserString() { //@4
        return JSON.toJSONString(getUser());
    }

    public static void main(String[] args) {
        String userString = getUserString();
        //会输出：{&quot;code&quot;:&quot;1&quot;,&quot;data&quot;:{&quot;id&quot;:1,&quot;name&quot;:&quot;路人甲Java&quot;},&quot;msg&quot;:&quot;操作成功&quot;}
        System.out.println(userString); //@5

        //下面我们需要将userString反序列化为Result&lt;UserModel&gt;对象
        Result&lt;UserModel&gt; userModelResult = JSON.parseObject(userString, new TypeReference&lt;Result&lt;UserModel&gt;&gt;() {
        }); //@6

        //我们来看看Result中的data是不是UserModel类型的
        System.out.println(userModelResult.getData().getClass()); //@6
    }
}
</code></pre>
<p>先看看运行结果：</p>
<pre><code class="language-shell">{&quot;code&quot;:&quot;1&quot;,&quot;data&quot;:{&quot;id&quot;:1,&quot;name&quot;:&quot;路人甲Java&quot;},&quot;msg&quot;:&quot;操作成功&quot;}
class com.javacode2018.chat05.demo11.Demo7$UserModel
</code></pre>
<ol>
<li>
<p>@1：创建了一个Result类型的，这个类型可以作为任何接口通用的返回值类型，这个大家可以借鉴，接口有几个通用的字段：code:状态码，subCode：子状态码，data：具体的任何类型的数据，data的具体类型可以在创建Result的时候指定，msg：接口返回的提示信息（如错误提示，操作成功等信息）。</p>
</li>
<li>
<p>@2：创建了一个用户类</p>
</li>
<li>
<p>@3：这个方法模拟返回一个用户的信息，用户信息封装在Result中。</p>
</li>
<li>
<p>@4：将用户信息转换为json字符串返回</p>
</li>
<li>
<p>@5：输出了用户信息字符串，也就是上面输出中的第一行的内容。</p>
</li>
<li>
<p>@6：这个是上面代码的关键，调用了fastjson中的方法，将字符串反序列化为<code>Result&lt;UserModel&gt;</code>，fastjson是如何获取泛型类Result中T的具体的类型的呢，T具体的类型对应的是<code>UserModel</code>，关键代码就是下面这行代码：</p>
<pre><code class="language-java">new TypeReference&lt;Result&lt;UserModel&gt;&gt;() {}
</code></pre>
</li>
</ol>
<p>这个相当于创建了一个<code>TypeReference</code>类的一个子类，注意<code>TypeReference</code>后面尖括号中的东西，是<code>&lt;UserModel&gt;</code>，通过这个指定了泛型变量类型的具体类型，我们去看一下<code>TypeReference</code>类源码，上一些关键代码：</p>
<pre><code class="language-java">public class TypeReference&lt;T&gt; {
    protected TypeReference(){
        Type superClass = getClass().getGenericSuperclass(); //@1

        Type type = ((ParameterizedType) superClass).getActualTypeArguments()[0]; //@2

        Type cachedType = classTypeCache.get(type);
        if (cachedType == null) {
            classTypeCache.putIfAbsent(type, type);
            cachedType = classTypeCache.get(type);
        }

        this.type = cachedType;
    }
}
</code></pre>
<p>注意上面的@1和@2是不是很熟悉了，fastjson中获取泛型的具体类型也是让我们采用匿名内部类去实现的，最后内部也是调用<code>getGenericSuperclass</code>去获取具体的泛型类型中具体的类型的。</p>
<p>fastjson maven配置：</p>
<pre><code class="language-xml">&lt;dependency&gt;
    &lt;groupId&gt;com.alibaba&lt;/groupId&gt;
    &lt;artifactId&gt;fastjson&lt;/artifactId&gt;
    &lt;version&gt;1.2.62&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<h2 id="通配符类型">通配符类型</h2>
<p>通配符在java中 使用?表示，例如：<code>? extends Number</code>和<code>? super Integer</code>。</p>
<p>java中通配符对应的类型是<code>WildcardType</code>接口，可以通过这个接口来获取通配符具体的各种信息。</p>
<h3 id="通配符上边界">通配符上边界</h3>
<p>通配符具体的类型，可以任意指定，但是我们可以限定通配符的上边界，上边界指定了这个通配符能够表示的最大的范围的类型。</p>
<p>比如：<code>？extends Integer</code>，那么?对应的具体类型只能是Integer本身或者其子类型。</p>
<h3 id="通配符上边界-1">通配符上边界</h3>
<p>也可以给通配符指定下边界，下边界定义了通配符能够表示的最小的类型。</p>
<p>比如：<code>? super C1</code>，那么?对应的具体类型只能是C1类型或者C1的父类型。</p>
<pre><code class="language-java">package com.javacode2018.chat05.demo11;

import java.lang.reflect.Method;
import java.lang.reflect.ParameterizedType;
import java.lang.reflect.Type;
import java.lang.reflect.WildcardType;
import java.util.List;
import java.util.Map;

public class Demo8 {
    public static class C1 { //@1
    }

    public static class C2 extends C1 { //@2
    }

    public static List&lt;?&gt; m1(Map&lt;? super C2, ? extends C1&gt; map) { //@3
        return null;
    }

    public static void main(String[] args) throws NoSuchMethodException {
        Method m1 = Demo8.class.getMethod(&quot;m1&quot;, Map.class);

        //获取m1方法参数泛型详细参数信息
        System.out.println(&quot;获取m1方法参数泛型详细参数信息&quot;);
        Type[] genericParameterTypes = m1.getGenericParameterTypes();
        for (Type genericParameterType : genericParameterTypes) {
            // m1的参数为Map&lt;? super C2, ? extends C1&gt;，这个是泛型类型的，所以是ParameterizedType接口类型
            if (genericParameterType instanceof ParameterizedType) { //@4
                ParameterizedType parameterizedType = (ParameterizedType) genericParameterType; //@5
                //下面获取Map后面两个尖括号中的泛型参数列表，对应? super C2, ? extends C1这部分的内容，这部分在java中对应WildcardType接口类型
                Type[] actualTypeArguments = parameterizedType.getActualTypeArguments(); //@6
                for (Type actualTypeArgument : actualTypeArguments) {
                    if (actualTypeArgument instanceof WildcardType) {
                        WildcardType wildcardType = (WildcardType) actualTypeArgument;
                        //获取通配符的名称，输出是?
                        System.out.println(&quot;通配符类型名称:&quot; + wildcardType.getTypeName());//@7
                        //获取通配符的上边界
                        Type[] upperBounds = wildcardType.getUpperBounds();
                        for (Type upperBound : upperBounds) {
                            System.out.println(&quot;通配符上边界类型：&quot; + upperBound.getTypeName());
                        }
                        //获取通配符的下边界
                        Type[] lowerBounds = wildcardType.getLowerBounds();
                        for (Type lowerBound : lowerBounds) {
                            System.out.println(&quot;通配符下边界类型:&quot; + lowerBound.getTypeName());
                        }
                        System.out.println(&quot;------------&quot;);
                    }
                }
            }
        }

        //获取返回值通配符详细信息
        System.out.println(&quot;获取m1方法返回值泛型类型详细信息&quot;);
        Type genericReturnType = m1.getGenericReturnType();
        // m1的返回值是List&lt;?&gt;，这个是个泛型类型，对应ParameterizedType接口，泛型中的具体类型是个通配符类型，通配符对应WildcardType接口类型
        if (genericReturnType instanceof ParameterizedType) { //@4
            ParameterizedType parameterizedType = (ParameterizedType) genericReturnType; //@5
            //下面获取List面两个尖括号中的泛型参数列表，对应?这部分的内容，这个是个通配符类型，这部分在java中对应WildcardType接口
            Type[] actualTypeArguments = parameterizedType.getActualTypeArguments();
            for (Type actualTypeArgument : actualTypeArguments) {
                if (actualTypeArgument instanceof WildcardType) {
                    WildcardType wildcardType = (WildcardType) actualTypeArgument;
                    //获取通配符的名称，输出是?
                    System.out.println(&quot;通配符类型名称:&quot; + wildcardType.getTypeName());
                    //获取通配符的上边界
                    Type[] upperBounds = wildcardType.getUpperBounds();
                    for (Type upperBound : upperBounds) {
                        System.out.println(&quot;通配符上边界类型：&quot; + upperBound.getTypeName());
                    }
                    //获取通配符的下边界
                    Type[] lowerBounds = wildcardType.getLowerBounds();
                    for (Type lowerBound : lowerBounds) {
                        System.out.println(&quot;通配符下边界类型:&quot; + lowerBound.getTypeName());
                    }
                    System.out.println(&quot;------------&quot;);
                }
            }
        }
    }

}
</code></pre>
<p>输出：</p>
<pre><code class="language-shell">获取m1方法参数泛型详细参数信息
通配符类型名称:? super com.javacode2018.chat05.demo11.Demo8$C2
通配符上边界类型：java.lang.Object
通配符下边界类型:com.javacode2018.chat05.demo11.Demo8$C2
------------
通配符类型名称:? extends com.javacode2018.chat05.demo11.Demo8$C1
通配符上边界类型：com.javacode2018.chat05.demo11.Demo8$C1
------------
获取m1方法返回值泛型类型详细信息
通配符类型名称:?
通配符上边界类型：java.lang.Object
------------
</code></pre>
<p>具体的就不解释了，只需要注意一点?通配符的信息使用WildcardType接口表示，可以通过这个接口获取通配符的详细信息。</p>
<h2 id="泛型数组">泛型数组</h2>
<h3 id="什么是泛型数组">什么是泛型数组？</h3>
<p>数组中的元素为泛型，那么这个数组就是泛型类型的数组，泛型数组在java中使用<code>GenericArrayType</code>接口来表示，可以通过这个接口提供的方法获取泛型数组更详细的信息。</p>
<p>如：<code>List&lt;String&gt; list [];</code> <code>List&lt;String&gt; list [][];</code></p>
<p>泛型数组类型的可以作为方法的参数、方法的返回值、泛型类的具体类型、字段的类型等等。</p>
<p>下面就以泛型字段来举例，一起来获取泛型字段的详细信息。</p>
<pre><code class="language-java">package com.javacode2018.chat05.demo11;

import java.lang.reflect.*;
import java.util.List;
import java.util.Map;

public class Demo9 {

    List&lt;String&gt; list[]; //@1

    public static void main(String[] args) throws NoSuchFieldException {
        Field list = Demo9.class.getDeclaredField(&quot;list&quot;);
        //获取字段的泛型类型
        Type genericType = list.getGenericType(); //@2
        //看看字段的具体泛型类型
        System.out.println(genericType.getClass()); //@3
        if (genericType instanceof GenericArrayType) {
            GenericArrayType genericArrayType = (GenericArrayType) genericType;
            //获取数组的具体类型，具体的类型就是List&lt;String&gt;，这个是个泛型类型，对应java中的ParameterizedType接口
            Type genericComponentType = genericArrayType.getGenericComponentType();//@4
            System.out.println(genericComponentType.getClass());
            if (genericComponentType instanceof ParameterizedType) {
                ParameterizedType parameterizedType = (ParameterizedType) genericComponentType;
                System.out.println(parameterizedType.getRawType());
                //调用getActualTypeArguments()获取List&lt;String&gt;中尖括号中的参数列表
                Type[] actualTypeArguments = parameterizedType.getActualTypeArguments();//@5
                for (Type actualTypeArgument : actualTypeArguments) {
                    System.out.println(actualTypeArgument.getTypeName());
                }
                System.out.println(parameterizedType.getOwnerType());
            }

        }
    }

}
</code></pre>
<p>运行输出：</p>
<pre><code class="language-shell">class sun.reflect.generics.reflectiveObjects.GenericArrayTypeImpl
class sun.reflect.generics.reflectiveObjects.ParameterizedTypeImpl
interface java.util.List
java.lang.String
null
</code></pre>
<p>代码解读：</p>
<ol>
<li>
<p>@1：声明了一个泛型类型的数组。</p>
</li>
<li>
<p>@2：获取list字段对应的泛型数组类型，泛型数组在java中使用<code>GenericArrayType</code>表示，所以@3输出是<code>GenericArrayType</code>接口类型的。</p>
</li>
<li>
<p>@4：调用<code>GenericArrayType</code>接口中的<code>getGenericComponentType</code>方法会返回数组的具体的泛型类型，这个地方对应的就是<code>List&lt;String&gt;</code>，这个是个泛型类型，泛型类型在java中使用<code>ParameterizedType</code>接口表示的。</p>
</li>
<li>
<p>@5：调用了<code>ParameterizedType</code>接口中的<code>getActualTypeArguments</code>方法，这个方法可以获取泛型类型中具体的类型列表，就是List后面尖括号中的参数列表。</p>
</li>
</ol>
<h2 id="综合案例">综合案例</h2>
<p>代码如下：</p>
<pre><code class="language-java">package com.javacode2018.chat05.demo11;


import java.util.List;
import java.util.Map;

public class Demo10&lt;K, V&gt; {

    Map&lt;String, ? extends List&lt;? extends Map&lt;K, V&gt;&gt;&gt; [][] map;
}
</code></pre>
<p>上面这个挺复杂的，我们一步步拆解解析一下，步骤如下：</p>
<ul>
<li>1、<code>Demo10&lt;K, V&gt;</code>：  --------&gt; 对应java中的<code>Class</code>对象</li>
<li>2、<code>&lt;K, V&gt;</code>：定义了2个泛型变量，泛型变量对应<code>TypeVariable</code>接口</li>
<li>3、<code>Map&lt;String, ? extends List&lt;? extends Map&lt;K, V&gt;&gt;&gt; [][]map</code>：定义了一个二维泛型数组，泛型数组用<code>GenericArrayType</code>接口表示</li>
<li>4、map中的每个元素是这个是<code>Map&lt;String, ? extends List&lt;? extends Map&lt;K, V&gt;&gt;&gt; []</code>类型的，是一个一维泛型数组，泛型数组用<code>GenericArrayType</code>接口表示。</li>
<li>5、再继续拆解，<code>Map&lt;String, ? extends List&lt;? extends Map&lt;K, V&gt;&gt;&gt; []</code>中每个元素是<code>Map&lt;String, ? extends List&lt;? extends Map&lt;K, V&gt;&gt;&gt;</code>泛型类型的，泛型类型在java中使用<code>ParameterizedType</code>接口表示</li>
<li>6、拆解<code>Map&lt;String, ? extends List&lt;? extends Map&lt;K, V&gt;&gt;&gt;</code>后面尖括号中的参数列表，可以调用<code>ParameterizedType</code>接口的<code>Type[] getActualTypeArguments()</code>方法获取，<code>Map</code>后面的尖括号中有2个参数，分别是<code>String</code>和<code>? extends List&lt;? extends Map&lt;K, V&gt;&gt;</code></li>
<li>7、String是java中定义的类型，对应java中的Class对象</li>
<li>8、<code>? extends List&lt;? extends Map&lt;K, V&gt;&gt;</code>是通配符类型的，对应<code>WildcardType</code>接口，通配符指定了上边界，上边界是<code>List&lt;? extends Map&lt;K, V&gt;&gt;</code></li>
<li>9、<code>List&lt;? extends Map&lt;K, V&gt;&gt;</code>又是一个泛型类型，泛型类型对应<code>ParameterizedType</code>接口，<code>List&lt;? extends Map&lt;K, V&gt;&gt;</code>的尖括号中又定义了这个泛型类型的具体的类型<code>? extends Map&lt;K, V&gt;</code></li>
<li>10、<code>? extends Map&lt;K, V&gt;</code>又是一个通配符类型，对应<code>WildcardType</code>接口,这个通配符指定了上边界为<code>Map&lt;K,V&gt;</code></li>
<li>11、<code>Map&lt;K,V&gt;</code>又对应泛型类型，泛型类型对应<code>ParameterizedType</code>接口，调用这个接口的<code>getActualTypeArguments()</code>方法获取泛型中的参数列表K和V</li>
<li>12、K和V是Demo10中定义的泛型变量类型，泛型变量类型对应<code>TypeVariable</code>接口
按照上面的思路，我们来完善一下解析代码：</li>
</ul>
<pre><code class="language-java">package com.javacode2018.chat05.demo11;


import sun.security.util.Length;

import java.lang.reflect.*;
import java.util.List;
import java.util.Map;

public class Demo10&lt;K, V&gt; {

    Map&lt;String, ? extends List&lt;? extends Map&lt;K, V&gt;&gt;&gt;[][] map;

    public static void parseType(Type type, int level) {
        String whileString = whileString(level);
        if (type instanceof GenericArrayType) {
            System.out.println(whileString + &quot;泛型数组类型:&quot; + type);
            parseType(((GenericArrayType) type).getGenericComponentType(), ++level);
        } else if (type instanceof ParameterizedType) {
            System.out.println(whileString + &quot;泛型类型:&quot; + type);
            ParameterizedType parameterizedType = (ParameterizedType) type;
            System.out.println(whileString + &quot;实际类型:&quot; + parameterizedType.getRawType());
            Type[] actualTypeArguments = parameterizedType.getActualTypeArguments();
            System.out.println(whileString + actualTypeArguments.length + &quot;个泛型参数,如下：&quot;);
            int count = 0;
            for (Type actualTypeArgument : actualTypeArguments) {
                if (count++ == 0) {
                    level++;
                }
                parseType(actualTypeArgument, level);
            }
        } else if (type instanceof WildcardType) {
            System.out.println(whileString + &quot;通配符类型:&quot; + type);
            WildcardType wildcardType = ((WildcardType) type);
            System.out.println(whileString + &quot;通配符类型名称:&quot; + wildcardType.getTypeName());
            Type[] upperBounds = wildcardType.getUpperBounds();
            System.out.println(whileString + &quot;上边界列表&quot;);
            int count = 0;
            for (Type upperBound : upperBounds) {
                if (count++ == 0) {
                    level++;
                }
                parseType(upperBound, level);
            }
            System.out.println(whileString + &quot;下边界列表&quot;);
            Type[] lowerBounds = wildcardType.getLowerBounds();
            for (Type lowerBound : lowerBounds) {
                if (count++ == 0) {
                    level++;
                }
                parseType(lowerBound, level);
            }
        } else if (type instanceof TypeVariable) {
            System.out.println(whileString + &quot;泛型变量类型:&quot; + type);
            TypeVariable typeVariable = ((TypeVariable) type);
            Type[] bounds = typeVariable.getBounds();
            System.out.println(whileString + &quot;泛型变量上边界列表&quot;);
            int count = 0;
            for (Type bound : bounds) {
                if (count++ == 0) {
                    level++;
                }
                parseType(bound, level);
            }
        } else if (type instanceof Class) {
            System.out.println(whileString + &quot;普通类型:&quot; + ((Class) type).getName());
        }
    }

    public static String whileString(int count) {
        StringBuilder sb = new StringBuilder();
        for (int i = 0; i &lt; count; i++) {
            sb.append(&quot;----&quot;);
        }
        return sb.toString();
    }

    public static void main(String[] args) throws NoSuchFieldException {
        parseType(Demo10.class.getDeclaredField(&quot;map&quot;).getGenericType(), 0);
    }
}
</code></pre>
<p>运行输出：</p>
<pre><code class="language-shell">泛型数组类型:java.util.Map&lt;java.lang.String, ? extends java.util.List&lt;? extends java.util.Map&lt;K, V&gt;&gt;&gt;[][]
----泛型数组类型:java.util.Map&lt;java.lang.String, ? extends java.util.List&lt;? extends java.util.Map&lt;K, V&gt;&gt;&gt;[]
--------泛型类型:java.util.Map&lt;java.lang.String, ? extends java.util.List&lt;? extends java.util.Map&lt;K, V&gt;&gt;&gt;
--------实际类型:interface java.util.Map
--------2个泛型参数,如下：
------------普通类型:java.lang.String
------------通配符类型:? extends java.util.List&lt;? extends java.util.Map&lt;K, V&gt;&gt;
------------通配符类型名称:? extends java.util.List&lt;? extends java.util.Map&lt;K, V&gt;&gt;
------------上边界列表
----------------泛型类型:java.util.List&lt;? extends java.util.Map&lt;K, V&gt;&gt;
----------------实际类型:interface java.util.List
----------------1个泛型参数,如下：
--------------------通配符类型:? extends java.util.Map&lt;K, V&gt;
--------------------通配符类型名称:? extends java.util.Map&lt;K, V&gt;
--------------------上边界列表
------------------------泛型类型:java.util.Map&lt;K, V&gt;
------------------------实际类型:interface java.util.Map
------------------------2个泛型参数,如下：
----------------------------泛型变量类型:K
----------------------------泛型变量上边界列表
--------------------------------普通类型:java.lang.Object
----------------------------泛型变量类型:V
----------------------------泛型变量上边界列表
--------------------------------普通类型:java.lang.Object
--------------------下边界列表
------------下边界列表
</code></pre>
<p>上将map这个属性详细的泛型信息都输出出来了，重点在于上面的<code>parseType</code>方法，java中的类型无非就是5种表示类型，这个方法内部使用递归来解析这些类型。</p>
<h2 id="总结">总结</h2>
<p>泛型解析需要一步步拆解，会被拆解为5中类型中的一种，需要理解5中类型分别对应什么，这个是关键</p>
<p>本篇内容比较多，建议每个案例大家都去自己写一下，体验一下，加深理解</p>
<p>如果对泛型有任何疑问的可以留言交流</p></div><footer class="theme-doc-footer docusaurus-mt-lg"><div class="theme-doc-footer-edit-meta-row row"><div class="col"><a href="https://github.com/lorchr/light-docusaurus/tree/main/docs/zh-cn/java/20-Java-Generic-Type.md" target="_blank" rel="noopener noreferrer" class="theme-edit-this-page"><svg fill="currentColor" height="20" width="20" viewBox="0 0 40 40" class="iconEdit_Z9Sw" aria-hidden="true"><g><path d="m34.5 11.7l-3 3.1-6.3-6.3 3.1-3q0.5-0.5 1.2-0.5t1.1 0.5l3.9 3.9q0.5 0.4 0.5 1.1t-0.5 1.2z m-29.5 17.1l18.4-18.5 6.3 6.3-18.4 18.4h-6.3v-6.2z"></path></g></svg>编辑此页</a></div><div class="col lastUpdated_vwxv"></div></div></footer></article><nav class="pagination-nav docusaurus-mt-lg" aria-label="文件选项卡"><a class="pagination-nav__link pagination-nav__link--prev" href="/light-docusaurus/docs/zh-cn/java/Java-Lock/"><div class="pagination-nav__sublabel">上一页</div><div class="pagination-nav__label">Java-Lock</div></a><a class="pagination-nav__link pagination-nav__link--next" href="/light-docusaurus/docs/category/spring-boot/"><div class="pagination-nav__sublabel">下一页</div><div class="pagination-nav__label">Spring Boot</div></a></nav></div></div><div class="col col--3"><div class="tableOfContents_bqdL thin-scrollbar theme-doc-toc-desktop"><ul class="table-of-contents table-of-contents__left-border"><li><a href="#type接口" class="table-of-contents__link toc-highlight">Type接口</a></li><li><a href="#genericdeclaration接 口" class="table-of-contents__link toc-highlight">GenericDeclaration接口</a><ul><li><a href="#类中定义泛型变量类型" class="table-of-contents__link toc-highlight">类中定义泛型变量类型</a></li><li><a href="#方法中定义泛型变量类型" class="table-of-contents__link toc-highlight">方法中定义泛型变量类型</a></li></ul></li><li><a href="#class类" class="table-of-contents__link toc-highlight">Class类</a><ul><li><a href="#class对象获取方式" class="table-of-contents__link toc-highlight">Class对象获取方式</a></li><li><a href="#常用的方法" class="table-of-contents__link toc-highlight">常用的方法</a></li></ul></li><li><a href="#method类" class="table-of-contents__link toc-highlight">Method类</a><ul><li><a href="#常用的方法-1" class="table-of-contents__link toc-highlight">常用的方法</a></li></ul></li><li><a href="#field类" class="table-of-contents__link toc-highlight">Field类</a><ul><li><a href="#常用的方法-2" class="table-of-contents__link toc-highlight">常用的方法</a></li></ul></li><li><a href="#parameterizedtype接口" class="table-of-contents__link toc-highlight">ParameterizedType接口</a></li><li><a href="#常用方法" class="table-of-contents__link toc-highlight">常用方法</a><ul><li><a href="#type-getactualtypearguments" class="table-of-contents__link toc-highlight"><code>Type[] getActualTypeArguments()</code></a></li><li><a href="#type-getrawtype" class="table-of-contents__link toc-highlight"><code>Type getRawType()</code></a></li><li><a href="#type--getownertype" class="table-of-contents__link toc-highlight"><code>Type[]  getOwnerType()</code></a></li></ul></li><li><a href="#typevariable接口" class="table-of-contents__link toc-highlight">TypeVariable接口</a><ul><li><a href="#常用的方法-3" class="table-of-contents__link toc-highlight">常用的方法</a></li></ul></li><li><a href="#wildcardtype接口" class="table-of-contents__link toc-highlight">WildcardType接口</a><ul><li><a href="#常用方法-1" class="table-of-contents__link toc-highlight">常用方法</a></li></ul></li><li><a href="#genericarraytype接口" class="table-of-contents__link toc-highlight">GenericArrayType接口</a><ul><li><a href="#常用方法-2" class="table-of-contents__link toc-highlight">常用方法</a></li></ul></li><li><a href="#泛型变量" class="table-of-contents__link toc-highlight">泛型变量</a></li><li><a href="#类中定义泛型变量" class="table-of-contents__link toc-highlight">类中定义泛型变量</a><ul><li><a href="#语法" class="table-of-contents__link toc-highlight">语法</a></li></ul></li><li><a href="#方法中定义泛型变量" class="table-of-contents__link toc-highlight">方法中定义泛型变量</a><ul><li><a href="#语法-1" class="table-of-contents__link toc-highlight">语法</a></li></ul></li><li><a href="#泛型类型" class="table-of-contents__link toc-highlight">泛型类型</a><ul><li><a href="#泛型类型定义的语法" class="table-of-contents__link toc-highlight">泛型类型定义的语法</a></li></ul></li><li><a href="#方法中泛型参数和泛型返回值" class="table-of-contents__link toc-highlight">方法中泛型参数和泛型返回值</a></li><li><a href="#泛型类" class="table-of-contents__link toc-highlight">泛型类</a><ul><li><a href="#泛型类的定义" class="table-of-contents__link toc-highlight">泛型类的定义</a></li></ul></li><li><a href="#通配符类型" class="table-of-contents__link toc-highlight">通配符类型</a><ul><li><a href="#通配符上边界" class="table-of-contents__link toc-highlight">通配符上边界</a></li><li><a href="#通配符上边界-1" class="table-of-contents__link toc-highlight">通配符上边界</a></li></ul></li><li><a href="#泛型数组" class="table-of-contents__link toc-highlight">泛型数组</a><ul><li><a href="#什么是泛型数组" class="table-of-contents__link toc-highlight">什么是泛型数组？</a></li></ul></li><li><a href="#综合案例" class="table-of-contents__link toc-highlight">综合案例</a></li><li><a href="#  总结" class="table-of-contents__link toc-highlight">总结</a></li></ul></div></div></div></div></main></div></div></div><footer class="footer footer--dark"><div class="container container-fluid"><div class="row footer__links"><div class="col footer__col"><div class="footer__title">Docs</div><ul class="footer__items clean-list"><li class="footer__item"><a class="footer__link-item" href="/light-docusaurus/docs/category/guide/">Torch</a></li><li class="footer__item"><a class="footer__link-item" href="/light-docusaurus/middleware/">Middleware</a></li><li class="footer__item"><a class="footer__link-item" href="/light-docusaurus/electron/">Electron</a></li></ul></div><div class="col footer__col"><div class="footer__title">Community</div><ul class="footer__items clean-list"><li class="footer__item"><a href="https://stackoverflow.com/questions/tagged/lorchr" target="_blank" rel="noopener noreferrer" class="footer__link-item">Stack Overflow<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li><li class="footer__item"><a href="https://discordapp.com/invite/lorchr" target="_blank" rel="noopener noreferrer" class="footer__link-item">Discord<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li><li class="footer__item"><a href="https://twitter.com/lorchr" target="_blank" rel="noopener noreferrer" class="footer__link-item">Twitter<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li></ul></div><div class="col footer__col"><div class="footer__title">More</div><ul class="footer__items clean-list"><li class="footer__item"><a class="footer__link-item" href="/light-docusaurus/blog/">Blog</a></li><li class="footer__item"><a class="footer__link-item" href="/light-docusaurus/diy/">DIY</a></li><li class="footer__item"><a href="https://github.com/lorchr/light-docusaurus" target="_blank" rel="noopener noreferrer" class="footer__link-item">GitHub<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li></ul></div><div class="col footer__col"><div class="footer__title">Offical</div><ul class="footer__items clean-list"><li class="footer__item"><a href="https://docusaurus.io" target="_blank" rel="noopener noreferrer" class="footer__link-item">Home<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li><li class="footer__item"><a href="https://github.com/facebook/docusaurus" target="_blank" rel="noopener noreferrer" class="footer__link-item">Github<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li><li class="footer__item"><a href="https://docusaurus.io/docs/playground" target="_blank" rel="noopener noreferrer" class="footer__link-item">Playground<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li></ul></div></div><div class="footer__bottom text--center"><div class="footer__copyright">Copyright © 2024 Light-Docusaurus, Inc. Built with Docusaurus.</div></div></div></footer></div>
</body>
</html>